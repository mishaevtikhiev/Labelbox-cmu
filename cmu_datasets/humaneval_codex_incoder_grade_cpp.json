[
  {
    "intent": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string value) {\n",
    "task_id": "99",
    "prompt": "/*\nCreate a function that takes a value (string) representing a number\nand returns the closest integer to it. If the number is equidistant\nfrom two integers, round it away from zero.\n\nExamples\n>>> closest_integer(\"10\")\n10\n>>> closest_integer(\"15.3\")\n15\n\nNote:\nRounding away from zero means that if the given number is equidistant\nfrom two integers, the one you should return is the one that is the\nfarthest from zero. For example closest_integer(\"14.5\") should\nreturn 15 and closest_integer(\"-14.5\") should return -15.\n*/\n#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\nint closest_integer(string value){\n",
    "simplified_intent": "Create a function that takes a value (string) representing a number and returns the closest integer to it. If the number is equidistant from two integers, round it away from zero.",
    "snippet": [
      "    double w;\n    w=atof(value.c_str());\n    return round(w);\n}\n"
    ],
    "sample_from": {
      "0": "incoder",
      "1": "incoder",
      "2": "incoder",
      "3": "codex",
      "4": "codex",
      "5": "codex"
    },
    "0": "long num;\n    // Using stringstream to avoid having to use atoi or atof functions\n    // for converting strings to numbers. This is faster than using atoi\n    // and atof functions in loops for large strings\n    std::istringstream str(value);\n    // Get rid of any whitespace\n    str.ignore(std::numeric_limits<std::streamsize>::max(), '\\n');\n    // Convert string to number\n    str >> num;\n    // Convert number to closest integer\n    long closest;\n    if (abs(num - closest) < abs(num - closest * 2)) {\n        closest = num;\n    }\n    return closest;",
    "grade-0": {
      "execution": 0
    },
    "1": "long x = 0;\n    if (value.size() == 0) return 0;\n\n    long y = 0;\n\n    long last_value = 0;\n\n    long last_y = 0;\n\n    for (auto & i : value) {\n        i = i - '0';\n        y = y * 10 + i;\n        x = x * 10 + i;\n    }\n\n    for (auto & i : value) {\n        i = i - '0';\n        if (i == last_value) continue;\n        last_value = i;\n        last_y = y;\n        last_x = x;\n        y = i * 10 + y;\n        x = i * 10 + x;\n    }\n\n    if (last_value == 0) {\n        return x;\n    } else if (last_value == 1) {\n        return y;\n    } else if (last_value == 2) {\n        return x;\n    } else if (last_value == 3) {\n        return y;\n    } else if (last_value == 4) {\n        return x;\n    } else if (last_value == 5) {\n        return -y;\n    } else if (last_value == 6) {\n        return -y;\n    } else if (last_value == 7) {\n        return -y;\n    } else if (last_value == 8) {\n        return -y;\n    } else if (last_value == 9) {\n        return -y;\n    } else if (last_value == -1) {\n        return -y;\n    } else if (last_value == -2) {\n        return -y;\n    } else if (last_value == -3) {\n        return -y;\n    } else if (last_value == -4) {\n        return -y;\n    } else if (last_value == -5) {\n        return -y;\n    } else if (last_value == -6) {\n        return -y;\n    } else if (last_value == -7) {\n        return -y;\n    } else if (last_value == -8) {\n        return -y;\n    } else if (last_value == -9) {\n        return -y;\n    } else if (last_value == -10) {\n        return -y;\n    }",
    "grade-1": {
      "execution": 0
    },
    "2": "int x = atof(value.c_str());\n    return round(x/10)*10;",
    "grade-2": {
      "execution": 0
    },
    "3": "long result = 0;\n    double number = stod(value);\n    if (number >= 0) {\n        result = (long) number;\n        if (number-result >= 0.5) {\n            result++;\n        }\n    } else {\n        result = (long) number;\n        if (result-number >= 0.5) {\n            result--;\n        }\n    }\n    return result;",
    "grade-3": {
      "execution": 1
    },
    "4": "return value.find(\".\") == std::string::npos ? std::stol(value) :\n\t\tstd::stol(value.substr(0, value.find(\".\"))) + (value.back() > '4');",
    "grade-4": {
      "execution": 0
    },
    "5": "double num = std::stod(value);\n\treturn std::round(num);",
    "grade-5": {
      "execution": 1
    }
  },
  {
    "intent": "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string text, replace all spaces in it with underscores, \n// and if a string has more than 2 consecutive spaces, \n// then replace all consecutive spaces with - \n// fix_spaces(\"Example\") == \"Example\"\n// fix_spaces(\"Example 1\") == \"Example_1\"\n// fix_spaces(\" Example 2\") == \"_Example_2\"\n// fix_spaces(\" Example   3\") == \"_Example-3\"\nstd::string fix_spaces(std::string text) {\n",
    "task_id": "140",
    "prompt": "/*\nGiven a string text, replace all spaces in it with underscores, \nand if a string has more than 2 consecutive spaces, \nthen replace all consecutive spaces with - \n\nfix_spaces(\"Example\") == \"Example\"\nfix_spaces(\"Example 1\") == \"Example_1\"\nfix_spaces(\" Example 2\") == \"_Example_2\"\nfix_spaces(\" Example   3\") == \"_Example-3\"\n*/\n#include<stdio.h>\n#include<string>\nusing namespace std;\nstring fix_spaces(string text){\n",
    "simplified_intent": "Given a string text, replace all spaces in it with underscores, and if a string has more than 2 consecutive spaces, then replace all consecutive spaces with -",
    "snippet": [
      "    string out=\"\";\n    int spacelen=0;\n    for (int i=0;i<text.length();i++)\n    if (text[i]==' ') spacelen+=1;\n    else\n    {\n        if (spacelen==1) out=out+'_';\n        if (spacelen==2) out=out+\"__\";\n        if (spacelen>2) out=out+'-';\n        spacelen=0;\n        out=out+text[i];\n    }\n    if (spacelen==1) out=out+'_';\n    if (spacelen==2) out=out+\"__\";\n    if (spacelen>2) out=out+'-';\n    return out;\n}\n"
    ],
    "sample_from": {
      "0": "incoder",
      "1": "incoder",
      "2": "incoder",
      "3": "codex",
      "4": "codex",
      "5": "codex"
    },
    "0": "std::replace_if(text.begin(), text.end(), \n    [](char ch) {\n      return (std::isspace(ch) || std::isspace(std::prev_element(text.begin(), text.end()))) ? \"_\" : ch;\n    }, ' ');\n  if (text.size() > 2 && text[0] == ' ')\n    return fix_spaces(text.substr(1));\n  return text;",
    "grade-0": {
      "execution": 0
    },
    "1": "size_t start = 0;\n\tsize_t end = text.length();\n\tbool flag = false;\n\twhile (flag == false) {\n\t\tstart = text.find(' ', start);\n\t\tend = text.find(' ', end);\n\t\tif (end != std::string::npos)\n\t\t\tif (end - start > 1)\n\t\t\t\ttext = text.substr(0, start) + \"_\" + text.substr(start + 1, end - 1);\n\t\telse {\n\t\t\tflag = true;\n\t\t}\n\t}\n\treturn text;",
    "grade-1": {
      "execution": 0
    },
    "2": "std::string ans;\n    std::string space=\"_\";\n    std::string newspace=\" \";\n    std::size_t found = text.find(space);\n    while(found != std::string::npos) {\n        ans = ans + text.substr(0,found);\n        ans = ans + newspace;\n        ans = ans + text.substr(found+1,text.length());\n        found = text.find(space,found+1);\n    }\n    ans = ans + text;\n    return ans;",
    "grade-2": {
      "execution": 0
    },
    "3": "std::string result = \"\";\n    int count = 0;\n    for (int i = 0; i < text.length(); i++) {\n        if (text[i] == ' ') {\n            count++;\n            if (count > 2) {\n                continue;\n            }\n            result += '_';\n        } else {\n            if (count > 2) {\n                result += '-';\n            }\n            count = 0;\n            result += text[i];\n        }\n    }\n    return result;",
    "grade-3": {
      "execution": 0
    },
    "4": "text.erase(remove(text.begin(), text.end(), ' '), text.end());\n    for (int i = 0; i < text.size(); i++) {\n        if (text[i] == ' ') {\n            text[i] = '_';\n        }\n    }\n    return text;",
    "grade-4": {
      "execution": 0
    },
    "5": "int num_spaces = 0;\n    int len = text.length();\n    for (int i = 0; i < len; i++) {\n        if (text[i] == ' ') {\n            num_spaces++;\n        }\n    }\n    int new_len = len + num_spaces*2;\n    char s[new_len];\n    // int start = new_len-1;\n    for (int i = len-1; i >= 0; i--) {\n        if (text[i] == ' ') {\n            num_spaces--;\n            if (num_spaces == 0) {\n                s[new_len-1] = '_';\n                new_len--;\n            } else {\n                s[new_len-1] = '-';\n                new_len--;\n            }\n        } else {\n            s[new_len-1] = text[i];\n            new_len--;\n        }\n    }\n    // std::cout << text.c_str() << \" : \" << s << std::endl;\n    return std::string(s);",
    "grade-5": {
      "execution": 0
    }
  },
  {
    "intent": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that takes an array of numbers as input and returns \n// the number of elements in the array that are greater than 10 and both \n// first and last digits of a number are odd (1, 3, 5, 7, 9).\n// For example:\n// specialFilter([15, -73, 14, -15]) => 1 \n// specialFilter([33, -2, -3, 45, 21, 109]) => 2\nlong specialFilter(std::vector<long> nums) {\n",
    "task_id": "146",
    "prompt": "/*\nWrite a function that takes a vector of numbers as input and returns \nthe number of elements in the vector that are greater than 10 and both \nfirst and last digits of a number are odd (1, 3, 5, 7, 9).\nFor example:\nspecialFilter({15, -73, 14, -15}) => 1 \nspecialFilter({33, -2, -3, 45, 21, 109}) => 2\n*/\n#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\nint specialFilter(vector<int> nums){\n",
    "simplified_intent": "Write a function that takes an array of numbers as input and returns the number of elements in the array that are greater than 10 and both first and last digits of a number are odd (1, 3, 5, 7, 9).",
    "snippet": [
      "    int num=0;\n    for (int i=0;i<nums.size();i++)\n    if (nums[i]>10)\n    {\n        string w=to_string(nums[i]);\n        if (w[0]%2==1 and w[w.length()-1]%2==1) num+=1;\n    }\n    return num;\n}\n"
    ],
    "sample_from": {
      "0": "incoder",
      "1": "incoder",
      "2": "incoder",
      "3": "codex",
      "4": "codex",
      "5": "codex"
    },
    "0": "int count = 0;\n  for (int i = 0; i < nums.size(); i++) {\n    if (nums[i] >= 10 && nums[i] % 2 == 1 && nums[i] % 3 == 1) {\n      count++;\n    }\n  }\n  return count;",
    "grade-0": {
      "execution": 0
    },
    "1": "long ans = 0;\n    for (auto &i : nums) \n    {\n        if (i%2 == 0 && (i<10) && (i>=0) && (i<10))\n        {\n            ans += 1;\n        }\n    }\n    return ans;",
    "grade-1": {
      "execution": 0
    },
    "2": "long count = 0;\n    // Write your code\n    for (auto &n: nums) \n        if (n > 10 && n % 2 == 1 && n % 2 != 0) \n            ++count; \n    return count;",
    "grade-2": {
      "execution": 0
    },
    "3": "long result = 0;\n  for (auto num : nums) {\n    long last = num % 10;\n    while (num > 9) num /= 10;\n    if (num % 2 != 0 && last % 2 != 0 && num > 10) ++result;\n  }\n  return result;",
    "grade-3": {
      "execution": 0
    },
    "4": "int count=0;\n  for(int i=0;i<nums.size();i++)\n  {\n    int check=0;\n    long n=nums[i];\n    if(n>10)\n    {\n      if(n<0)\n      {\n        n=-n;\n      }\n      while(n!=0)\n      {\n        if(n%10==1 || n%10==3 || n%10==5 || n%10==7 || n%10==9)\n        {\n          check++;\n        }\n        n=n/10;\n      }\n      if(check==2)\n      {\n        count++;\n      }\n    }\n  }\n  return count;",
    "grade-4": {
      "execution": 1
    },
    "5": "// Write your code here.\n\tint count = 0;\n\tfor (int i = 0; i < nums.size(); i++) {\n\t\tint lastDigit = nums[i] % 10;\n\t\tint firstDigit = nums[i];\n\t\twhile (firstDigit > 9) {\n\t\t\tfirstDigit = firstDigit / 10;\n\t\t}\n\t\tif (lastDigit % 2 != 0 && firstDigit % 2 != 0 && nums[i] > 10) {\n\t\t\tcount++;\n\t\t}\n\t}\n\treturn count;",
    "grade-5": {
      "execution": 1
    }
  },
  {
    "intent": "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the name of a class (a string) and a list of extensions.\n// The extensions are to be used to load additional classes to the class. The\n// strength of the extension is as follows: Let CAP be the number of the uppercase\n// letters in the extension's name, and let SM be the number of lowercase letters \n// in the extension's name, the strength is given by the fraction CAP - SM. \n// You should find the strongest extension and return a string in this \n// format: ClassName.StrongestExtensionName.\n// If there are two or more extensions with the same strength, you should\n// choose the one that comes first in the list.\n// For example, if you are given \"Slices\" as the class and a list of the\n// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n// (its strength is -1).\n// Example:\n// for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\nstd::string Strongest_Extension(std::string class_name, std::vector<std::string> extensions) {\n",
    "task_id": "153",
    "prompt": "/*\nYou will be given the name of a class (a string) and a vector of extensions.\nThe extensions are to be used to load additional classes to the class. The\nstrength of the extension is as follows: Let CAP be the number of the uppercase\nletters in the extension's name, and let SM be the number of lowercase letters \nin the extension's name, the strength is given by the fraction CAP - SM. \nYou should find the strongest extension and return a string in this \nformat: ClassName.StrongestExtensionName.\nIf there are two or more extensions with the same strength, you should\nchoose the one that comes first in the vector.\nFor example, if you are given \"Slices\" as the class and a vector of the\nextensions: {\"SErviNGSliCes\", \"Cheese\", \"StuFfed\"} then you should\nreturn \"Slices.SErviNGSliCes\" since \"SErviNGSliCes\" is the strongest extension \n(its strength is -1).\nExample:\nfor Strongest_Extension(\"my_class\", {\"AA\", \"Be\", \"CC\"}) == \"my_class.AA\"\n*/\n#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\nstring Strongest_Extension(string class_name,vector<string> extensions){\n",
    "simplified_intent": "You will be given the name of a class (a string) and a list of extensions. The extensions are to be used to load additional classes to the class. The strength of the extension is as follows: Let CAP be the number of the uppercase letters in the extension's name, and let SM be the number of lowercase letters in the extension's name, the strength is given by the fraction CAP - SM. You should find the strongest extension and return a string in this format: ClassName.StrongestExtensionName. If there are two or more extensions with the same strength, you should choose the one that comes first in the list. For example, if you are given \"Slices\" as the class and a list of the extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension (its strength is -1).",
    "snippet": [
      "    string strongest=\"\";\n    int max=-1000;\n    for (int i=0;i<extensions.size();i++)\n    {\n        int strength=0;\n        for (int j=0;j<extensions[i].length();j++)\n        {\n            char chr=extensions[i][j];\n            if (chr>=65 and chr<=90) strength+=1;\n            if (chr>=97 and chr<=122) strength-=1;\n        }\n        if (strength>max) \n        {\n            max=strength;\n            strongest=extensions[i];\n        }\n    }\n    return class_name+'.'+strongest;\n}\n"
    ],
    "sample_from": {
      "0": "incoder",
      "1": "incoder",
      "2": "incoder",
      "3": "codex",
      "4": "codex",
      "5": "codex"
    },
    "0": "// your code goes here\n    return 0;",
    "grade-0": {
      "execution": 0
    },
    "1": "// your code goes here\n\tstd::sort(extensions.begin(), extensions.end(), \n\t\t\t\t[](std::string a, std::string b){\n\t\t\t\t\treturn std::stoi(a) > std::stoi(b);\n\t\t\t\t}\n\t);\n\tstd::string res = class_name;\n\tint cap = 0;\n\tint sm = 0;\n\tfor (const auto &ext : extensions)\n\t{\n\t\tcap = std::max(cap, std::count(ext.begin(), ext.end(), std::toupper(ext.at(0))));\n\t\tsm = std::max(sm, std::count(ext.begin(), ext.end(), std::tolower(ext.at(0))));\n\t}\n\tstd::string ans = res;\n\tif (cap > sm)\n\t{\n\t\tfor (const auto &ext : extensions)\n\t\t{\n\t\t\tif (cap - sm == std::stoi(ext))\n\t\t\t{\n\t\t\t\tans += \".\" + ext;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn ans;",
    "grade-1": {
      "execution": 0
    },
    "2": "std::string result;\n    double cap_counter{0};\n    double sm_counter{0};\n    for (auto&& ext : extensions) {\n        auto cap = ext.find_first_of('A');\n        auto sm = ext.find_first_of('z');\n        if (cap == std::string::npos || sm == std::string::npos) {\n            std::cout << \"Empty extension detected!\" << std::endl;\n            return class_name + ext;\n        }\n        if (cap != -1 && sm != -1) {\n            cap_counter++;\n            sm_counter++;\n        }\n    }\n    if (cap_counter == 0 || sm_counter == 0){\n        std::cout << \"Empty extension detected!\" << std::endl;\n        return class_name;\n    }\n    double strength_counter = cap_counter - sm_counter;\n    if (strength_counter < 0){\n        std::cout << \"Extension name not unique\" << std::endl;\n        return class_name + extensions[0];\n    }\n    double strength = strength_counter / cap_counter;\n    if (strength == 0){\n        std::cout << \"Extension name not unique\" << std::endl;\n        return class_name + extensions[0];\n    }\n    std::cout << \"Class name: \" << class_name << std::endl;\n    double max_strength = -1;\n    for (auto&& ext : extensions) {\n        auto cap = ext.find_first_of('A');\n        auto sm = ext.find_first_of('z');\n        if (cap == std::string::npos || sm == std::string::npos) {\n            std::cout << \"Empty extension detected!\" << std::endl;\n            return class_name + ext;\n        }\n        if (cap != -1 && sm != -1) {\n            if (cap > sm || cap < sm_counter || sm > cap_counter) {\n                std::cout << \"Extension name not unique\" << std::endl;\n                return class_name + ext;\n            }\n            if (cap > max_strength){\n                result = class_name + ext;\n                max_strength = cap;\n            }\n        }\n    }\n    std::cout << \"Extension name: \" << result << std::endl;\n    return result;",
    "grade-2": {
      "execution": 0
    },
    "3": "// code here.\n    int max_cap=0, max_sm=0;\n    std::string result;\n    for(std::string s: extensions){\n        int cap=0, sm=0;\n        for(char c: s){\n            if(c >= 'A' && c <= 'Z'){\n                cap++;\n            }\n            else if(c >= 'a' && c <= 'z'){\n                sm++;\n            }\n        }\n        if(cap-sm > max_cap-max_sm){\n            max_cap = cap;\n            max_sm = sm;\n            result = s;\n        }\n    }\n    return class_name + \".\" + result;",
    "grade-3": {
      "execution": 0
    },
    "4": "float max = -2;\n\tint s, l;\n\tfor (int i = 0; i < extensions.size(); i++) {\n\t\ts = 0;\n\t\tl = 0;\n\t\tfor (int j = 0; j < extensions[i].size(); j++) {\n\t\t\tif (extensions[i][j] >= 'A' && extensions[i][j] <= 'Z') {\n\t\t\t\ts++;\n\t\t\t}\n\t\t\telse if (extensions[i][j] >= 'a' && extensions[i][j] <= 'z') {\n\t\t\t\tl++;\n\t\t\t}\n\t\t}\n\t\tif (s - l > max) {\n\t\t\tmax = s - l;\n\t\t}\n\t}\n\tfor (int i = 0; i < extensions.size(); i++) {\n\t\ts = 0;\n\t\tl = 0;\n\t\tfor (int j = 0; j < extensions[i].size(); j++) {\n\t\t\tif (extensions[i][j] >= 'A' && extensions[i][j] <= 'Z') {\n\t\t\t\ts++;\n\t\t\t}\n\t\t\telse if (extensions[i][j] >= 'a' && extensions[i][j] <= 'z') {\n\t\t\t\tl++;\n\t\t\t}\n\t\t}\n\t\tif (s - l == max) {\n\t\t\treturn class_name + \".\" + extensions[i];\n\t\t}\n\t}",
    "grade-4": {
      "execution": 1
    },
    "5": "std::string result = class_name;\n\tint max_strength = 0;\n\tfor (std::string extension : extensions) {\n\t\tint strength = 0;\n\t\tfor (char c : extension) {\n\t\t\tif (isupper(c)) strength++;\n\t\t\telse if (islower(c)) strength--;\n\t\t}\n\t\tif (strength > max_strength) {\n\t\t\tmax_strength = strength;\n\t\t\tresult += \".\" + extension;\n\t\t}\n\t}\n\treturn result;",
    "grade-5": {
      "execution": 0
    }
  },
  {
    "intent": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// get_row([\n// [1,2,3,4,5,6],\n// [1,2,3,4,1,6],\n// [1,2,3,4,5,1]\n// ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n// get_row([], 1) == []\n// get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\nstd::vector<std::tuple<long, long>> get_row(std::vector<std::vector<long>> lst, long x) {\n",
    "task_id": "87",
    "prompt": "/*\nYou are given a 2 dimensional data, as a nested vectors,\nwhich is similar to matrix, however, unlike matrices,\neach row may contain a different number of columns.\nGiven lst, and integer x, find integers x in the vector,\nand return vector of vectors, {{x1, y1}, {x2, y2} ...} such that\neach vector is a coordinate - {row, columns}, starting with 0.\nSort coordinates initially by rows in ascending order.\nAlso, sort coordinates of the row by columns in descending order.\n\nExamples:\nget_row({\n  {1,2,3,4,5,6},\n  {1,2,3,4,1,6},\n  {1,2,3,4,5,1}\n}, 1) == {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}}\nget_row({}, 1) == {}\nget_row({{}, {1}, {1, 2, 3}}, 3) == {{2, 2}}\n*/\n#include<stdio.h>\n#include<vector>\nusing namespace std;\nvector<vector<int>> get_row(vector<vector<int>> lst, int x){\n",
    "simplified_intent": "You are given a 2 dimensional data, as a nested lists, which is similar to matrix, however, unlike matrices, each row may contain a different number of columns. Given lst, and integer x, find integers x in the list, and return list of tuples, [(x1, y1), (x2, y2) ...] such that each tuple is a coordinate - (row, columns), starting with 0. Sort coordinates initially by rows in ascending order. Also, sort coordinates of the row by columns in descending order.",
    "snippet": [
      "    vector<vector<int>> out={};\n    for (int i=0;i<lst.size();i++)\n    for (int j=lst[i].size()-1;j>=0;j-=1)\n    if (lst[i][j]==x) out.push_back({i,j});\n    return out;\n}\n"
    ],
    "sample_from": {
      "0": "incoder",
      "1": "incoder",
      "2": "incoder",
      "3": "codex",
      "4": "codex",
      "5": "codex"
    },
    "0": "std::vector<std::tuple<long, long>> res;\n    // Write your code here\n    for(auto &row : lst){\n        for(auto &num : row){\n            if(num==x)\n                res.push_back(std::make_tuple(row.size(),row.size()));\n        }\n    }\n    res.sort();\n    res.sort((std::greater<std::tuple<long, long>>()));\n    for(auto &row : res){\n        res.sort((std::greater<std::tuple<long, long>>()));\n        for(auto &num : row){\n            res.sort((std::less<std::tuple<long, long>>()));\n            std::cout << std::get<0>(num) << '\\t' << std::get<1>(num) << '\\n';\n        }\n    }\n    return res;",
    "grade-0": {
      "execution": 0
    },
    "1": "std::vector<std::tuple<long, long>> result;\n    for(auto &row : lst) {\n        std::vector<std::tuple<long, long>> rowResult;\n        for(auto &e : row) {\n            if(x == e) {\n                rowResult.push_back((row.size(), row.size() - 1));\n                break;\n            }\n            if(x == e) {\n                rowResult.push_back((row.size(), row.size() - 1));\n                break;\n            }\n        }\n        result.push_back(std::make_tuple(rowResult.begin(), rowResult.end()));\n    }\n    std::sort(result.begin(), result.end(), [](auto &a, auto &b) {\n        return a.first > b.first;\n    });\n    for(auto &x : result) {\n        std::sort(x.second, x.second+2);\n    }\n    return result;",
    "grade-1": {
      "execution": 0
    },
    "2": "if (lst.empty())\n        return std::vector<std::tuple<long, long>>();\n    long row = lst[0][0];\n    long col = std::max(0, (row + x - 1) % lst[0][0]);\n    return std::vector<std::tuple<long, long>>(std::make_tuple(row, col));",
    "grade-2": {
      "execution": 0
    },
    "3": "std::vector<std::tuple<long, long>> answer;\n    for (long row = 0; row < lst.size(); row++) {\n        for (long col = 0; col < lst[row].size(); col++) {\n            if (lst[row][col] == x) {\n                answer.push_back(std::make_tuple(row, col));\n            }\n        }\n    }\n    std::sort(answer.begin(), answer.end(), [](auto t1, auto t2) {\n        return (std::get<0>(t1) < std::get<0>(t2)) || (std::get<0>(t1) == std::get<0>(t2) && std::get<1>(t1) > std::get<1>(t2));\n    });\n    return answer;",
    "grade-3": {
      "execution": 1
    },
    "4": "std::vector<std::tuple<long, long>> answer;\n\tfor (int i = 0; i < lst.size(); i++) {\n\t\tfor (int j = 0; j < lst[i].size(); j++) {\n\t\t\tif (lst[i][j] == x)\n\t\t\t\tanswer.push_back(std::make_tuple(i, j));\n\t\t}\n\t}\n\tstd::sort(answer.begin(), answer.end(), [](std::tuple<long, long> a, std::tuple<long, long> b) {\n\t\treturn std::get<0>(a) < std::get<0>(b);\n\t});\n\tstd::sort(answer.begin(), answer.end(), [](std::tuple<long, long> a, std::tuple<long, long> b) {\n\t\treturn std::get<1>(a) > std::get<1>(b);\n\t});\n\treturn answer;",
    "grade-4": {
      "execution": 0
    },
    "5": "std::vector<std::tuple<long, long>> l;\n    for (long i = 0; i < lst.size(); i++) {\n        for (long j = 0; j < lst[i].size(); j++) {\n            if (lst[i][j] == x) {\n                l.push_back(std::make_tuple(i, j));\n            }\n        }\n    }\n    std::sort(l.begin(), l.end());\n    for (long i = 0; i < l.size(); i++) {\n        if (i + 1 < l.size() && std::get<0>(l[i]) == std::get<0>(l[i + 1])) {\n            std::get<1>(l[i]) *= -1;\n            std::get<1>(l[i + 1]) *= -1;\n        }\n    }\n    std::sort(l.begin(), l.end());\n    for (long i = 0; i < l.size(); i++) {\n        if (std::get<1>(l[i]) < 0) {\n            std::get<1>(l[i]) *= -1;\n        }\n    }\n    return l;",
    "grade-5": {
      "execution": 1
    }
  },
  {
    "intent": "#include<assert.h>\n#include<bits/stdc++.h>\n// Return median of elements in the list l.\n// >>> median([3, 1, 2, 4, 5])\n// 3\n// >>> median([-10, 4, 6, 1000, 10, 20])\n// 15.0\nfloat median(std::vector<long> l) {\n",
    "task_id": "47",
    "prompt": "/*\nReturn median of elements in the vector l.\n>>> median({3, 1, 2, 4, 5})\n3\n>>> median({-10, 4, 6, 1000, 10, 20})\n15.0\n*/\n#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nfloat median(vector<float> l){\n",
    "simplified_intent": "Return median of elements in the list l.",
    "snippet": [
      "    sort(l.begin(),l.end());\n    if (l.size()%2==1) return l[l.size()/2];\n    return 0.5*(l[l.size()/2]+l[l.size()/2-1]);\n}\n"
    ],
    "sample_from": {
      "0": "incoder",
      "1": "incoder",
      "2": "incoder",
      "3": "codex",
      "4": "codex",
      "5": "codex"
    },
    "0": "long l = std::min(l.size(), l.size() / 2);\n    long mid = l.size() / 2;\n    long count = 0;\n    float res = 0.0;\n\n    for (long i = 0; i < l; i++) {\n        if (i == mid)\n            mid++;\n        count += 1;\n        if (count > 2) {\n            res = l[mid];\n            break;\n        }\n    }\n    return res;",
    "grade-0": {
      "execution": 0
    },
    "1": "int n = l.size();\n    float x[n];\n    float sum = 0;\n    for (int i = 0; i < n; ++i) {\n        x[i] = l[i];\n        sum += x[i];\n    }\n    return sum / n;",
    "grade-1": {
      "execution": 0
    },
    "2": "long long middle = l.size() / 2;\n    long long largest = middle; // largest is just half the length\n    long long smaller = middle - 1; // smaller is just one less than the length\n    if (l.size() % 2 == 1) {\n        std::swap(smaller, largest);\n    }\n    float med = 0.f;\n    if (largest >= 1 && smallest <= l.size() - 1) {\n        float largest1 = l[largest];\n        float smaller1 = l[smaller];\n        if (largest1 < smaller1)\n            std::swap(largest1, smaller1);\n        float x = (largest1 + smaller1) / 2;\n        float y = (largest + smaller) / 2;\n        float z = (largest1 + smaller1 + largest) / 4;\n        float w = (largest + smaller1 + largest1 + smaller) / 8;\n        float med1 = median([y, x, z, w]);\n        float med2 = median([z, w, x, y, z]);\n        float med3 = median([x, z, y, w, x]);\n        float med4 = median([y, z, x, z, w]);\n        float med5 = median([z, w, z, y, x]);\n        float med6 = median([w, z, x, z, y]);\n        float med7 = median([z, y, x, z, w]);\n        float med8 = median([y, x, z, y, w]);\n        float med9 = median([z, w, y, x, z]);\n        float med10 = median([w, z, y, x, w]);\n        float med11 = median([z, y, x, z, y]);\n        float med12 = median([y, x, z, y, w]);\n        float med13 = median([z, w, y, z, x]);\n        float med14 = median([w, z, y, z, w]);\n        float med15 = median([z, y, z, y, w]);\n        float med16 = median([y, z, z, y, x]);\n        float med17 = median([z, w, z, z, y]);\n        float med18 = median([w, z, z, z, w]);\n        float med19 = median([z, y, z, z, x]);\n        float med20 = median([y, z, z, y, x]);\n        float med21 = median([z, w, y, z, y]);\n        float med22 = median([w, z, y, z, w]);\n        float med23 = median([z, y, z, y, w]);\n        float med24 = median([y, z, z, y, x]);\n        float med25 = median([z, w, y, z, z]);\n        float",
    "grade-2": {
      "execution": 0
    },
    "3": "// Write your code here\n\tint size = l.size();\n\t// sort the vector\n\tstd::sort(l.begin(), l.end());\n\tif (size % 2 != 0) {\n\t\t// if size is odd\n\t\treturn l[size / 2];\n\t}\n\telse {\n\t\t// if size is even\n\t\tfloat x = l[size / 2];\n\t\tfloat y = l[(size / 2) - 1];\n\t\tfloat avg = (x + y) / 2;\n\t\treturn avg;\n\t}",
    "grade-3": {
      "execution": 1
    },
    "4": "return 0.0;",
    "grade-4": {
      "execution": 0
    },
    "5": "// your code here\n    long n = l.size();\n    float m1, m2;\n    if(n % 2 == 0)\n    {\n        m1 = l[n/2];\n        m2 = l[n/2 - 1];\n        return (m1 + m2)/2;\n    }\n    else\n    {\n        return l[n/2];\n    }",
    "grade-5": {
      "execution": 0
    }
  },
  {
    "intent": "#include<assert.h>\n#include<bits/stdc++.h>\n// Input is a space-delimited string of numberals from 'zero' to 'nine'.\n// Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n// Return the string with numbers sorted from smallest to largest\n// >>> sort_numbers('three one five')\n// 'one three five'\nstd::string sort_numbers(std::string numbers) {\n",
    "task_id": "19",
    "prompt": "/*\nInput is a space-delimited string of numberals from \"zero\" to \"nine\".\nValid choices are \"zero\", \"one\", 'two\", 'three\", \"four\", \"five\", 'six\", 'seven\", \"eight\" and \"nine\".\nReturn the string with numbers sorted from smallest to largest\n>>> sort_numbers('three one five\")\n\"one three five\"\n*/\n#include<stdio.h>\n#include<string>\n#include<map>\nusing namespace std;\nstring sort_numbers(string numbers){\n",
    "simplified_intent": "Input is a space-delimited string of numberals from 'zero' to 'nine'. Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'. Return the string with numbers sorted from smallest to largest",
    "snippet": [
      "    map<string,int> tonum={{\"zero\",0},{\"one\",1},{\"two\",2},{\"three\",3},{\"four\",4},{\"five\",5},{\"six\",6},{\"seven\",7},{\"eight\",8},{\"nine\",9}};\n    map<int,string> numto={{0,\"zero\"},{1,\"one\"},{2,\"two\"},{3,\"three\"},{4,\"four\"},{5,\"five\"},{6,\"six\"},{7,\"seven\"},{8,\"eight\"},{9,\"nine\"}};\n    int count[10];\n    for (int i=0;i<10;i++)\n        count[i]=0;\n    string out=\"\",current=\"\";\n    if (numbers.length()>0) numbers=numbers+' ';\n    for (int i=0;i<numbers.length();i++)\n        if (numbers[i]==' ')\n        {\n            count[tonum[current]]+=1;\n            current=\"\";\n        }\n        else current+=numbers[i];\n    for (int i=0;i<10;i++)\n        for (int j=0;j<count[i];j++)\n            out=out+numto[i]+' ';\n    if (out.length()>0) out.pop_back();\n    return out;\n}\n"
    ],
    "sample_from": {
      "0": "incoder",
      "1": "incoder",
      "2": "incoder",
      "3": "codex",
      "4": "codex",
      "5": "codex"
    },
    "0": "std::string sortedNumbers = numbers;\n    std::sort(std::begin(sortedNumbers), std::end(sortedNumbers), [](char a, char b) {\n        return a < b;\n    });\n    return sortedNumbers;",
    "grade-0": {
      "execution": 0
    },
    "1": "std::istringstream ss(numbers);\n  std::string res;\n  ss >> res;\n  assert(ss.good());\n  std::vector<int> nums;\n  while (res != \"\") {\n    nums.push_back(atoi(res));\n    ss >> res;\n  }\n  std::sort(nums.begin(), nums.end());\n  std::string result;\n  for (int i = 0; i < nums.size(); i++) {\n    result += std::to_string(nums[i]);\n    if (i < nums.size() - 1) {\n      result += ' ';\n    }\n  }\n  return result;",
    "grade-1": {
      "execution": 0
    },
    "2": "std::string result;\n    int largest = 0;\n    int num;\n    \n    for (int i = 0; i < numbers.size(); i++) {\n        num = atoi(numbers[i].c_str());\n        \n        // if the num is less than the largest so far, record it\n        if (num < largest) {\n            result = numbers[i];\n            largest = num;\n        }\n    }\n    \n    // append the largest number at the end\n    result += \" \" + std::to_string(largest);\n    return result;",
    "grade-2": {
      "execution": 0
    },
    "3": "char c[] = \"zero one two three four five six seven eight nine\";\n    char* p = strtok(c, \" \");\n    std::map<std::string, int> number_map;\n    int i = 0;\n    while (p != NULL) {\n        number_map[p] = i;\n        p = strtok(NULL, \" \");\n        i++;\n    }\n    std::vector<std::string> nums;\n    p = strtok((char*)numbers.c_str(), \" \");\n    while (p != NULL) {\n        nums.push_back(p);\n        p = strtok(NULL, \" \");\n    }\n    std::sort(nums.begin(), nums.end(), [&](const std::string& a, const std::string& b) { return number_map[a] < number_map[b]; });\n    std::stringstream ss;\n    for (int i = 0; i < nums.size(); i++) {\n        ss << nums[i];\n        if (i != nums.size() - 1) {\n            ss << \" \";\n        }\n    }\n    return ss.str();",
    "grade-3": {
      "execution": 1
    },
    "4": "std::map<std::string, int> nmap;\n    std::istringstream ss(numbers);\n    int n;\n    nmap[\"zero\"] = 0;\n    nmap[\"one\"] = 1;\n    nmap[\"two\"] = 2;\n    nmap[\"three\"] = 3;\n    nmap[\"four\"] = 4;\n    nmap[\"five\"] = 5;\n    nmap[\"six\"] = 6;\n    nmap[\"seven\"] = 7;\n    nmap[\"eight\"] = 8;\n    nmap[\"nine\"] = 9;\n    std::string s;\n    std::vector<int> nums;\n    while (ss >> s) {\n        nums.push_back(nmap[s]);\n    }\n    std::sort(nums.begin(), nums.end());\n    std::ostringstream os;\n    for (int i = 0; i < nums.size(); i++) {\n        for (std::map<std::string, int>::iterator it = nmap.begin(); it != nmap.end(); it++) {\n            if (it->second == nums[i]) {\n                os << it->first << \" \";\n                break;\n            }\n        }\n    }\n    std::string res = os.str();\n    res.pop_back();\n    return res;",
    "grade-4": {
      "execution": 0
    },
    "5": "// Initialize the map with the numbers and their corresponding string\n\tstd::map<std::string, int> number_map = {\n\t\t{ \"zero\", 0 }, { \"one\", 1 }, { \"two\", 2 }, { \"three\", 3 }, { \"four\", 4 },\n\t\t{ \"five\", 5 }, { \"six\", 6 }, { \"seven\", 7 }, { \"eight\", 8 }, { \"nine\", 9 }\n\t};\n\t// Initialize the vector of numbers, the index of the current number, and the size of the string\n\tstd::vector<int> num_list;\n\tint index = 0;\n\tint size = numbers.size();\n\t// While there are numbers left to parse\n\twhile (index < size) {\n\t\t// Initialize the number string\n\t\tstd::string num = \"\";\n\t\t// Add characters to the number string until the next character is a space\n\t\twhile (numbers[index] != ' ') {\n\t\t\tnum += numbers[index];\n\t\t\tindex++;\n\t\t}\n\t\t// Add the integer number to the list\n\t\tnum_list.push_back(number_map[num]);\n\t\t// Advance to the next number\n\t\tindex++;\n\t}\n\t// Sort the numbers in ascending order\n\tstd::sort(num_list.begin(), num_list.end());\n\t// Create the new string to return\n\tstd::string ret_str = \"\";\n\t// For each number\n\tfor (int i = 0; i < num_list.size(); i++) {\n\t\t// Initialize the number string\n\t\tstd::string num = \"\";\n\t\t// Find the string version of the number\n\t\tfor (std::map<std::string, int>::iterator it = number_map.begin(); it != number_map.end(); it++) {\n\t\t\tif (it->second == num_list[i]) {\n\t\t\t\tnum = it->first;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t// If this is not the last number\n\t\tif (i != num_list.size() - 1) {\n\t\t\t// Add a space to the string",
    "grade-5": {
      "execution": 0
    }
  },
  {
    "intent": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// Input: \n// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n// bucket_capacity : 1\n// Output: 6\n// Example 2:\n// Input: \n// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n// bucket_capacity : 2\n// Output: 5\n// Example 3:\n// Input: \n// grid : [[0,0,0], [0,0,0]]\n// bucket_capacity : 5\n// Output: 0\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>> grid, long capacity) {\n",
    "task_id": "115",
    "prompt": "/*\nYou are given a rectangular grid of wells. Each row represents a single well,\nand each 1 in a row represents a single unit of water.\nEach well has a corresponding bucket that can be used to extract water from it, \nand all buckets have the same capacity.\nYour task is to use the buckets to empty the wells.\nOutput the number of times you need to lower the buckets.\n\nExample 1:\n    Input: \n        grid : {{0,0,1,0}, {0,1,0,0}, {1,1,1,1}}\n        bucket_capacity : 1\n    Output: 6\n\nExample 2:\n    Input: \n        grid : {{0,0,1,1}, {0,0,0,0}, {1,1,1,1}, {0,1,1,1}}\n        bucket_capacity : 2\n    Output: 5\n\nExample 3:\n    Input: \n        grid : {{0,0,0}, {0,0,0}}\n        bucket_capacity : 5\n    Output: 0\n\nConstraints:\n    * all wells have the same length\n    * 1 <= grid.length <= 10^2\n    * 1 <= grid{:,1}.length <= 10^2\n    * grid{i}{j} -> 0 | 1\n    * 1 <= capacity <= 10\n*/\n#include<stdio.h>\n#include<vector>\nusing namespace std;\nint max_fill(vector<vector<int>> grid,int capacity){\n",
    "simplified_intent": "You are given a rectangular grid of wells. Each row represents a single well, and each 1 in a row represents a single unit of water. Each well has a corresponding bucket that can be used to extract water from it, and all buckets have the same capacity. Your task is to use the buckets to empty the wells. Output the number of times you need to lower the buckets. Constraints: * all wells have the same length * 1 <= grid.length <= 10^2 * 1 <= grid[:,1].length <= 10^2 * grid[i][j] -> 0 | 1 * 1 <= capacity <= 10",
    "snippet": [
      "    int out=0;\n    for (int i=0;i<grid.size();i++)\n    {\n        int sum=0;\n        for (int j=0;j<grid[i].size();j++)\n            sum+=grid[i][j];\n        if (sum>0)  out+=(sum-1)/capacity+1;\n    }\n    return out;\n}\n"
    ],
    "sample_from": {
      "0": "incoder",
      "1": "incoder",
      "2": "incoder",
      "3": "codex",
      "4": "codex",
      "5": "codex"
    },
    "0": "long m = grid.size();\n    long n = grid[0].size();\n    long cnt = 0;\n    long ans = 0;\n    long i, j;\n    std::vector<std::vector<long>> dfs(m * n);\n    std::vector<std::vector<long>> visited(m, std::vector<long>(n, 0));\n    // Initilize all visited cells with 0 \n    memset(dfs.data(), 0, sizeof(dfs));\n    // Recursion\n    dfs(0, 0, dfs.size(), dfs.data(), visited);\n    // BFS\n    std::queue<std::vector<long>> q;\n    q.push(std::vector<long>(0, 0));\n    while (!q.empty()) {\n        cnt++;\n        ans += q.front().size();\n        q.pop();\n        for (int i = 0; i < q.front().size(); i++) {\n            j = q.front()[i];\n            q.push(std::vector<long>(i, j));\n        }\n        visited[q.front()[0]][q.front()[1]] = 0;\n    }\n    return ans - cnt;",
    "grade-0": {
      "execution": 0
    },
    "1": "if(grid.size()<1 || grid.size()[0]<1)\n    {\n        return 0;\n    }\n    int m = grid.size()[0];\n    int n = grid.size()[1];\n    std::vector<std::pair<long, long>> buckets(bucket_capacity);\n    for(int i = 0; i < bucket_capacity; i++)\n    {\n        buckets[i].first = 0;\n        buckets[i].second = capacity;\n    }\n    for(int i = 0; i < m; i++)\n    {\n        for(int j = 0; j < n; j++)\n        {\n            if(grid[i][j] == 1)\n            {\n                for(int k = 0; k < bucket_capacity; k++)\n                {\n                    if(buckets[k].first == 0 && buckets[k].second == capacity)\n                    {\n                        buckets[k].first = i;\n                        buckets[k].second = j;\n                        break;\n                    }\n                    else if(buckets[k].first == i && buckets[k].second == j)\n                    {\n                        buckets[k].first++;\n                        break;\n                    }\n                    else if(buckets[k].first == bucket_capacity)\n                    {\n                        buckets[k].first = 0;\n                        buckets[k].second = j;\n                        break;\n                    }\n                }\n            }\n        }\n    }\n    int count = 0;\n    for(int i = 0; i < bucket_capacity; i++)\n    {\n        if(buckets[i].first == 0 && buckets[i].second == 0)\n        {\n            count++;\n        }\n    }\n    return count;",
    "grade-1": {
      "execution": 0
    },
    "2": "// Your code here\n    long count = 0;\n    long i = grid.size() - 1;\n    long j = grid[i].size() - 1;\n\n    while (i >= 0 && j >= 0) {\n        if (grid[i][j] == 1){\n            if (grid[i][j-1] == 1 && grid[i-1][j] == 0) {\n                count++;\n                grid[i][j] = 0;\n                grid[i][j-1] = 1;\n                grid[i-1][j] = 1;\n            }\n            if (grid[i][j-1] == 1 && grid[i-1][j] == 1 && grid[i-1][j-1] == 0) {\n                count++;\n                grid[i][j] = 0;\n                grid[i][j-1] = 1;\n                grid[i-1][j] = 1;\n                grid[i-1][j-1] = 1;\n            }\n            if (grid[i][j-1] == 1 && grid[i-1][j] == 1 && grid[i-1][j-1] == 1 &&\n                    grid[i][j-1] == 0){\n                count++;\n                grid[i][j] = 0;\n                grid[i][j-1] = 1;\n                grid[i-1][j] = 1;\n                grid[i-1][j-1] = 1;\n                grid[i][j-1] = 1;\n            }\n            else if (grid[i][j-1] == 1 && grid[i-1][j] == 1 && grid[i-1][j-1] == 1 &&\n                    grid[i][j-1] == 1 &&\n                    grid[i+1][j] == 1){\n                count++;\n                grid[i][j] = 0;\n                grid[i][j-1] = 1;\n                grid[i-1][j] = 1;\n                grid[i-1][j-1] = 1;\n                grid[i][j-1] = 1;\n                grid[i+1][j-1] = 1;\n            }\n        }\n        else if (grid[i][j] == 0) {\n            if (grid[i][j+1] == 1 && grid[i][j] == 1){\n                count++;\n                grid[i][j] = 0;\n                grid[i][j+1] = 1;\n            }\n            else if (grid[i][j+1] == 1 && grid[i][j] == 0){\n                count++;\n                grid[i][j] = 0;\n                grid[i][j+1] = 1;\n            }\n            else if (grid[i][j+1] == 1 && grid[i][j] == 1 && grid[i-1][j] == 1){\n                count++;\n                grid[i][j] = 0;\n                grid[i][j+1] = 1;\n                grid[i-1][j] = 1;\n            }\n            else if (grid[i][j+1] == 1 && grid[i][j] == 1 && grid[i-1][j] == 0){\n                count++;\n                grid[i][j] = 0;\n                grid[i][j+1] = 1;\n                grid[i-1][j] = 1;\n            }\n            else if (grid[i][j+1] == 1 && grid[i][j] == 1 && grid[i-1][j] == 1 &&\n                    grid[i][j-1] == 0){\n                count++;\n                grid[i][j] = 0;\n                grid[i][j+1] = 1;\n                grid[i-1][j] = 1;\n                grid[i-1][j-1] = 1;\n            }\n            else if (grid[i][j+1] == 1 && grid[i][j] == 1 && grid[i-1][j] == 1 &&\n                    grid[i][j-1] == 1 &&\n                    grid[i][j+1] == 1){\n                count++;\n                grid[i][j] = 0;\n                grid[i][j+1]",
    "grade-2": {
      "execution": 0
    },
    "3": "std::sort(grid.begin(), grid.end(), [](const std::vector<long>& a, const std::vector<long>& b) {\n        return a.size() < b.size();\n    });\n    if (grid.size() == 0) return 0;\n    long max_water = 0;\n    for (auto& row : grid) {\n        long water = 0;\n        for (auto& well : row) {\n            if (well) {\n                water++;\n            }\n        }\n        max_water = std::max(max_water, water);\n    }\n    return std::max(max_water - capacity, 0L);",
    "grade-3": {
      "execution": 0
    },
    "4": "// your code goes here\n    long n = grid.size();\n    long total_wells = grid[0].size();\n    long max_fill_level = 0;\n    for(long i = 0; i < n; i++) {\n        long fill_level = 0;\n        for(long j = 0; j < total_wells; j++) {\n            if(grid[i][j] == 1) {\n                fill_level += 1;\n            }\n        }\n        max_fill_level = std::max(max_fill_level, fill_level);\n    }\n    return max_fill_level;",
    "grade-4": {
      "execution": 0
    },
    "5": "// Fill this in.\n  long max_fill_count = 0;\n  long max_fill_count_column = 0;\n  long grid_row_count = grid.size();\n  long grid_column_count = grid[0].size();\n  long grid_row_count_column = grid.size();\n  for(long row_index = 0; row_index < grid_row_count; row_index++) {\n    for(long column_index = 0; column_index < grid_column_count; column_index++) {\n      if(1 == grid[row_index][column_index]) {\n        max_fill_count++;\n      }\n    }\n  }\n  for(long column_index = 0; column_index < grid_column_count; column_index++) {\n    for(long row_index = 0; row_index < grid_row_count_column; row_index++) {\n      if(1 == grid[row_index][column_index]) {\n        max_fill_count_column++;\n      }\n    }\n  }\n  if(max_fill_count > max_fill_count_column) {\n    return max_fill_count;\n  }\n  return max_fill_count_column;",
    "grade-5": {
      "execution": 0
    }
  },
  {
    "intent": "#include<assert.h>\n#include<bits/stdc++.h>\n// Given an array arr of integers, find the minimum number of elements that\n// need to be changed to make the array palindromic. A palindromic array is an array that\n// is read the same backwards and forwards. In one change, you can change one element to any other element.\n// For example:\n// smallest_change([1,2,3,5,4,7,9,6]) == 4\n// smallest_change([1, 2, 3, 4, 3, 2, 2]) == 1\n// smallest_change([1, 2, 3, 2, 1]) == 0\nlong smallest_change(std::vector<long> arr) {\n",
    "task_id": "73",
    "prompt": "/*\nGiven a vector arr of integers, find the minimum number of elements that\nneed to be changed to make the vector palindromic. A palindromic vector is a vector that\nis read the same backwards and forwards. In one change, you can change one element to any other element.\n\nFor example:\nsmallest_change({1,2,3,5,4,7,9,6}) == 4\nsmallest_change({1, 2, 3, 4, 3, 2, 2}) == 1\nsmallest_change({1, 2, 3, 2, 1}) == 0\n*/\n#include<stdio.h>\n#include<vector>\nusing namespace std;\nint smallest_change(vector<int> arr){\n",
    "simplified_intent": "Given an array arr of integers, find the minimum number of elements that need to be changed to make the array palindromic. A palindromic array is an array that is read the same backwards and forwards. In one change, you can change one element to any other element.",
    "snippet": [
      "    int out=0;\n    for (int i=0;i<arr.size()-1-i;i++)\n        if (arr[i]!=arr[arr.size()-1-i])\n            out+=1;\n    return out;\n}\n"
    ],
    "sample_from": {
      "0": "incoder",
      "1": "incoder",
      "2": "incoder",
      "3": "codex",
      "4": "codex",
      "5": "codex"
    },
    "0": "// Code here\n    if(arr.size() <= 1)\n        return 0;\n    std::vector<long> temp(arr);\n    long ans = 0, flag = 0, l = 0, r = arr.size() - 1;\n    while(l < r) {\n        if(arr[l] != arr[arr[r]]) {\n            ans += flag;\n            flag = 1;\n            temp[ans] = arr[l];\n        }\n        else {\n            flag = 0;\n        }\n        ++l;\n        --r;\n    }\n    ans += flag;\n    for(int i = ans - 1; i >= 0; --i)\n        std::cout << temp[i] << ' ';\n    std::cout << std::endl;\n    return ans;",
    "grade-0": {
      "execution": 0
    },
    "1": "// Write your code here\n    long n = arr.size();\n    long i = 0;\n    long j = 0;\n    long min;\n    long temp;\n    while(i < n){\n        min = INT_MAX;\n        j=i;\n        while(j < n){\n            if(arr[i] <= arr[j]){\n                min = min>arr[j]?min:arr[j];\n            }\n            j++;\n        }\n        if(min != INT_MAX){\n            if(min<0){\n                min = 0;\n            }\n            temp = arr[i];\n            arr[i] = min;\n            arr[j] = temp;\n        }\n        i++;\n    }\n    return min;",
    "grade-1": {
      "execution": 0
    },
    "2": "std::stack<long> st;\n  long ans = 0, min_change = 0;\n  for (int i = 0; i < arr.size(); ++i) {\n    st.push(arr[i]);\n  }\n  while (!st.empty()) {\n    long val = st.top();\n    st.pop();\n    // check forwards\n    if (val % 2 != 0 && val != (val / 2)) {\n      ++min_change;\n    }\n    // check backwards\n    if (val % 2 == 0 && val != (val / 2)) {\n      --min_change;\n    }\n    ans = std::min(ans, min_change);\n  }\n  return ans;",
    "grade-2": {
      "execution": 0
    },
    "3": "int n = arr.size();\n  int a[n+1][n+1];\n  for(int i=0;i<=n;i++)\n  {\n    for(int j=0;j<=n;j++)\n    {\n      if(i==0 || j==0)\n      {\n        a[i][j] = 0;\n      }\n      else if(arr[i-1] == arr[n-j])\n      {\n        a[i][j] = 1 + a[i-1][j-1];\n      }\n      else\n      {\n        a[i][j] = std::max(a[i-1][j],a[i][j-1]);\n      }\n    }\n  }\n  return (n - a[n][n]);",
    "grade-3": {
      "execution": 0
    },
    "4": "std::cout << \"In function\" << std::endl;\n    int n = arr.size();\n    int i = 0;\n    int j = n-1;\n    int count = 0;\n    while(i<j){\n        if(arr[i] != arr[j])\n            count++;\n        i++;\n        j--;\n    }\n    return count;",
    "grade-4": {
      "execution": 1
    },
    "5": "int beg = 0;\n    int end = arr.size() - 1;\n    int count = 0;\n    for (int i = 0; i < arr.size() / 2; i++) {\n        if (arr[beg] != arr[end]) {\n            count++;\n        }\n        beg++;\n        end--;\n    }\n    return count;",
    "grade-5": {
      "execution": 1
    }
  },
  {
    "intent": "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of strings only for ones that start with a given prefix.\n// >>> filter_by_prefix([], 'a')\n// []\n// >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n// ['abc', 'array']\nstd::vector<std::string> filter_by_prefix(std::vector<std::string> strings, std::string prefix) {\n",
    "task_id": "29",
    "prompt": "/*\nFilter an input vector of strings only for ones that start with a given prefix.\n>>> filter_by_prefix({}, \"a\")\n{}\n>>> filter_by_prefix({\"abc\", \"bcd\", \"cde\", \"vector\"}, \"a\")\n{\"abc\", \"vector\"}\n*/\n#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\nvector<string> filter_by_prefix(vector<string> strings, string prefix){\n",
    "simplified_intent": "Filter an input list of strings only for ones that start with a given prefix.",
    "snippet": [
      "    vector<string> out={};\n    for (int i=0;i<strings.size();i++)\n        if (strings[i].substr(0,prefix.length())==prefix) out.push_back(strings[i]);\n    return out;\n}\n"
    ],
    "sample_from": {
      "0": "incoder",
      "1": "incoder",
      "2": "incoder",
      "3": "codex",
      "4": "codex",
      "5": "codex"
    },
    "0": "std::vector<std::string> filteres;\n  for (const auto &str : strings) {\n    if (str.substr(0, prefix.length()) == prefix) {\n      filteres.push_back(str);\n    }\n  }\n  return filteres;",
    "grade-0": {
      "execution": 1
    },
    "1": "assert(strings.size() != 0);\n  assert(strings.size() >= prefix.size());\n  std::vector<std::string> result;\n  for (int i = 0; i < prefix.size(); i++) {\n    result.push_back(strings[i]);\n  }\n  for (int i = 0; i < strings.size(); i++) {\n    if (strings[i].compare(0, prefix.size(), prefix) == 0) {\n      result.push_back(strings[i]);\n    }\n  }\n  return result;",
    "grade-1": {
      "execution": 0
    },
    "2": "std::string prefix_copy = prefix;\n    prefix_copy.insert(prefix_copy.begin(), prefix.size());\n    std::vector<std::string> results;\n\n    for (std::string &s : strings) {\n        if (prefix_copy == s) {\n            results.push_back(s);\n        }\n    }\n\n    return results;",
    "grade-2": {
      "execution": 0
    },
    "3": "std::vector<std::string> result;\n    for (int i = 0; i < strings.size(); i++) {\n        if (strings[i].substr(0, prefix.size()) == prefix) {\n            result.push_back(strings[i]);\n        }\n    }\n    return result;",
    "grade-3": {
      "execution": 1
    },
    "4": "std::vector<std::string> result;\n  for (std::string word : strings) {\n    if (word.substr(0, prefix.length()) == prefix) {\n      result.push_back(word);\n    }\n  }\n  return result;",
    "grade-4": {
      "execution": 1
    },
    "5": "std::vector<std::string> result;\n    for (auto elem : strings) {\n        if (elem.substr(0, prefix.size()) == prefix) {\n            result.push_back(elem);\n        }\n    }\n    return result;",
    "grade-5": {
      "execution": 1
    }
  },
  {
    "intent": "#include<assert.h>\n#include<bits/stdc++.h>\n// Return true if a given number is prime, and false otherwise.\n// >>> is_prime(6)\n// False\n// >>> is_prime(101)\n// True\n// >>> is_prime(11)\n// True\n// >>> is_prime(13441)\n// True\n// >>> is_prime(61)\n// True\n// >>> is_prime(4)\n// False\n// >>> is_prime(1)\n// False\nbool is_prime(long n) {\n",
    "task_id": "31",
    "prompt": "/*\nReturn true if a given number is prime, and false otherwise.\n>>> is_prime(6)\nfalse\n>>> is_prime(101)\ntrue\n>>> is_prime(11)\ntrue\n>>> is_prime(13441)\ntrue\n>>> is_prime(61)\ntrue\n>>> is_prime(4)\nfalse\n>>> is_prime(1)\nfalse\n*/\n#include<stdio.h>\nusing namespace std;\nbool is_prime(long long n){\n",
    "simplified_intent": "Return true if a given number is prime, and false otherwise.",
    "snippet": [
      "    if (n<2) return false;\n    for (long long i=2;i*i<=n;i++)\n        if (n%i==0) return false;\n    return true;\n}\n"
    ],
    "sample_from": {
      "0": "incoder",
      "1": "incoder",
      "2": "incoder",
      "3": "codex",
      "4": "codex",
      "5": "codex"
    },
    "0": "if ( n <= 1) {\n      return false;\n   }\n   if ( n == 2) {\n      return true;\n   }\n   if ( n % 2 == 0) {\n      return false;\n   }\n   long i = 3;\n   while (i <= sqrt(n)) {\n      if (n % i == 0) {\n         return false;\n      }\n      i += 2;\n   }\n   return true;",
    "grade-0": {
      "execution": 1
    },
    "1": "if (n == 2)\n        return true;\n    if (n % 2 == 0)\n        return false;\n    int k = 3;\n    for (int i = 3; i * k <= n; i += 2)\n        if (n % i == 0)\n            return false;\n    return true;",
    "grade-1": {
      "execution": 0
    },
    "2": "if(n==1) return false;\n    long i = 2;\n    while(i <= n/i)\n    {\n        if(n%i==0) return false;\n        i++;\n    }\n    return true;",
    "grade-2": {
      "execution": 1
    },
    "3": "//\n\t// YOUR CODE HERE\n\t//\n\tif (n <= 1)\n\t\treturn false;\n\telse if (n <= 3)\n\t\treturn true;\n\telse if (n % 2 == 0 || n % 3 == 0)\n\t\treturn false;\n\tint i = 5;\n\twhile (i * i <= n) {\n\t\tif (n % i == 0 || n % (i + 2) == 0)\n\t\t\treturn false;\n\t\ti += 6;\n\t}\n\treturn true;",
    "grade-3": {
      "execution": 1
    },
    "4": "// TODO: implement\nif(n>1){\nfor(int i=2;i<n;i++){\nif(n%i==0){\nreturn false;",
    "grade-4": {
      "execution": 0
    },
    "5": "for (int i = 2; i <= sqrt(n); i++) {\n\t\tif (n % i == 0)\n\t\t\treturn false;\n\t}\n\treturn true;",
    "grade-5": {
      "execution": 0
    }
  },
  {
    "intent": "#include<assert.h>\n#include<bits/stdc++.h>\n// In this problem, you will implement a function that takes two lists of numbers,\n// and determines whether it is possible to perform an exchange of elements\n// between them to make lst1 a list of only even numbers.\n// There is no limit on the number of exchanged elements between lst1 and lst2.\n// If it is possible to exchange elements between the lst1 and lst2 to make\n// all the elements of lst1 to be even, return \"YES\".\n// Otherwise, return \"NO\".\n// For example:\n// exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n// exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n// It is assumed that the input lists will be non-empty.\nstd::string exchange(std::vector<long> lst1, std::vector<long> lst2) {\n",
    "task_id": "110",
    "prompt": "/*\nIn this problem, you will implement a function that takes two vectors of numbers,\nand determines whether it is possible to perform an exchange of elements\nbetween them to make lst1 a vector of only even numbers.\nThere is no limit on the number of exchanged elements between lst1 and lst2.\nIf it is possible to exchange elements between the lst1 and lst2 to make\nall the elements of lst1 to be even, return \"YES\".\nOtherwise, return \"NO\".\nFor example:\nexchange({1, 2, 3, 4}, {1, 2, 3, 4}) => \"YES\"\nexchange({1, 2, 3, 4}, {1, 5, 3, 4}) => \"NO\"\nIt is assumed that the input vectors will be non-empty.\n*/\n#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\nstring exchange(vector<int> lst1,vector<int> lst2){\n",
    "simplified_intent": "In this problem, you will implement a function that takes two lists of numbers, and determines whether it is possible to perform an exchange of elements between them to make lst1 a list of only even numbers. There is no limit on the number of exchanged elements between lst1 and lst2. If it is possible to exchange elements between the lst1 and lst2 to make all the elements of lst1 to be even, return \"YES\". Otherwise, return \"NO\".",
    "snippet": [
      "    int num=0;\n    for (int i=0;i<lst1.size();i++)\n    if (lst1[i]%2==0) num+=1;\n    for (int i=0;i<lst2.size();i++)\n    if (lst2[i]%2==0) num+=1;\n    if (num>=lst1.size()) return \"YES\";\n    return \"NO\";\n}\n"
    ],
    "sample_from": {
      "0": "incoder",
      "1": "incoder",
      "2": "incoder",
      "3": "codex",
      "4": "codex",
      "5": "codex"
    },
    "0": "// Write your code here\n    return \"\";",
    "grade-0": {
      "execution": 0
    },
    "1": "if (lst1.size() != lst2.size()) {\n        return \"NO\";\n    }\n    // Do not write main() function.\n    // Do not read input, instead use the arguments to the function.\n    // You can only use the standard library.\n    // Use a loop to do some work.\n    // You can only use the following functions: <iostream>\n    // You can only use one return statement.\n    // If the two inputs have the same number of elements, return \"NO\".\n    if (lst1.size() == lst2.size()) {\n        for (int i = 0; i < lst1.size(); i++) {\n            std::swap(lst1[i], lst2[i]);\n        }\n        return \"YES\";\n    }\n    return \"NO\";",
    "grade-1": {
      "execution": 0
    },
    "2": "long even=0, odd=0, exchanged=0;\n    for (long i = 0; i < lst1.size(); i++) {\n        if (lst1[i] % 2 == 0 && lst2[i] % 2 == 0) {\n            even = even + lst1[i];\n            exchanged = exchanged + lst2[i];\n        }\n        else if (lst1[i] % 2 == 1) {\n            odd = odd + lst1[i];\n            exchanged = exchanged + lst2[i];\n        }\n        else {\n            even = even + lst1[i];\n            odd = odd + lst2[i];\n            exchanged = exchanged + lst1[i];\n        }\n    }\n    if (even > odd) {\n        return \"YES\";\n    }\n    else {\n        return \"NO\";\n    }",
    "grade-2": {
      "execution": 0
    },
    "3": "long const size = lst1.size();\n  long sum1 = 0;\n  long sum2 = 0;\n  for (long i = 0; i < size; i++) {\n    sum1 += lst1[i];\n    sum2 += lst2[i];\n  }\n  if (sum1 % 2 == 0 || sum2 % 2 == 0) {\n    return \"YES\";\n  }\n  return \"NO\";",
    "grade-3": {
      "execution": 0
    },
    "4": "// your code here\n    std::string s;\n    int ctr1 = 0, ctr2 = 0;\n    for(int i = 0; i < lst1.size(); i++) {\n        if(lst1[i] % 2 == 0) {\n            ctr1++;\n        }\n    }\n    for(int i = 0; i < lst2.size(); i++) {\n        if(lst2[i] % 2 == 0) {\n            ctr2++;\n        }\n    }\n    if(ctr1 + ctr2 >= lst1.size()) {\n        s = \"YES\";\n    }\n    else {\n        s = \"NO\";\n    }\n    return s;",
    "grade-4": {
      "execution": 1
    },
    "5": "// Write your code here\n  for(long i=0;i<lst1.size();i++){\n    if(lst1[i]%2 != 0){\n      for(long j=0;j<lst2.size();j++){\n        if(lst2[j]%2 == 0){\n          lst1[i] = lst2[j];\n          lst2[j] = lst1[i];\n          break;\n        }\n      }\n    }\n  }\n  for(long i=0;i<lst1.size();i++){\n    if(lst1[i]%2 != 0){\n      return \"NO\";\n    }\n  }\n  return \"YES\";",
    "grade-5": {
      "execution": 0
    }
  },
  {
    "intent": "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of \"(\" and \")\".\n// return True if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\")\n// False\n// >>> correct_bracketing(\"()\")\n// True\n// >>> correct_bracketing(\"(()())\")\n// True\n// >>> correct_bracketing(\")(()\")\n// False\nbool correct_bracketing(std::string brackets) {\n",
    "task_id": "61",
    "prompt": "/*\nbrackets is a string of '(' and ')'.\nreturn true if every opening bracket has a corresponding closing bracket.\n\n>>> correct_bracketing(\"(\")\nfalse\n>>> correct_bracketing(\"()\")\ntrue\n>>> correct_bracketing(\"(()())\")\ntrue\n>>> correct_bracketing(\")(()\")\nfalse\n*/\n#include<stdio.h>\n#include<string>\nusing namespace std;\nbool correct_bracketing(string brackets){\n",
    "simplified_intent": "brackets is a string of \"(\" and \")\". return True if every opening bracket has a corresponding closing bracket.",
    "snippet": [
      "    int level=0;\n    for (int i=0;i<brackets.length();i++)\n    {\n        if (brackets[i]=='(') level+=1;\n        if (brackets[i]==')') level-=1;\n        if (level<0) return false;\n    }\n    if (level!=0) return false;\n    return true;\n}\n"
    ],
    "sample_from": {
      "0": "incoder",
      "1": "incoder",
      "2": "incoder",
      "3": "codex",
      "4": "codex",
      "5": "codex"
    },
    "0": "// check that the string is well formed\n  if (brackets.size() != 2) {\n    return false;\n  }\n  // initialize result to false\n  bool result = false;\n  // iterate over every character in the input string\n  for (int i = 0; i < brackets.size(); i++) {\n    // get the current character\n    char curr = brackets[i];\n    // iterate over every character in the brackets\n    for (int j = 0; j < brackets.size(); j++) {\n      // if the character at i equals the character at j\n      if (i == j) {\n        // then we're at the first character in the brackets, so return false\n        return false;\n      } else if (curr == brackets[j]) {\n        // if the current character equals the previous character\n        if (i == 0) {\n          // then we're at the first character of the brackets string\n          // and it's equal to the previous character\n          result = true;\n        }\n        // otherwise, we're not at the first character of the brackets\n        // and the current character equals the previous character\n        // so return false and break out of the loop\n        return false;\n      }\n    }\n  }\n  // if we got here, then all brackets had a corresponding closing bracket\n  return result;",
    "grade-0": {
      "execution": 0
    },
    "1": "int opening = 0, closing = 0;\n    for (auto it = brackets.begin(); it != brackets.end(); ++it) {\n        if (*it == '(') opening++;\n        if (*it == ')') closing++;\n    }\n    return opening == closing;",
    "grade-1": {
      "execution": 0
    },
    "2": "assert(brackets.size() != 0);\n    // iterate through the brackets until we encounter an opening bracket.\n    // if we see anything other than an opening bracket, return false\n    for (auto c : brackets) {\n        if (c == '(') {\n            // if we've seen an opening bracket, we're done.\n            return false;\n        }\n    }\n    // we've iterated through the brackets so far so return true.\n    return true;",
    "grade-2": {
      "execution": 0
    },
    "3": "//code\n    stack<char> s;\n    int i = 0;\n    while(i<brackets.length())\n    {\n        if(brackets[i] == '(')\n        {\n            s.push(brackets[i]);\n        }\n        else if(brackets[i] == ')')\n        {\n            if(s.empty())\n            {\n                return false;\n            }\n            s.pop();\n        }\n        i++;\n    }\n    if(s.empty())\n    {\n        return true;\n    }\n    return false;",
    "grade-3": {
      "execution": 0
    },
    "4": "int counter = 0;\n  for (int i = 0; i < brackets.size(); i++) {\n    if (brackets[i] == '(') {\n      counter += 1;\n    } else if (brackets[i] == ')') {\n      counter -= 1;\n    } else {\n      return false;\n    }\n    if (counter < 0) {\n      return false;\n    }\n  }\n  if (counter == 0) {\n    return true;\n  } else {\n    return false;\n  }",
    "grade-4": {
      "execution": 1
    },
    "5": "stack<char> char_stack;\n  for (char c : brackets) {\n    if (c == '(') {\n      char_stack.push(c);\n    } else if (c == ')') {\n      if (char_stack.empty()) {\n        return false;\n      }\n      char_stack.pop();\n    }\n  }\n  return char_stack.empty();",
    "grade-5": {
      "execution": 0
    }
  },
  {
    "intent": "#include<assert.h>\n#include<bits/stdc++.h>\n// Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n// the last couple centuries. However, what people don't know is Tribonacci sequence.\n// Tribonacci sequence is defined by the recurrence:\n// tri(1) = 3\n// tri(n) = 1 + n / 2, if n is even.\n// tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n// For example:\n// tri(2) = 1 + (2 / 2) = 2\n// tri(4) = 3\n// tri(3) = tri(2) + tri(1) + tri(4)\n// = 2 + 3 + 3 = 8 \n// You are given a non-negative integer number n, you have to a return a list of the \n// first n + 1 numbers of the Tribonacci sequence.\n// Examples:\n// tri(3) = [1, 3, 2, 8]\nstd::vector<long> tri(long n) {\n",
    "task_id": "130",
    "prompt": "/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \nthe last couple centuries. However, what people don't know is Tribonacci sequence.\nTribonacci sequence is defined by the recurrence:\ntri(1) = 3\ntri(n) = 1 + n / 2, if n is even.\ntri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\nFor example:\ntri(2) = 1 + (2 / 2) = 2\ntri(4) = 3\ntri(3) = tri(2) + tri(1) + tri(4)\n       = 2 + 3 + 3 = 8 \nYou are given a non-negative integer number n, you have to a return a vector of the \nfirst n + 1 numbers of the Tribonacci sequence.\nExamples:\ntri(3) = {1, 3, 2, 8}\n*/\n#include<stdio.h>\n#include<vector>\nusing namespace std;\nvector<int> tri(int n){\n",
    "simplified_intent": "Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in the last couple centuries. However, what people don't know is Tribonacci sequence. Tribonacci sequence is defined by the recurrence: tri(1) = 3 tri(n) = 1 + n / 2, if n is even. tri(n) = tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.",
    "snippet": [
      "    vector<int> out={1,3};\n    if (n==0) return {1};\n    for (int i=2;i<=n;i++)\n    {\n        if (i%2==0) out.push_back(1+i/2);\n        else out.push_back(out[i-1]+out[i-2]+1+(i+1)/2);\n    }\n    return out;\n}\n"
    ],
    "sample_from": {
      "0": "incoder",
      "1": "incoder",
      "2": "incoder",
      "3": "codex",
      "4": "codex",
      "5": "codex"
    },
    "0": "assert(n > 0);\n    std::vector<long> ans;\n    ans.push_back(n);\n    if (n&1) ans.push_back(n*3);\n    for (int i=1; i<n; i++) {\n        ans.push_back(ans[i-1] + ans[i-2] + ans[i+1]);\n    }\n    return ans;",
    "grade-0": {
      "execution": 0
    },
    "1": "// assert(n > 0);\n    std::vector<long> res;\n    if(n<=1){\n        res.push_back(n);\n    }else{\n        long l1 = n, l2 = 1, l3 = (n+1)/2;\n        while(l3 <= l2){\n            res.push_back(l1);\n            l3 = l3+l2;\n            l2 = l2+l1;\n        }\n    }\n    return res;",
    "grade-1": {
      "execution": 0
    },
    "2": "std::vector<long> result;\n  long next1 = 1;\n  long next2 = 1;\n  long next3 = 1;\n  for (long i = 1; i <= n; ++i) {\n    result.push_back(next3);\n    next3 = next1 + next2 + next3;\n    next2 = next1;\n    next1 = next3;\n  }\n  return result;",
    "grade-2": {
      "execution": 0
    },
    "3": "std::vector<long> v;\n\tlong t=3;\n\tv.push_back(1);\n\tv.push_back(3);\n\tv.push_back(2);\n\tv.push_back(8);\n\tfor(int i=4;i<=n;i++){\n\t\tif(i%2==0){\n\t\t\tt=1+i/2;\n\t\t}\n\t\telse{\n\t\t\tt=v[i-1]+v[i-2]+v[i+1];\n\t\t}\n\t\tv.push_back(t);\n\t}\n\treturn v;",
    "grade-3": {
      "execution": 0
    },
    "4": "std::vector<long> triSeq;\n    if(n == 0)\n        return triSeq;\n    triSeq.push_back(1);\n    if(n == 1)\n        return triSeq;\n    triSeq.push_back(3);\n    if(n == 2)\n        return triSeq;\n    triSeq.push_back(2);\n    if(n == 3)\n        return triSeq;\n    for(int i = 4; i <= n; i++){\n        if(i % 2 == 0)\n            triSeq.push_back(1 + i / 2);\n        else\n            triSeq.push_back(triSeq[i - 1] + triSeq[i - 2] + triSeq[i + 1]);\n    }\n    return triSeq;",
    "grade-4": {
      "execution": 0
    },
    "5": "std::vector<long> v(n+1);\n  v[0] = 1;\n  v[1] = 3;\n  v[2] = 2;\n  for(int i = 3; i <= n; i++) {\n    if(i % 2 == 0) {\n      v[i] = 1 + i / 2;\n    } else {\n      v[i] = v[i-1] + v[i-2] + v[i+1];\n    }\n  }\n  return v;",
    "grade-5": {
      "execution": 0
    }
  },
  {
    "intent": "#include<assert.h>\n#include<bits/stdc++.h>\n// Return length of given string\n// >>> strlen('')\n// 0\n// >>> strlen('abc')\n// 3\nlong strlen(std::string string) {\n",
    "task_id": "23",
    "prompt": "/*\nReturn length of given string\n>>> strlen(\"\")\n0\n>>> strlen(\"abc\")\n3\n*/\n#include<stdio.h>\n#include<string>\nusing namespace std;\nint strlen(string str){\n",
    "simplified_intent": "Return length of given string",
    "snippet": [
      "    return str.length();\n}\n"
    ],
    "sample_from": {
      "0": "incoder",
      "1": "incoder",
      "2": "incoder",
      "3": "codex",
      "4": "codex",
      "5": "codex"
    },
    "0": "long cnt=0;\n    for(int i = 0; i< string.length(); i++) {\n        cnt++;\n    }\n    return cnt;",
    "grade-0": {
      "execution": 0
    },
    "1": "auto it = string.begin();\n    auto end = string.end();\n    long length = 0;\n    while(it != end) {\n        it++;\n        length++;\n    }\n    return length;",
    "grade-1": {
      "execution": 0
    },
    "2": "// Write your code here.\n  return string.size();",
    "grade-2": {
      "execution": 0
    },
    "3": "assert(string.length() <= INT_MAX);\n\treturn string.length();",
    "grade-3": {
      "execution": 0
    },
    "4": "// TODO implement this function\n    return string.length();",
    "grade-4": {
      "execution": 0
    },
    "5": "long length=0;\n    for(int i=0;i<string.length();i++){\n        length++;\n    }\n    return length;",
    "grade-5": {
      "execution": 0
    }
  },
  {
    "intent": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function encrypt that takes a string as an argument and\n// returns a string encrypted with the alphabet being rotated. \n// The alphabet should be rotated in a manner such that the letters \n// shift down by two multiplied to two places.\n// For example:\n// encrypt('hi') returns 'lm'\n// encrypt('asdfghjkl') returns 'ewhjklnop'\n// encrypt('gf') returns 'kj'\n// encrypt('et') returns 'ix'\nstd::string encrypt(std::string s) {\n",
    "task_id": "89",
    "prompt": "/*\nCreate a function encrypt that takes a string as an argument and\nreturns a string encrypted with the alphabet being rotated. \nThe alphabet should be rotated in a manner such that the letters \nshift down by two multiplied to two places.\nFor example:\nencrypt(\"hi\") returns \"lm\"\nencrypt(\"asdfghjkl\") returns \"ewhjklnop\"\nencrypt(\"gf\") returns \"kj\"\nencrypt(\"et\") returns \"ix\"\n*/\n#include<stdio.h>\n#include<string>\nusing namespace std;\nstring encrypt(string s){\n",
    "simplified_intent": "Create a function encrypt that takes a string as an argument and returns a string encrypted with the alphabet being rotated. The alphabet should be rotated in a manner such that the letters shift down by two multiplied to two places.",
    "snippet": [
      "    string out;\n    int i;\n    for (i=0;i<s.length();i++)\n    {\n        int w=((int)s[i]+4-(int)'a')%26+(int)'a';   \n        out=out+(char)w;\n    }\n    return out;\n}\n"
    ],
    "sample_from": {
      "0": "incoder",
      "1": "incoder",
      "2": "incoder",
      "3": "codex",
      "4": "codex",
      "5": "codex"
    },
    "0": "int len = s.size();\n    // Rotate the alphabet by two multiples to get 'lm', then shift the letters down by two.\n    std::string newS;\n    for (int i = 0; i < len; i++)\n    {\n        newS += alpha[(alpha[(s.at(i))] + alpha[(s.at(i) + 1)])];\n    }\n    return newS;",
    "grade-0": {
      "execution": 0
    },
    "1": "int len = s.length();\n    std::string s2;\n    for (int i = 0; i < len / 2; i++) {\n        s2 += s[i];\n        s2 += s[i];\n    }\n    for (int i = len / 2; i < len; i++) {\n        s2 += s[i];\n        s2 += s[len - i - 1];\n    }\n    return s2;",
    "grade-1": {
      "execution": 0
    },
    "2": "std::string result;\n    for(int i=0; i<s.length(); i++)\n    {\n        if(s[i]<26) \n            result += rotator(s[i], 2);\n        else \n            result += rotator(s[i], 1);\n    }\n    return result;",
    "grade-2": {
      "execution": 0
    },
    "3": "std::string newString = \"\";\n    for (int i = 0; i < s.length(); i++) {\n        int newChar = s[i] + 2 * 2;\n        newString = newString + (char)newChar;\n    }\n    return newString;",
    "grade-3": {
      "execution": 0
    },
    "4": "std::string newstr = s;\n\tfor (size_t i = 0; i < s.length(); i++) {\n\t\tnewstr[i] += 4;\n\t}\n\treturn newstr;",
    "grade-4": {
      "execution": 0
    },
    "5": "std::string result;\n    std::string encryptDictionary = \"abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz\";\n    for (int i = 0; i < s.length(); i++) {\n        result += encryptDictionary[(s[i] - 97) * 2 + 26];\n    }\n    return result;",
    "grade-5": {
      "execution": 0
    }
  },
  {
    "intent": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function vowels_count which takes a string representing\n// a word as input and returns the number of vowels in the string.\n// Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n// vowel, but only when it is at the end of the given word.\n// Example:\n// >>> vowels_count(\"abcde\")\n// 2\n// >>> vowels_count(\"ACEDY\")\n// 3\nlong vowels_count(std::string s) {\n",
    "task_id": "64",
    "prompt": "/*\nWrite a function vowels_count which takes a string representing a word as input and returns the number of vowels in the string. Vowels in this case are 'a', 'e', 'i', 'o', 'u'. \nHere, 'y' is also a vowel, but only when it is at the end of the given word.\nExample: \n>>> vowels_count(\"abcde\") \n2 \n>>> vowels_count(\"ACEDY\") \n3\n*/\n#include<stdio.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\nint vowels_count(string s){\n",
    "simplified_intent": "Add more test cases.",
    "snippet": [
      "    string vowels=\"aeiouAEIOU\";\n    int count=0;\n    for (int i=0;i<s.length();i++)\n    if (find(vowels.begin(),vowels.end(),s[i])!=vowels.end())\n        count+=1;\n    if (s[s.length()-1]=='y' or s[s.length()-1]=='Y') count+=1;\n    return count;\n}\n"
    ],
    "sample_from": {
      "0": "incoder",
      "1": "incoder",
      "2": "incoder",
      "3": "codex",
      "4": "codex",
      "5": "codex"
    },
    "0": "long vowels=0;\n    for(char c:s)\n    {\n        if(c=='a' || c=='e' || c=='i' || c=='o' || c=='u')\n        {\n            vowels++;\n        }\n    }\n    return vowels;",
    "grade-0": {
      "execution": 0
    },
    "1": "long result = 0;\n    for (auto c : s) {\n        result += (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u');\n    }\n    return result;",
    "grade-1": {
      "execution": 0
    },
    "2": "int vowels[8] = { 'a', 'e', 'i', 'o', 'u', 'y', 'a' };\n  int n = s.size();\n  long count = 0;\n  for (int i = 0; i < n; i++) {\n    if (vowels[i] == s[n - 1 - i]) {\n      count++;\n    }\n  }\n  return count;",
    "grade-2": {
      "execution": 0
    },
    "3": "long count = 0;\n    for (int i = 0; i < s.length(); i++) {\n        char c = s[i];\n        if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u')\n            count++;\n        if (c == 'y' && i != s.length() - 1)\n            count++;\n    }\n    return count;",
    "grade-3": {
      "execution": 0
    },
    "4": "long cnt = 0;\n    for (auto x : s) {\n        if (x == 'a' || x == 'e' || x == 'i' || x == 'o' || x == 'u' || x == 'y') {\n            cnt++;\n        }\n    }\n    if (s[s.size() - 1] == 'y') cnt--;\n    return cnt;",
    "grade-4": {
      "execution": 0
    },
    "5": "int count = 0;\n\tfor (auto i = s.begin(); i != s.end(); i++) {\n\t\tswitch (*i) {\n\t\t\tcase 'a': case 'e': case 'i': case 'o': case 'u': case 'y':\n\t\t\t\tcount++;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tif (count > 0) {\n\t\tif (s.back() == 'y') {\n\t\t\tcount -= 1;\n\t\t}\n\t}\n\treturn count;",
    "grade-5": {
      "execution": 0
    }
  },
  {
    "intent": "#include<assert.h>\n#include<bits/stdc++.h>\n// For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n// Empty sum should be equal to 0 and empty product should be equal to 1.\n// >>> sum_product([])\n// (0, 1)\n// >>> sum_product([1, 2, 3, 4])\n// (10, 24)\nstd::tuple<long, long> sum_product(std::vector<long> numbers) {\n",
    "task_id": "8",
    "prompt": "/*\nFor a given vector of integers, return a vector consisting of a sum and a product of all the integers in a vector.\nEmpty sum should be equal to 0 and empty product should be equal to 1.\n>>> sum_product({})\n(0, 1)\n>>> sum_product({1, 2, 3, 4})\n(10, 24)\n*/\n#include<stdio.h>\n#include<vector>\nusing namespace std;\nvector<int> sum_product(vector<int> numbers){\n",
    "simplified_intent": "For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list. Empty sum should be equal to 0 and empty product should be equal to 1.",
    "snippet": [
      "    int sum=0,product=1;\n    for (int i=0;i<numbers.size();i++)\n    {\n        sum+=numbers[i];\n        product*=numbers[i];\n    }\n    return {sum,product};\n}\n"
    ],
    "sample_from": {
      "0": "incoder",
      "1": "incoder",
      "2": "incoder",
      "3": "codex",
      "4": "codex",
      "5": "codex"
    },
    "0": "// Your code goes here\n    long sum = 0;\n    long product = 1;\n    for (auto n : numbers) {\n        sum += n;\n        product *= n;\n    }\n    return std::make_tuple(sum, product);",
    "grade-0": {
      "execution": 1
    },
    "1": "// O(2N) Time Complexity\n    // O(1) Space Complexity\n    long long sum = 0, product = 1;\n    for (auto &num : numbers)\n        sum += num;\n    for (auto &num : numbers)\n        product *= num;\n    return std::make_tuple(sum, product);",
    "grade-1": {
      "execution": 1
    },
    "2": "if (numbers.empty())\n    return std::make_tuple(0, 1);\n\n  std::map<long, long> sumProductMap;\n  // Sum each number and store it in the map\n  for (long n : numbers) {\n    sumProductMap[n] = sumProductMap[n] + n;\n  }\n  // Multiply each number with its map's value and return as a tuple\n  std::tuple<long, long> sumProduct(sumProductMap.begin(), sumProductMap.end());\n  return sumProduct;",
    "grade-2": {
      "execution": 0
    },
    "3": "long sum = 0;\n    long product = 1;\n    if(numbers.size() == 0)\n        return {sum, product};\n    else{\n        for(int i = 0; i < numbers.size(); i++){\n            sum += numbers[i];\n            product *= numbers[i];\n        }\n        return {sum, product};\n    }",
    "grade-3": {
      "execution": 1
    },
    "4": "long sum=0,prod=1;\n    for(int i=0;i<numbers.size();i++){\n        sum+=numbers[i];\n        prod*=numbers[i];\n    }\n    return std::make_tuple(sum,prod);",
    "grade-4": {
      "execution": 1
    },
    "5": "long sum = 0;\n\tlong prod = 1;\n\tfor (auto i = numbers.begin(); i != numbers.end(); i++) {\n\t\tsum += *i;\n\t\tprod *= *i;\n\t}\n\treturn std::make_tuple(sum, prod);",
    "grade-5": {
      "execution": 1
    }
  },
  {
    "intent": "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n// >>> fizz_buzz(50)\n// 0\n// >>> fizz_buzz(78)\n// 2\n// >>> fizz_buzz(79)\n// 3\nlong fizz_buzz(long n) {\n",
    "task_id": "36",
    "prompt": "/*\nReturn the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n>>> fizz_buzz(50)\n0\n>>> fizz_buzz(78)\n2\n>>> fizz_buzz(79)\n3\n*/\n#include<stdio.h>\nusing namespace std;\nint fizz_buzz(int n){\n",
    "simplified_intent": "Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.",
    "snippet": [
      "    int count=0;\n    for (int i=0;i<n;i++)\n    if (i%11==0 or i%13==0)\n    {\n        int q=i;\n        while (q>0)\n        {\n            if (q%10==7) count+=1;\n            q=q/10;\n        }\n    } \n    return count;\n}\n"
    ],
    "sample_from": {
      "0": "incoder",
      "1": "incoder",
      "2": "incoder",
      "3": "codex",
      "4": "codex",
      "5": "codex"
    },
    "0": "assert(n % 100 == 0);\n    \n    long fizz_count = 0; // To keep count of the number of digits which are divisible by 11 or 13.\n    long curr = n / 100; // To keep track of the current digit while dividing n.\n    \n    while (curr > 0) {\n        // If the current digit is either 7 or 13.\n        if (curr % 10 == 7 || curr % 10 == 13) {\n            fizz_count++;\n        }\n        curr--;\n    }\n    return fizz_count;",
    "grade-0": {
      "execution": 0
    },
    "1": "//code\n    if (n == 0 || n == 1)\n        return 0;\n    long num_of_sevens = 0;\n    while (n > 0) {\n        if (n % 10 == 7) {\n            num_of_sevens += 1;\n        }\n        n /= 10;\n    }\n    return num_of_sevens;",
    "grade-1": {
      "execution": 0
    },
    "2": "long count = 0;\n  for (int i = 1; i < n; i++) {\n    long remainder = n % i;\n    long is_divisible_by_11 = 0;\n    long is_divisible_by_13 = 0;\n    if (remainder == 0) {\n      is_divisible_by_11 = 1;\n    } else {\n      is_divisible_by_13 = 1;\n    }\n    if (i % 11 == 0) {\n      is_divisible_by_11 = 1;\n    }\n    if (i % 13 == 0) {\n      is_divisible_by_13 = 1;\n    }\n    // If divisible\n    if (is_divisible_by_11 == 1 && is_divisible_by_13 == 1) {\n      count++;\n    }\n  }\n  return count;",
    "grade-2": {
      "execution": 0
    },
    "3": "long sum = 0;\n  for (int i = 0; i < n; i++) {\n    if ((i % 11 == 0) || (i % 13 == 0)) {\n      std::string digit = std::to_string(i);\n      if (digit.find(\"7\") != std::string::npos) {\n        sum += 1;\n      }\n    }\n  }\n  return sum;",
    "grade-3": {
      "execution": 0
    },
    "4": "long count = 0;\n    for (long i = 1; i < n; i++) {\n        if ((i % 11 == 0 || i % 13 == 0) && to_string(i).find(\"7\") != string::npos)\n            count++;\n    }\n    return count;",
    "grade-4": {
      "execution": 0
    },
    "5": "long count=0;\n    for(long i=1;i<n;i++){\n        if(i%11==0){\n            long copy=i;\n            while(copy!=0){\n                if(copy%10==7){\n                    count++;\n                }\n                copy=copy/10;\n            }\n        }\n        if(i%13==0){\n            long copy=i;\n            while(copy!=0){\n                if(copy%10==7){\n                    count++;\n                }\n                copy=copy/10;\n            }\n        }\n    }\n    return count;",
    "grade-5": {
      "execution": 0
    }
  },
  {
    "intent": "#include<assert.h>\n#include<bits/stdc++.h>\n// Input are two strings a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs and return result also as a string.\n// >>> string_xor('010', '110')\n// '100'\nstd::string string_xor(std::string a, std::string b) {\n",
    "task_id": "11",
    "prompt": "/*\nInput are two strings a and b consisting only of 1s and 0s.\nPerform binary XOR on these inputs and return result also as a string.\n>>> string_xor(\"010\", \"110\")\n\"100\"\n*/\n#include<stdio.h>\n#include<string>\nusing namespace std;\nstring string_xor(string a,string b){\n",
    "simplified_intent": "Input are two strings a and b consisting only of 1s and 0s. Perform binary XOR on these inputs and return result also as a string.",
    "snippet": [
      "    string output=\"\";\n    for (int i=0;(i<a.length() and i<b.length());i++)\n    {\n        if (i<a.length() and i<b.length())\n        {\n            if (a[i]== b[i]) \n            {\n                output+='0';\n            }  \n            else output+='1';\n        }\n        else\n        {\n            if (i>=a.length()) \n            {\n            output+=b[i];\n            }\n            else output+=a[i];\n        }\n    }\n    return output;\n}\n"
    ],
    "sample_from": {
      "0": "incoder",
      "1": "incoder",
      "2": "incoder",
      "3": "codex",
      "4": "codex",
      "5": "codex"
    },
    "0": "std::pair<std::string, std::string> res = std::make_pair(a, b);\n    return res.first;",
    "grade-0": {
      "execution": 0
    },
    "1": "int n = a.size();\n  int m = b.size();\n  std::string c(n, '\\0');\n  for (int i = 0; i < n; ++i) {\n    c[i] = a[i] ^ b[i];\n  }\n  return c;",
    "grade-1": {
      "execution": 0
    },
    "2": "int size = a.size() + b.size();\n    std::string result;\n    result.reserve(size);\n    int i, j = 0;\n    for (i = 0; i < a.size(); ++i) {\n        if (i != b.size()) {\n            result += a[i];\n            result += b[j];\n            j++;\n        } else {\n            result += a[i];\n        }\n    }\n    return result;",
    "grade-2": {
      "execution": 0
    },
    "3": "std::string result = \"\";  // initialize result\n    // Traverse all characters\n    for (int i = 0; i < a.size(); i++) {\n        // If characters are same, append 0 to result\n        if (a[i] == b[i])\n            result.push_back('0');\n        // Else append 1 to result\n        else\n            result.push_back('1');\n    }\n    return result;",
    "grade-3": {
      "execution": 1
    },
    "4": "std::string output = \"\";\n    int size = a.size();\n    for(int i = 0; i < size; i++) {\n        if (a[i] == b[i])\n            output += \"0\";\n        else\n            output += \"1\";\n    }\n    return output;",
    "grade-4": {
      "execution": 1
    },
    "5": "std::string result = \"\";\n    int s = a.size();\n    int t = b.size();\n    int  i = 0;\n    // Append zeros to make length's of both string same\n    if(s < t) {\n        for(i = 0 ; i < t - s ; i++) {\n            a = '0' + a;\n        }\n    }\n    else if(s > t) {\n        for(i = 0 ; i < s - t ; i++) {\n            b = '0' + b;\n        }\n    }\n    for(i = 0 ; i < a.size() ; i++) {\n        result += (a[i] == b[i]) ? '0' : '1';\n    }\n    return result;",
    "grade-5": {
      "execution": 1
    }
  },
  {
    "intent": "#include<assert.h>\n#include<bits/stdc++.h>\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// [2, 2, 2]\n// >>> factorize(25)\n// [5, 5]\n// >>> factorize(70)\n// [2, 5, 7]\nstd::vector<long> factorize(long n) {\n",
    "task_id": "25",
    "prompt": "/*\nReturn vector of prime factors of given integer in the order from smallest to largest.\nEach of the factors should be vectored number of times corresponding to how many times it appeares in factorization.\nInput number should be equal to the product of all factors\n>>> factorize(8)\n{2, 2, 2}\n>>> factorize(25)\n{5, 5}\n>>> factorize(70)\n{2, 5, 7}\n*/\n#include<stdio.h>\n#include<vector>\nusing namespace std;\nvector<int> factorize(int n){\n",
    "simplified_intent": "Return list of prime factors of given integer in the order from smallest to largest. Each of the factors should be listed number of times corresponding to how many times it appeares in factorization. Input number should be equal to the product of all factors",
    "snippet": [
      "    vector<int> out={};\n    for (int i=2;i*i<=n;i++)\n        if (n%i==0)\n        {\n            n=n/i;\n            out.push_back(i);\n            i-=1;\n        }\n    out.push_back(n);\n    return out;\n}\n"
    ],
    "sample_from": {
      "0": "incoder",
      "1": "incoder",
      "2": "incoder",
      "3": "codex",
      "4": "codex",
      "5": "codex"
    },
    "0": "std::vector<long> factorization;\n  long r = 1;\n  while (n % r != 0) {\n    long c = r * 2;\n    while (n % c != 0) {\n      c = c * 2;\n    }\n    r = c;\n  }\n  factorization.push_back(r);\n  while (n != 1) {\n    r = r * 2;\n    n = n / r;\n    if (n != 1) {\n      factorization.push_back(r);\n    }\n  }\n  return factorization;",
    "grade-0": {
      "execution": 0
    },
    "1": "std::vector<long> factorization;\n    factorization.push_back(n);\n    long m = n;\n    long factor = 1;\n    while (m != 1) {\n        while (m%factor == 0) {\n            factor++;\n        }\n        if (factor != 2) {\n            factorization.push_back(factor);\n        }\n        m /= factor;\n    }\n    return factorization;",
    "grade-1": {
      "execution": 0
    },
    "2": "// Store list of factors and how many times each one appeared in factorization\n    std::vector < long > factors;\n    long counter = 0;\n\n    // Generate list of factors of number\n    do {\n        // If current number is divisible by all factors\n        if (n % i == 0) {\n            // Add factor to list\n            factors.push_back(i);\n\n            // Add 1 to count of this factor in factorization\n            counter++;\n\n            // Remove number from number (since we've already gotten it above)\n            n /= i;\n        }\n    } while (n > 1);\n\n    // Return factors\n    return factors;",
    "grade-2": {
      "execution": 0
    },
    "3": "std::vector<long> v;\n\tint cnt = 0;\n\twhile (n % 2 == 0) {\n\t\tcnt++;\n\t\tn /= 2;\n\t}\n\tif (cnt > 0) {\n\t\tfor (int i = 0; i < cnt; i++)\n\t\t\tv.push_back(2);\n\t}\n\tfor (int i = 3; i <= sqrt(n); i += 2) {\n\t\tcnt = 0;\n\t\twhile (n % i == 0) {\n\t\t\tcnt++;\n\t\t\tn /= i;\n\t\t}\n\t\tif (cnt > 0) {\n\t\t\tfor (int j = 0; j < cnt; j++)\n\t\t\t\tv.push_back(i);\n\t\t}\n\t}\n\tif (n > 2) {\n\t\tv.push_back(n);\n\t}\n\treturn v;",
    "grade-3": {
      "execution": 1
    },
    "4": "std::vector<long> result;\n\tlong number = n;\n\tfor (long factor = 2; factor * factor <= number; factor++) {\n\t\twhile (number % factor == 0) {\n\t\t\tresult.push_back(factor);\n\t\t\tnumber /= factor;\n\t\t}\n\t}\n\tif (number > 1) {\n\t\tresult.push_back(number);\n\t}\n\treturn result;",
    "grade-4": {
      "execution": 1
    },
    "5": "std::vector<long> res;\n    while(n%2==0){\n        res.push_back(2);\n        n/=2;\n    }\n    for(long i=3;i<=sqrt(n);i+=2){\n        while(n%i==0){\n            res.push_back(i);\n            n/=i;\n        }\n    }\n    if(n>2)\n        res.push_back(n);\n    return res;",
    "grade-5": {
      "execution": 1
    }
  },
  {
    "intent": "#include<assert.h>\n#include<bits/stdc++.h>\n// You're given a list of deposit and withdrawal operations on a bank account that starts with\n// zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n// at that point function should return True. Otherwise it should return False.\n// >>> below_zero([1, 2, 3])\n// False\n// >>> below_zero([1, 2, -4, 5])\n// True\nbool below_zero(std::vector<long> operations) {\n",
    "task_id": "3",
    "prompt": "/*\nYou\"re given a vector of deposit and withdrawal operations on a bank account that starts with\nzero balance. Your task is to detect if at any point the balance of account falls below zero, and\nat that point function should return true. Otherwise it should return false.\n>>> below_zero({1, 2, 3})\nfalse\n>>> below_zero({1, 2, -4, 5})\ntrue\n*/\n#include<stdio.h>\n#include<vector>\nusing namespace std;\nbool below_zero(vector<int> operations){\n",
    "simplified_intent": "You're given a list of deposit and withdrawal operations on a bank account that starts with zero balance. Your task is to detect if at any point the balance of account fallls below zero, and at that point function should return True. Otherwise it should return False.",
    "snippet": [
      "    int num=0;\n    for (int i=0;i<operations.size();i++)\n    {\n        num+=operations[i];\n        if (num<0) return true;\n    }\n    return false;\n}\n"
    ],
    "sample_from": {
      "0": "incoder",
      "1": "incoder",
      "2": "incoder",
      "3": "codex",
      "4": "codex",
      "5": "codex"
    },
    "0": "//Complete the function\n    int flag = 1;\n    int sum = 0;\n    for(int i=0;i<operations.size();i++){\n        sum+=operations[i];\n    }\n    if(sum<0){\n        sum=sum*-1;\n        flag=0;\n    }\n    return flag;",
    "grade-0": {
      "execution": 0
    },
    "1": "// Your code here\n    if (operations.empty())\n        return true;\n    if (operations[0] == 0)\n        return false;\n    return below_zero(operations.cbegin() + 1, operations.cend() - 1);",
    "grade-1": {
      "execution": 0
    },
    "2": "int sum = 0;\n  for (int i = 0; i < operations.size(); i++) {\n    sum += operations[i];\n    if (sum < 0)\n      return false;\n  }\n  return true;",
    "grade-2": {
      "execution": 0
    },
    "3": "long t=0;\n\tfor(int i=0;i<operations.size();i++)\n\t{\n\t\tt+=operations[i];\n\t\tif(t<0)\n\t\t\treturn true;\n\t}\n\treturn false;",
    "grade-3": {
      "execution": 1
    },
    "4": "std::vector<long>::iterator itr = operations.begin();\n  long temp = 0;\n  while(itr != operations.end()) {\n    temp += *itr;\n    if(temp < 0) {\n      return true;\n    }\n    itr++;\n  }\n  return false;",
    "grade-4": {
      "execution": 1
    },
    "5": "long sum = 0;\n    for (auto it : operations) {\n        sum += it;\n        if (sum < 0) {\n            return true;\n        }\n    }\n    return false;",
    "grade-5": {
      "execution": 1
    }
  },
  {
    "intent": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that returns True if the object q will fly, and False otherwise.\n// The object q will fly if it's balanced (it is a palindromic list) and the sum of its elements is less than or equal the maximum possible weight w.\n// Example:\n// will_it_fly([1, 2], 5) \u279e False \n// # 1+2 is less than the maximum possible weight, but it's unbalanced.\n// will_it_fly([3, 2, 3], 1) \u279e False\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n// will_it_fly([3, 2, 3], 9) \u279e True\n// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n// will_it_fly([3], 5) \u279e True\n// # 3 is less than the maximum possible weight, and it's balanced.\nbool will_it_fly(std::vector<long> q, long w) {\n",
    "task_id": "72",
    "prompt": "/*\nWrite a function that returns true if the object q will fly, and false otherwise.\nThe object q will fly if it's balanced (it is a palindromic vector) and the sum of its elements is less than or equal the maximum possible weight w.\n\nExample:\nwill_it_fly({1, 2}, 5) \u279e false \n// 1+2 is less than the maximum possible weight, but it's unbalanced.\n\nwill_it_fly({3, 2, 3}, 1) \u279e false\n// it's balanced, but 3+2+3 is more than the maximum possible weight.\n\nwill_it_fly({3, 2, 3}, 9) \u279e true\n// 3+2+3 is less than the maximum possible weight, and it's balanced.\n\nwill_it_fly({3}, 5) \u279e true\n// 3 is less than the maximum possible weight, and it's balanced.\n*/\n#include<stdio.h>\n#include<vector>\nusing namespace std;\nbool will_it_fly(vector<int> q,int w){\n",
    "simplified_intent": "Write a function that returns True if the object q will fly, and False otherwise. The object q will fly if it's balanced (it is a palindromic list) and the sum of its elements is less than or equal the maximum possible weight w.",
    "snippet": [
      "    int sum=0;\n    for (int i=0;i<q.size();i++)\n    {\n        if (q[i]!=q[q.size()-1-i]) return false;\n        sum+=q[i];\n    }\n    if (sum>w) return false;\n    return true;\n}\n"
    ],
    "sample_from": {
      "0": "incoder",
      "1": "incoder",
      "2": "incoder",
      "3": "codex",
      "4": "codex",
      "5": "codex"
    },
    "0": "if(q.size()<1){\n        return false;\n    }\n    if(q.back()!=(q.size()-1)){\n        return false;\n    }\n    long sum=0;\n    for(auto i:q){\n        sum+=i;\n    }\n    if(sum<=w){\n        return true;\n    }\n    return false;",
    "grade-0": {
      "execution": 0
    },
    "1": "long max = INT_MIN;\n    for(long i = 0; i < q.size(); ++i) {\n        max = std::max(max, q[i]);\n    }\n    long min_sum = INT_MAX;\n    for(long i = 0; i < q.size(); ++i) {\n        min_sum = std::min(min_sum, q[i] + w);\n    }\n    return (min_sum == max);",
    "grade-1": {
      "execution": 0
    },
    "2": "int n = q.size();\n    if(n < 2) return true;\n    long max_weight = w;\n    long min_weight = w;\n    long sum = 0;\n    while(!q.empty()) {\n        sum += q.front();\n        q.pop_front();\n        if(sum == max_weight) {\n            sum += max_weight - min_weight;\n            max_weight -= min_weight;\n            min_weight = w;\n        }\n        else if(sum < max_weight) {\n            min_weight += w;\n        }\n        else if(sum > max_weight) {\n            max_weight -= w;\n        }\n    }\n    return sum == 0;",
    "grade-2": {
      "execution": 0
    },
    "3": "int sum = 0;\n    int i = 0;\n    int j = q.size() - 1;\n    while(i <= j){\n        if(q[i] != q[j]){\n            return false;\n        }\n        sum += q[i];\n        i++;\n        j--;\n    }\n    if(sum <= w){\n        return true;\n    }\n    return false;",
    "grade-3": {
      "execution": 1
    },
    "4": "bool isBalanced = false;\n\tint sum = 0;\n\tfor (int i = 0; i < q.size(); i++) {\n\t\tsum += q[i];\n\t}\n\tstd::reverse(q.begin(), q.end());\n\tif (q == q) {\n\t\tisBalanced = true;\n\t}\n\tif (sum <= w && isBalanced) {\n\t\treturn true;\n\t}\n\telse {\n\t\treturn false;\n\t}",
    "grade-4": {
      "execution": 0
    },
    "5": "int sz = q.size();\n\tlong sum = 0;\n\tfor (int i = 0; i < sz; i++) {\n\t\tsum += q[i];\n\t}\n\tbool balanced = true;\n\tfor (int i = 0; i < sz / 2; i++) {\n\t\tif (q[i] != q[sz - i - 1]) {\n\t\t\tbalanced = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn balanced&&(sum <= w);",
    "grade-5": {
      "execution": 1
    }
  },
  {
    "intent": "#include<assert.h>\n#include<bits/stdc++.h>\n// Task\n// Write a function that takes a string as input and returns the sum of the upper characters only'\n// ASCII codes.\n// Examples:\n// digitSum(\"\") => 0\n// digitSum(\"abAB\") => 131\n// digitSum(\"abcCd\") => 67\n// digitSum(\"helloE\") => 69\n// digitSum(\"woArBld\") => 131\n// digitSum(\"aAaaaXa\") => 153\nlong digitSum(std::string s) {\n",
    "task_id": "66",
    "prompt": "/*\nTask\nWrite a function that takes a string as input and returns the sum of the upper characters only's\nASCII codes.\n\nExamples:\n    digitSum(\"\") => 0\n    digitSum(\"abAB\") => 131\n    digitSum(\"abcCd\") => 67\n    digitSum(\"helloE\") => 69\n    digitSum(\"woArBld\") => 131\n    digitSum(\"aAaaaXa\") => 153\n*/\n#include<stdio.h>\n#include<string>\nusing namespace std;\nint digitSum(string s){\n",
    "simplified_intent": "Task Write a function that takes a string as input and returns the sum of the upper characters only' ASCII codes.",
    "snippet": [
      "    int sum=0;\n    for (int i=0;i<s.length();i++)\n        if (s[i]>=65 and s[i]<=90)\n            sum+=s[i];\n    return sum;\n}\n"
    ],
    "sample_from": {
      "0": "incoder",
      "1": "incoder",
      "2": "incoder",
      "3": "codex",
      "4": "codex",
      "5": "codex"
    },
    "0": "long sum = 0;\n    for (char &c: s) {\n        sum += (c < 'A' && c > 'a') ? c - 'a' + 10 : c - 'A' + 10;\n    }\n    return sum;",
    "grade-0": {
      "execution": 0
    },
    "1": "int n = s.length();\n    long sum = 0;\n    int maxValue = 0;\n    for (int i = 0; i < n; i++) {\n        // convert ascii to int\n        int intValue = s[i];\n        // add ascii of upper letters to sum\n        sum += intValue + maxValue;\n        // update max value\n        maxValue = intValue > maxValue ? intValue : maxValue;\n    }\n    return sum;",
    "grade-1": {
      "execution": 0
    },
    "2": "int result = 0;\n  for (int i = 0; i < s.length(); i++) {\n    if ((int)s[i] == (int)s[i - 1]) continue;\n    result += (int)s[i];\n  }\n  return result;",
    "grade-2": {
      "execution": 0
    },
    "3": "long sum = 0;\n    for(auto it = s.begin(); it != s.end(); it++) {\n        if(*it >= 'A' && *it <= 'Z') {\n            sum += (int)*it;\n        }\n    }\n    return sum;",
    "grade-3": {
      "execution": 1
    },
    "4": "//your code here",
    "grade-4": {
      "execution": 0
    },
    "5": "long sum = 0;\n  for (auto i : s) {\n    if (std::isupper(i)) {\n      sum += (int)i;\n    }\n  }\n  return sum;",
    "grade-5": {
      "execution": 1
    }
  },
  {
    "intent": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array arr of integers and you need to return\n// sum of magnitudes of integers multiplied by product of all signs\n// of each number in the array, represented by 1, -1 or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1, 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\nstd::optional<long> prod_signs(std::vector<long> arr) {\n",
    "task_id": "128",
    "prompt": "/*\nYou are given a vector arr of integers and you need to return\nsum of magnitudes of integers multiplied by product of all signs\nof each number in the vector, represented by 1, -1 or 0.\nNote: return -32768 for empty arr.\n\nExample:\n>>> prod_signs({1, 2, 2, -4}) == -9\n>>> prod_signs({0, 1}) == 0\n>>> prod_signs({}) == -32768\n*/\n#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\nint prod_signs(vector<int> arr){\n",
    "simplified_intent": "You are given an array arr of integers and you need to return sum of magnitudes of integers multiplied by product of all signs of each number in the array, represented by 1, -1 or 0. Note: return None for empty arr.",
    "snippet": [
      "    if (arr.size()==0) return -32768;\n    int i,sum=0,prods=1;\n    for (i=0;i<arr.size();i++)\n    {\n        sum+=abs(arr[i]);\n        if (arr[i]==0) prods=0;\n        if (arr[i]<0) prods=-prods;\n   }\n   return sum*prods;\n}\n"
    ],
    "sample_from": {
      "0": "incoder",
      "1": "incoder",
      "2": "incoder",
      "3": "codex",
      "4": "codex",
      "5": "codex"
    },
    "0": "int n = arr.size();\n  long sum = 0;\n  for (int i = 0; i < n; ++i) {\n    long v = arr[i];\n    for (int j = i; j >= 0; j--) {\n      if (arr[j] < 0) v = -v;\n    }\n    sum += v;\n  }\n  return sum * std::signbit(sum);",
    "grade-0": {
      "execution": 0
    },
    "1": "int n = arr.size();\n    long prod = 0;\n    for (int i = 0; i < n; i++) {\n        long sign = arr[i] >> 63;\n        long val = arr[i] & 1LL << 63;\n        prod += sign * val * (sign != 0);\n    }\n    return prod;",
    "grade-1": {
      "execution": 0
    },
    "2": "long ans = 0;\n  std::for_each(arr.begin(), arr.end(), [&](long &i) { ans += i * i * i / i; });\n  return std::optional<long>(ans);",
    "grade-2": {
      "execution": 0
    },
    "3": "if (arr.empty()) return std::nullopt;\n    if (arr.size() == 1) return arr[0];\n    if (arr.size() == 2) return arr[0] * arr[1];\n    long prod = 1;\n    for (const auto& el : arr) {\n        if (el > 0) prod *= 1;\n        else if (el < 0) prod *= -1;\n        else prod *= 0;\n    }\n    long result = 0;\n    for (const auto& el : arr) {\n        result += std::abs(el);\n    }\n    return result * prod;",
    "grade-3": {
      "execution": 0
    },
    "4": "if (arr.empty()) {\n        return std::nullopt;\n    }\n    int prod = 1;\n    int sum = 0;\n    for (long elem : arr) {\n        if (elem < 0) {\n            prod *= -1;\n        } else if (elem > 0) {\n            sum += elem;\n        }\n    }\n    return sum * prod;",
    "grade-4": {
      "execution": 0
    },
    "5": "if (arr.empty()) {\n\t\treturn std::nullopt;\n\t}\n\n\t// TODO:\n\n\treturn std::nullopt;",
    "grade-5": {
      "execution": 0
    }
  },
  {
    "intent": "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer n, you have to make a pile of n levels of stones.\n// The first level has n stones.\n// The number of stones in the next level is:\n// - the next odd number if n is odd.\n// - the next even number if n is even.\n// Return the number of stones in each level in a list, where element at index\n// i represents the number of stones in the level (i+1).\n// Examples:\n// >>> make_a_pile(3)\n// [3, 5, 7]\nstd::vector<long> make_a_pile(long n) {\n",
    "task_id": "100",
    "prompt": "/*\nGiven a positive integer n, you have to make a pile of n levels of stones.\nThe first level has n stones.\nThe number of stones in the next level is:\n    - the next odd number if n is odd.\n    - the next even number if n is even.\nReturn the number of stones in each level in a vector, where element at index\ni represents the number of stones in the level (i+1).\n\nExamples:\n>>> make_a_pile(3)\n{3, 5, 7}\n*/\n#include<stdio.h>\n#include<vector>\nusing namespace std;\nvector<int> make_a_pile(int n){\n",
    "simplified_intent": "Given a positive integer n, you have to make a pile of n levels of stones. The first level has n stones. The number of stones in the next level is: - the next odd number if n is odd. - the next even number if n is even. Return the number of stones in each level in a list, where element at index i represents the number of stones in the level (i+1).",
    "snippet": [
      "    vector<int> out={n};\n    for (int i=1;i<n;i++)\n        out.push_back(out[out.size()-1]+2);\n    return out;\n}\n"
    ],
    "sample_from": {
      "0": "incoder",
      "1": "incoder",
      "2": "incoder",
      "3": "codex",
      "4": "codex",
      "5": "codex"
    },
    "0": "std::vector<long> pile;\n    if(n%2 == 0){\n        for(long i = 0; i < n; i++){\n            pile.push_back(i+1);\n        }\n    }else{\n        for(long i = 0; i < n; i++){\n            pile.push_back(i);\n        }\n    }\n    return pile;",
    "grade-0": {
      "execution": 0
    },
    "1": "std::vector<long> ans;\n    // your code goes here\n    long x = 1;\n    long y = 1;\n    long z = 1;\n    int k = 0;\n    for(long i = 0; i < n; i++){\n        long n = k + x;\n        ans.push_back(n);\n        x = y;\n        y = z;\n        z = (x + y) % n;\n        k++;\n    }\n    return ans;",
    "grade-1": {
      "execution": 0
    },
    "2": "assert(n >= 0);\n    long nums = 1;\n    long num_even = 1;\n    long num_odd = 1;\n    for (long i = 2; i <= n; i++) {\n        long num = nums * i;\n        if (i % 2 == 0) {\n            num_even = num_even * i;\n        } else {\n            num_odd = num_odd * i;\n        }\n        nums = num;\n    }\n    std::vector<long> result(num_even+1, num_odd+1);\n    result[0] = nums;\n    long curr = 0;\n    for (long i = 1; i <= n; i++) {\n        result[i] += result[i - 1];\n        curr = result[i - 1];\n        result[i - 1] = curr;\n    }\n    return result;",
    "grade-2": {
      "execution": 0
    },
    "3": "assert(n >= 1);\n    std::vector<long> result;\n    long i = n;\n    for (; i > 0; n = (n % 2) ? n + 2 : n + 1) {\n        result.push_back(n);\n    }\n    return result;",
    "grade-3": {
      "execution": 0
    },
    "4": "std::vector<long> vec;\n  while (n > 0) {\n    vec.push_back(n);\n    n = n % 2 == 0 ? n + 1 : n + 2;\n  }\n  return vec;",
    "grade-4": {
      "execution": 0
    },
    "5": "std::vector<long> result;\n    if (n == 0) {\n        return result;\n    }\n    result.push_back(n);\n    while (n > 0) {\n        if (n % 2 == 0) {\n            n = n / 2;\n        } else {\n            n = (n - 1) / 2;\n        }\n        result.push_back(n);\n    }\n    return result;",
    "grade-5": {
      "execution": 0
    }
  },
  {
    "intent": "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer N, return the total sum of its digits in binary.\n// Example\n// For N = 1000, the sum of digits will be 1 the output should be \"1\".\n// For N = 150, the sum of digits will be 6 the output should be \"110\".\n// For N = 147, the sum of digits will be 12 the output should be \"1100\".\n// Variables:\n// @N integer\n// Constraints: 0 \u2264 N \u2264 10000.\n// Output:\n// a string of binary number\nstd::string solve(long N) {\n",
    "task_id": "84",
    "prompt": "/*\nGiven a positive integer N, return the total sum of its digits in binary.\n\nExample\n    For N = 1000, the sum of digits will be 1 the output should be \"1\".\n    For N = 150, the sum of digits will be 6 the output should be \"110\".\n    For N = 147, the sum of digits will be 12 the output should be \"1100\".\n\nVariables:\n    @N integer\n         Constraints: 0 \u2264 N \u2264 10000.\nOutput:\n     a string of binary number\n*/\n#include<stdio.h>\n#include<string>\nusing namespace std;\nstring solve(int N){\n",
    "simplified_intent": "Given a positive integer N, return the total sum of its digits in binary.",
    "snippet": [
      "    string str,bi=\"\";\n    str=to_string(N);\n    int i,sum=0;\n    for (int i=0;i<str.length();i++)\n        sum+=str[i]-48;\n    while (sum>0)\n    {\n        bi=to_string(sum%2)+bi;\n        sum=sum/2;\n    }\n    return bi;\n}\n"
    ],
    "sample_from": {
      "0": "incoder",
      "1": "incoder",
      "2": "incoder",
      "3": "codex",
      "4": "codex",
      "5": "codex"
    },
    "0": "long long num_bin;\n    std::string s;\n    while(N >=1000){\n        num_bin = (N % 1000) * 1000 + N / 1000;\n        s += to_string(num_bin);\n        N -= num_bin;\n    }\n    while(N >0){\n        num_bin = N%10;\n        s += to_string(num_bin);\n        N -= num_bin;\n    }\n    return s;",
    "grade-0": {
      "execution": 0
    },
    "1": "// your code goes here\n    std::string binary = \"\";\n    long sum = 0;\n    while (N >> 1)\n    {\n        int i = N & 1;\n        sum = sum + i;\n        N = N >> 1;\n        binary += std::to_string(i);\n    }\n    binary = std::to_string(sum) + binary;\n    return binary;",
    "grade-1": {
      "execution": 0
    },
    "2": "std::string s = std::to_string(n);\n    return s;",
    "grade-2": {
      "execution": 0
    },
    "3": "std::string result;\n    std::bitset<32> binary(N);\n    unsigned long total = 0;\n    for (int i = 0; i < binary.size(); i++) {\n        if (binary[i] == 1) {\n            total += 1;\n        }\n    }\n    result = std::to_string(total);\n    return result;",
    "grade-3": {
      "execution": 0
    },
    "4": "// Write your code here\n    return \"\";",
    "grade-4": {
      "execution": 0
    },
    "5": "std::string result;\n    // Write your code here\n    std::vector<int> v;\n    int sum=0;\n    while(N>0)\n    {\n        if(N%2==0)\n        {\n            v.push_back(0);\n        }\n        else\n        {\n            v.push_back(1);\n        }\n        N/=2;\n    }\n    // std::reverse(v.begin(),v.end());\n    for(int i=v.size()-1;i>=0;i--)\n    {\n        sum+=v[i];\n    }\n    result=std::to_string(sum);\n    return result;",
    "grade-5": {
      "execution": 0
    }
  },
  {
    "intent": "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer n, return the product of the odd digits.\n// Return 0 if all digits are even.\n// For example:\n// digits(1)  == 1\n// digits(4)  == 0\n// digits(235) == 15\nlong digits(long n) {\n",
    "task_id": "131",
    "prompt": "/*\nGiven a positive integer n, return the product of the odd digits.\nReturn 0 if all digits are even.\nFor example:\ndigits(1)  == 1\ndigits(4)  == 0\ndigits(235) == 15\n*/\n#include<stdio.h>\n#include<string>\nusing namespace std;\nint digits(int n){\n",
    "simplified_intent": "Given a positive integer n, return the product of the odd digits. Return 0 if all digits are even.",
    "snippet": [
      "    int prod=1,has=0;\n    string s=to_string(n);\n    for (int i=0;i<s.length();i++)\n        if (s[i]%2==1) \n        {\n            has=1;\n            prod=prod*(s[i]-48);\n        }\n    if (has==0) return 0;\n    return prod;\n}\n"
    ],
    "sample_from": {
      "0": "incoder",
      "1": "incoder",
      "2": "incoder",
      "3": "codex",
      "4": "codex",
      "5": "codex"
    },
    "0": "long d = 0;\n\twhile (n > 0) {\n\t\td *= 10;\n\t\td += (n % 10);\n\t\tn /= 10;\n\t}\n\treturn d * 2;",
    "grade-0": {
      "execution": 0
    },
    "1": "int x = n;\n    long res = 1;\n    while(x > 0) {\n        res *= x%10;\n        x /= 10;\n    }\n    return res%2 ? res : 0;",
    "grade-1": {
      "execution": 0
    },
    "2": "assert(n);\n\tlong ret = 1;\n\twhile (n > 0) {\n\t\tret *= n % 10;\n\t\tn /= 10;\n\t}\n\treturn ret % 2 ? 0 : ret;",
    "grade-2": {
      "execution": 0
    },
    "3": "long out = 1;\n  while (n != 0) {\n    int dig = n % 10;\n    if (dig % 2 != 0) {\n      out *= dig;\n    }\n    n /= 10;\n  }\n  return out;",
    "grade-3": {
      "execution": 0
    },
    "4": "long product = 1;\n  int digit = 0;\n  while (n != 0) {\n    digit = n % 10;\n    if (digit % 2 != 0) {\n      product *= digit;\n    }\n    n /= 10;\n  }\n  return product;",
    "grade-4": {
      "execution": 0
    },
    "5": "long product = 1;\n  while (n) {\n    int i = n % 10;\n    if (i % 2 != 0) {\n      product *= i;\n    }\n    n /= 10;\n  }\n  return product;",
    "grade-5": {
      "execution": 0
    }
  },
  {
    "intent": "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit, and you already have eaten a certain number of carrots,\n// but now you need to eat more carrots to complete the day's meals.\n// you should return an array of [ total number of eaten carrots after your meals,\n// the number of carrots left after your meals ]\n// if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n// * eat(5, 6, 10) -> [11, 4]\n// * eat(4, 8, 9) -> [12, 1]\n// * eat(1, 10, 10) -> [11, 0]\n// * eat(2, 11, 5) -> [7, 0]\n// Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n// @need : integer\n// the number of carrots that you need to eat.\n// @remaining : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long> eat(long number, long need, long remaining) {\n",
    "task_id": "159",
    "prompt": "/*\nYou\"re a hungry rabbit, and you already have eaten a certain number of carrots,\nbut now you need to eat more carrots to complete the day's meals.\nyou should return a vector of { total number of eaten carrots after your meals,\n                                the number of carrots left after your meals }\nif there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n\nExample:\n* eat(5, 6, 10) -> {11, 4}\n* eat(4, 8, 9) -> {12, 1}\n* eat(1, 10, 10) -> {11, 0}\n* eat(2, 11, 5) -> {7, 0}\n\nVariables:\n@number : integer\n    the number of carrots that you have eaten.\n@need : integer\n    the number of carrots that you need to eat.\n@remaining : integer\n    the number of remaining carrots thet exist in stock\n\nConstrain:\n* 0 <= number <= 1000\n* 0 <= need <= 1000\n* 0 <= remaining <= 1000\n\nHave fun :)\n*/\n#include<stdio.h>\n#include<vector>\nusing namespace std;\nvector<int> eat(int number,int need,int remaining){\n",
    "simplified_intent": "You're a hungry rabbit, and you already have eaten a certain number of carrots, but now you need to eat more carrots to complete the day's meals. you should return an array of [ total number of eaten carrots after your meals, the number of carrots left after your meals ] if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.",
    "snippet": [
      "    if (need>remaining) return {number+remaining, 0};\n    return {number+need,remaining-need};\n}\n"
    ],
    "sample_from": {
      "0": "incoder",
      "1": "incoder",
      "2": "incoder",
      "3": "codex",
      "4": "codex",
      "5": "codex"
    },
    "0": "long dp[1001][1001];\n    for (long i = 0; i < 1000; i++) {\n        for (long j = 0; j < 1000; j++) {\n            long tmp = number;\n            dp[i][j] = tmp;\n            for (int k = 0; k < j; k++) {\n                tmp -= (dp[i + 1][k] - dp[i][j]) * need;\n            }\n            if (tmp >= 0) {\n                dp[i][j] = tmp;\n            }\n        }\n    }\n    std::vector<long> ans;\n    long ans1 = 0;\n    long ans2 = 0;\n    for (long i = 0; i < 1000; i++) {\n        long sum = 0;\n        for (int j = 0; j < 1000; j++) {\n            sum += dp[i][j];\n        }\n        if (sum < number) {\n            ans1 = sum;\n        }\n        if (sum > number) {\n            ans2 = sum - number;\n        }\n    }\n    if (ans1 == ans2)\n        ans.push_back(ans1);\n    else\n        ans.push_back(ans2);\n    return ans;",
    "grade-0": {
      "execution": 0
    },
    "1": "// Write your code here.\n    std::vector<long> res;\n    long meals = 0;\n    long carrots = number;\n    while(carrots >= meals){\n        meals = meals + need;\n        carrots = carrots - meals;\n        res.push_back(carrots);\n    }\n    if(carrots > 0){\n        res.push_back(carrots);\n    }\n    return res;",
    "grade-1": {
      "execution": 0
    },
    "2": "long left = (number - remaining);\n    long right = (remaining - need);\n    if (left == 0) {\n        return std::vector<long>(1, left);\n    } else if (right == 0) {\n        return std::vector<long>(1, right);\n    } else {\n        std::vector<long> res;\n        res.push_back(left);\n        res.push_back(right);\n        if (res.front() > res.back()) {\n            return res;\n        } else {\n            return eat(number, need, remaining);\n        }\n    }",
    "grade-2": {
      "execution": 0
    },
    "3": "std::vector<long> res(2);\n    if (need > remaining) {\n        res[0] = number + remaining;\n        res[1] = 0;\n    } else {\n        res[0] = number + need;\n        res[1] = remaining - need;\n    }\n    return res;",
    "grade-3": {
      "execution": 1
    },
    "4": "std::vector<long> v;\n    if(need <= remaining)\n    {\n        v.push_back(number + need);\n        v.push_back(remaining - need);\n    }\n    else\n    {\n        v.push_back(number + remaining);\n        v.push_back(0);\n    }\n    return v;",
    "grade-4": {
      "execution": 1
    },
    "5": "long t = 0;\n    if (remaining < need - number) {\n        t = remaining;\n    } else {\n        t = need - number;\n    }\n    std::vector<long> a;\n    a.push_back(number + t);\n    a.push_back(remaining - t);\n    return a;",
    "grade-5": {
      "execution": 0
    }
  },
  {
    "intent": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that takes an integer a and returns True \n// if this ingeger is a cube of some integer number.\n// Note: you may assume the input is always valid.\n// Examples:\n// iscube(1) ==> True\n// iscube(2) ==> False\n// iscube(-1) ==> True\n// iscube(64) ==> True\n// iscube(0) ==> True\n// iscube(180) ==> False\nbool iscube(long a) {\n",
    "task_id": "77",
    "prompt": "/*\nWrite a function that takes an integer a and returns true \nif this ingeger is a cube of some integer number.\nNote: you may assume the input is always valid.\nExamples:\niscube(1) ==> true\niscube(2) ==> false\niscube(-1) ==> true\niscube(64) ==> true\niscube(0) ==> true\niscube(180) ==> false\n*/\n#include<stdio.h>\n#include<math.h>\nusing namespace std;\nbool iscuber(int a){\n",
    "simplified_intent": "Write a function that takes an integer a and returns True if this ingeger is a cube of some integer number. Note: you may assume the input is always valid.",
    "snippet": [
      "    for (int i=0;i*i*i<=abs(a);i++)\n        if (i*i*i==abs(a)) return true;\n    return false;\n}\n"
    ],
    "sample_from": {
      "0": "incoder",
      "1": "incoder",
      "2": "incoder",
      "3": "codex",
      "4": "codex",
      "5": "codex"
    },
    "0": "int b = 0;\n    int c = 0;\n    while (b < a) {\n        c += b;\n        b++;\n    }\n    c -= b;\n    return c >= a / a / a / a / a;",
    "grade-0": {
      "execution": 0
    },
    "1": "long i=2;\n    while (i<a) {\n        if(a%i==0)\n            return false;\n        i++;\n    }\n    return true;",
    "grade-1": {
      "execution": 0
    },
    "2": "if(a==0)\n        return true;\n    if(a==1)\n        return true;\n    \n    int i,j;\n    long long int sum=0;\n    for(i=a;i>0;i=i/3)\n        for(j=i;j>=3;j-=3)\n            sum+=j*j*j;\n    if(sum==a*a*a)\n        return true;\n    else\n        return false;",
    "grade-2": {
      "execution": 0
    },
    "3": "return (abs(a)== pow(int(pow(abs(a), 1.0/3.0)), 3));",
    "grade-3": {
      "execution": 0
    },
    "4": "if (a == 0 || a == 1 || a == -1) {\n\t\treturn true;\n\t}\n\telse {\n\t\tif (a > 0) {\n\t\t\tlong i = 1;\n\t\t\twhile (i*i*i < a) {\n\t\t\t\ti++;\n\t\t\t}\n\t\t\tif (i*i*i == a) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tlong i = -1;\n\t\t\twhile (i*i*i > a) {\n\t\t\t\ti--;\n\t\t\t}\n\t\t\tif (i*i*i == a) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}",
    "grade-4": {
      "execution": 1
    },
    "5": "return round(cbrt(a)) * round(cbrt(a)) * round(cbrt(a)) == a;",
    "grade-5": {
      "execution": 1
    }
  },
  {
    "intent": "#include<assert.h>\n#include<bits/stdc++.h>\nunion Union_long_float_std_string{\n    long f0;\n    float f1;\n    std::string f2;    Union_long_float_std_string(long _f0) : f0(_f0) {}\n    Union_long_float_std_string(float _f1) : f1(_f1) {}\n    Union_long_float_std_string(std::string _f2) : f2(_f2) {}\n    ~Union_long_float_std_string() {}\n    bool operator==(Union_long_float_std_string u2) {\n        return f0 == u2.f0 || f1 == u2.f1 || f2 == u2.f2 ;\n    }\n};\nunion Union_long_float_std_string_{}{\n    long f0;\n    float f1;\n    std::string f2;\n    {} f3;    Union_long_float_std_string_{}(long _f0) : f0(_f0) {}\n    Union_long_float_std_string_{}(float _f1) : f1(_f1) {}\n    Union_long_float_std_string_{}(std::string _f2) : f2(_f2) {}\n    Union_long_float_std_string_{}({} _f3) : f3(_f3) {}\n    ~Union_long_float_std_string_{}() {}\n    bool operator==(Union_long_float_std_string_{} u2) {\n        return f0 == u2.f0 || f1 == u2.f1 || f2 == u2.f2 || f3 == u2.f3 ;\n    }\n};\n// Create a function that takes integers, floats, or strings representing\n// real numbers, and returns the larger variable in its given variable type.\n// Return None if the values are equal.\n// Note: If a real number is represented as a string, the floating point might be . or ,\n// compare_one(1, 2.5) \u279e 2.5\n// compare_one(1, \"2,3\") \u279e \"2,3\"\n// compare_one(\"5,1\", \"6\") \u279e \"6\"\n// compare_one(\"1\", 1) \u279e None\nUnion_long_float_std_string_{} compare_one(Union_long_float_std_string a, Union_long_float_std_string b) {\n",
    "task_id": "137",
    "prompt": "/*\nCreate a function that takes integers, floats, or strings representing\nreal numbers, and returns the larger variable in its given variable type.\nReturn \"None\" if the values are equal.\nNote: If a real number is represented as a string, the floating point might be . or ,\n\ncompare_one(1, 2.5) \u279e 2.5\ncompare_one(1, \"2,3\") \u279e \"2,3\"\ncompare_one(\"5,1\", \"6\") \u279e \"6\"\ncompare_one(\"1\", 1) \u279e \"None\"\n*/\n#include<stdio.h>\n#include<string>\n#include<algorithm>\n#include<boost/any.hpp>\nusing namespace std;\nboost::any compare_one(boost::any a,boost::any b){\n",
    "simplified_intent": "Create a function that takes integers, floats, or strings representing real numbers, and returns the larger variable in its given variable type. Return None if the values are equal. Note: If a real number is represented as a string, the floating point might be . or ,",
    "snippet": [
      "    double  numa,numb;\n    boost::any out;\n   \n    if (a.type()==typeid(string))\n    {\n        string s;\n        s=boost::any_cast<string>(a);\n        if (find(s.begin(),s.end(),',')!=s.end())\n            for (int i=0;i<s.length();i++)\n                if (s[i]==',') s=s.substr(0,i)+'.'+s.substr(i+1);\n        numa=atof(s.c_str());\n        \n    }\n    else \n    {\n        if (a.type()==typeid(int)) numa=boost::any_cast<int>(a);\n        if (a.type()==typeid(double)) numa=boost::any_cast<double>(a);\n    }\n    if (b.type()==typeid(string))\n    {\n        string s;\n        s=boost::any_cast<string>(b);\n        if (find(s.begin(),s.end(),',')!=s.end())\n            for (int i=0;i<s.length();i++)\n                if (s[i]==',') s=s.substr(0,i)+'.'+s.substr(i+1);\n        numb=atof(s.c_str());\n    }\n    else \n    {\n        if (b.type()==typeid(int)) numb=boost::any_cast<int>(b);\n        if (b.type()==typeid(double)) numb=boost::any_cast<double>(b);\n    }\n\n    if (numa==numb) return string(\"None\");\n    if (numa<numb) return b;\n    if (numa>numb) return a;\n}\n"
    ],
    "sample_from": {
      "0": "incoder",
      "1": "incoder",
      "2": "incoder",
      "3": "codex",
      "4": "codex",
      "5": "codex"
    },
    "0": "if (a.f0 != b.f0) return a.f0;\n    if (a.f1 != b.f1) return a.f1;\n    if (a.f2 != b.f2) return a.f2;\n    if (a.f3 != b.f3) return a.f3;\n    return Union_long_float_std_string_{};",
    "grade-0": {
      "execution": 0
    },
    "1": "if (a == b) return a;\n    union Union_long_float_std_string_{}{\n        long f0;\n        float f1;\n        std::string f2;\n    } ua1, ub1;\n    if (a.f2 == b.f2) {\n        ua1.f2 = a.f2;\n        ub1.f2 = b.f2;\n    } else if (a.f1 == b.f1) {\n        ua1.f1 = a.f1;\n        ub1.f1 = b.f1;\n    } else if (a.f0 == b.f0) {\n        ua1.f0 = a.f0;\n        ub1.f0 = b.f0;\n    } else {\n        ua1.f0 = a.f0;\n        ub1.f0 = b.f0;\n    }\n    if (ua1.f0 == ua1.f1 && ub1.f0 == ub1.f1 && ua1.f2 == ub1.f2) return ua1;\n    return ua1.f2 > ub1.f2 ? ua1 : ub1;",
    "grade-1": {
      "execution": 0
    },
    "2": "if (a == b) return a;\n    if (a < b) return b;\n    if (a > b) return a;\n    return None;",
    "grade-2": {
      "execution": 0
    },
    "3": "return Union_long_float_std_string_{}((a.f0 > b.f0) ? a.f0 : ((a.f1 > b.f1) ? a.f1 : ((a.f2 > b.f2) ? a.f2 : {} )));",
    "grade-3": {
      "execution": 0
    },
    "4": "Union_long_float_std_string_{} result;\n    if (a.f0 == b.f0) {\n        result = Union_long_float_std_string_{}(NULL);\n    } else if (a.f0 > b.f0) {\n        result = Union_long_float_std_string_{}(a.f0);\n    } else {\n        result = Union_long_float_std_string_{}(b.f0);\n    }\n    if (a.f1 == b.f1) {\n        result = Union_long_float_std_string_{}(NULL);\n    } else if (a.f1 > b.f1) {\n        result = Union_long_float_std_string_{}(a.f1);\n    } else {\n        result = Union_long_float_std_string_{}(b.f1);\n    }\n    if (a.f2 == b.f2) {\n        result = Union_long_float_std_string_{}(NULL);\n    } else if (a.f2 > b.f2) {\n        result = Union_long_float_std_string_{}(a.f2);\n    } else {\n        result = Union_long_float_std_string_{}(b.f2);\n    }\n    return result;",
    "grade-4": {
      "execution": 0
    },
    "5": "if (a == b) {\n        return {};\n    }\n    else if (a.f0 > b.f0) {\n        return Union_long_float_std_string_{}(a.f0);\n    }\n    else if (a.f1 > b.f1) {\n        return Union_long_float_std_string_{}(a.f1);\n    }\n    else if (a.f2 > b.f2) {\n        return Union_long_float_std_string_{}(a.f2);\n    }\n    else if (b.f0 > a.f0) {\n        return Union_long_float_std_string_{}(b.f0);\n    }\n    else if (b.f1 > a.f1) {\n        return Union_long_float_std_string_{}(b.f1);\n    }\n    else if (b.f2 > a.f2) {\n        return Union_long_float_std_string_{}(b.f2);\n    }",
    "grade-5": {
      "execution": 0
    }
  },
  {
    "intent": "#include<assert.h>\n#include<bits/stdc++.h>\n// Given the lengths of the three sides of a triangle. Return the area of\n// the triangle rounded to 2 decimal points if the three sides form a valid triangle. \n// Otherwise return -1\n// Three sides make a valid triangle when the sum of any two sides is greater \n// than the third side.\n// Example:\n// triangle_area(3, 4, 5) == 6.00\n// triangle_area(1, 2, 10) == -1\nfloat triangle_area(long a, long b, long c) {\n",
    "task_id": "71",
    "prompt": "/*\nGiven the lengths of the three sides of a triangle. Return the area of\nthe triangle rounded to 2 decimal points if the three sides form a valid triangle. \nOtherwise return -1\nThree sides make a valid triangle when the sum of any two sides is greater \nthan the third side.\nExample:\ntriangle_area(3, 4, 5) == 6.00\ntriangle_area(1, 2, 10) == -1\n*/\n#include<stdio.h>\n#include<math.h>\nusing namespace std;\nfloat triangle_area(float a,float b,float c){\n",
    "simplified_intent": "Given the lengths of the three sides of a triangle. Return the area of the triangle rounded to 2 decimal points if the three sides form a valid triangle. Otherwise return -1 Three sides make a valid triangle when the sum of any two sides is greater than the third side.",
    "snippet": [
      "    if (a+b<=c or a+c<=b or b+c<=a) return -1;\n    float h=(a+b+c)/2;\n    float area;\n    area=pow(h*(h-a)*(h-b)*(h-c),0.5);\n    return area;\n}\n"
    ],
    "sample_from": {
      "0": "incoder",
      "1": "incoder",
      "2": "incoder",
      "3": "codex",
      "4": "codex",
      "5": "codex"
    },
    "0": "// Write your code here\n    if((b+c)>=a && (b+c)>=c && (b+a)>=a && (b+a)>=c){\n        return (b+c)/2;\n    }\n    else {\n        return -1;\n    }",
    "grade-0": {
      "execution": 0
    },
    "1": "if(a<=0 || b<=0 || c<=0) return -1;\n    long s = a+b+c;\n    if(s<=3) return 0;\n    else if(a+b<c) return -1;\n    else return s/2;",
    "grade-1": {
      "execution": 0
    },
    "2": "if (a == 0 || b == 0 || c == 0 || a > b + c || b > a + c || c > a + b)\n        return -1;\n    return a * b * c / (a + b + c);",
    "grade-2": {
      "execution": 0
    },
    "3": "// Your code here\n  if(a+b>c && a+c>b && b+c>a)\n  {\n    float s = (a+b+c)/2.0;\n    float area = sqrt(s*(s-a)*(s-b)*(s-c));\n    return roundf(area * 100) / 100;\n  }\n  else\n  {\n    return -1;\n  }",
    "grade-3": {
      "execution": 0
    },
    "4": "float s = (a + b + c) / 2.0;\n    float area = sqrt(s * (s - a) * (s - b) * (s - c));\n    if (area > 0)\n        return roundf(area * 100) / 100;\n    else\n        return -1;",
    "grade-4": {
      "execution": 0
    },
    "5": "float s = (a + b + c) / 2.0;\n    if(s-a > 0 && s-b > 0 && s-c > 0) {\n        return sqrt(s*(s-a)*(s-b)*(s-c));\n    }\n    return -1;",
    "grade-5": {
      "execution": 0
    }
  },
  {
    "intent": "#include<assert.h>\n#include<bits/stdc++.h>\n// Given an array arr of integers and a positive integer k, return a sorted list \n// of length k with the maximum k numbers in arr.\n// Example 1:\n// Input: arr = [-3, -4, 5], k = 3\n// Output: [-4, -3, 5]\n// Example 2:\n// Input: arr = [4, -4, 4], k = 2\n// Output: [4, 4]\n// Example 3:\n// Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n// Output: [2]\n// Note:\n// 1. The length of the array will be in the range of [1, 1000].\n// 2. The elements in the array will be in the range of [-1000, 1000].\n// 3. 0 <= k <= len(arr)\nstd::vector<long> maximum(std::vector<long> arr, long k) {\n",
    "task_id": "120",
    "prompt": "/*\nGiven a vector arr of integers and a positive integer k, return a sorted vector \nof length k with the maximum k numbers in arr.\n\nExample 1:\n\n    Input: arr = {-3, -4, 5}, k = 3\n    Output: {-4, -3, 5}\n\nExample 2:\n\n    Input: arr = {4, -4, 4}, k = 2\n    Output: {4, 4}\n\nExample 3:\n\n    Input: arr = {-3, 2, 1, 2, -1, -2, 1}, k = 1\n    Output: {2}\n\nNote:\n    1. The length of the vector will be in the range of {1, 1000}.\n    2. The elements in the vector will be in the range of {-1000, 1000}.\n    3. 0 <= k <= len(arr)\n*/\n#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nvector<int> maximum(vector<int> arr,int k){\n",
    "simplified_intent": "Given an array arr of integers and a positive integer k, return a sorted list of length k with the maximum k numbers in arr. Note: 1. The length of the array will be in the range of [1, 1000]. 2. The elements in the array will be in the range of [-1000, 1000]. 3. 0 <= k <= len(arr)",
    "snippet": [
      "    sort(arr.begin(),arr.end());\n    vector<int> out(arr.end()-k,arr.end());\n    return out;\n}\n"
    ],
    "sample_from": {
      "0": "incoder",
      "1": "incoder",
      "2": "incoder",
      "3": "codex",
      "4": "codex",
      "5": "codex"
    },
    "0": "// Write your code here\n    std::vector<long> v; \n    std::sort(arr.begin(), arr.end()); \n    std::vector<long> ans;\n    long n = arr.size();\n    long cnt = 0;\n    for(int i=0;i<k;i++)\n    {\n        for(int j=0;j<n-k;j++)\n        {\n            if(arr[j] > arr[j+1])\n            {\n                std::swap(arr[j], arr[j+1]);\n            }\n        }\n        ans.push_back(arr[j]);\n        cnt++;\n    }\n    return ans;",
    "grade-0": {
      "execution": 0
    },
    "1": "if(arr.size() == 0 || k == 0) return {};\n    std::vector<long> res;\n    if(arr.size() <= k) res.reserve(arr.size());\n    for(long i = 1; i < arr.size(); i++) {\n        if(arr[i-1] > arr[i])\n            std::swap(arr[i-1], arr[i]);\n        if(res.size() >= k) break;\n    }\n    for(long i = 0; i < k; i++) res.push_back(arr[i]);\n    return res;",
    "grade-1": {
      "execution": 0
    },
    "2": "long long ans = 0;\n    long long temp = 0;\n    // This for loop will loop until we get k number of elements in arr\n    for (long long i = 0; i < k; i++) {\n        // This if condition will loop until we get a negative or positive number\n        if (arr[i] > arr[i+1]) {\n            temp = 0;\n        } else {\n            temp = arr[i+1];\n        }\n        // This if condition will loop until we get a negative or positive number\n        if (temp > temp) {\n            temp = 0;\n        } else {\n            temp = temp;\n        }\n        // This if condition will loop until we get a negative or positive number\n        if (arr[i] > arr[i+2]) {\n            temp = 0;\n        } else {\n            temp = arr[i+2];\n        }\n        // This if condition will loop until we get a negative or positive number\n        if (temp > temp) {\n            temp = 0;\n        } else {\n            temp = temp;\n        }\n        // This if condition will loop until we get a negative or positive number\n        if (arr[i] > arr[i+3]) {\n            temp = 0;\n        } else {\n            temp = arr[i+3];\n        }\n        // This if condition will loop until we get a negative or positive number\n        if (temp > temp) {\n            temp = 0;\n        } else {\n            temp = temp;\n        }\n        // This if condition will loop until we get a negative or positive number\n        if (arr[i] > arr[i+4]) {\n            temp = 0;\n        } else {\n            temp = arr[i+4];\n        }\n        // This if condition will loop until we get a negative or positive number\n        if (temp > temp) {\n            temp = 0;\n        } else {\n            temp = temp;\n        }\n        // This if condition will loop until we get a negative or positive number\n        if (arr[i] > arr[i+5]) {\n            temp = 0;\n        } else {\n            temp = arr[i+5];\n        }\n        // This if condition will loop until we get a negative or positive number\n        if (temp > temp) {\n            temp = 0;\n        } else {\n            temp = temp;\n        }\n        // This if condition will loop until we get a negative or positive number\n        if (arr[i] > arr[i+6]) {\n            temp = 0;\n        } else {\n            temp = arr[i+6];\n        }\n        // This if condition will loop until we get a negative or positive number\n        if (temp > temp) {\n            temp = 0;\n        } else {\n            temp = temp;\n        }\n        // This if condition will loop until we get a negative or positive number\n        if (arr[i] > arr[i+7]) {\n            temp = 0;\n        } else {\n            temp = arr[i+7];\n        }\n        // This if condition will loop until we get a negative or positive number\n        if (temp > temp) {\n            temp = 0;\n        } else {\n            temp = temp;\n        }",
    "grade-2": {
      "execution": 0
    },
    "3": "if (arr.size() == 0) return {};\n    if (arr.size() == 1) return arr;\n    std::sort(arr.begin(), arr.end());\n    std::vector<long> res(arr.end() - k, arr.end());\n    return res;",
    "grade-3": {
      "execution": 1
    },
    "4": "std::priority_queue<long> heap;\n  for (auto a : arr) {\n    heap.push(a);\n    if (heap.size() > k) {\n      heap.pop();\n    }\n  }\n  std::vector<long> result;\n  while (!heap.empty()) {\n    result.push_back(heap.top());\n    heap.pop();\n  }\n  std::reverse(result.begin(), result.end());\n  return result;",
    "grade-4": {
      "execution": 0
    },
    "5": "std::priority_queue<long> pq;\n    for (long x : arr) {\n        pq.push(x);\n        if (pq.size() > k) pq.pop();\n    }\n    std::vector<long> ans;\n    while (!pq.empty()) {\n        ans.push_back(pq.top());\n        pq.pop();\n    }\n    return ans;",
    "grade-5": {
      "execution": 0
    }
  },
  {
    "intent": "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of \"<\" and \">\".\n// return True if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"<\")\n// False\n// >>> correct_bracketing(\"<>\")\n// True\n// >>> correct_bracketing(\"<<><>>\")\n// True\n// >>> correct_bracketing(\"><<>\")\n// False\nbool correct_bracketing(std::string brackets) {\n",
    "task_id": "56",
    "prompt": "/*\nbrackets is a string of '<' and '>'.\nreturn true if every opening bracket has a corresponding closing bracket.\n\n>>> correct_bracketing(\"<\")\nfalse\n>>> correct_bracketing(\"<>\")\ntrue\n>>> correct_bracketing(\"<<><>>\")\ntrue\n>>> correct_bracketing(\"><<>\")\nfalse\n*/\n#include<stdio.h>\n#include<string>\nusing namespace std;\nbool correct_bracketing(string brackets){\n",
    "simplified_intent": "brackets is a string of \"<\" and \">\". return True if every opening bracket has a corresponding closing bracket.",
    "snippet": [
      "    int level=0;\n    for (int i=0;i<brackets.length();i++)\n    {\n        if (brackets[i]=='<') level+=1;\n        if (brackets[i]=='>') level-=1;\n        if (level<0) return false;\n    }\n    if (level!=0) return false;\n    return true;\n}\n"
    ],
    "sample_from": {
      "0": "incoder",
      "1": "incoder",
      "2": "incoder",
      "3": "codex",
      "4": "codex",
      "5": "codex"
    },
    "0": "size_t count = 0;\n    for (size_t i=0; i<brackets.size(); i++) {\n        if (brackets[i] == '<') {\n            count++;\n        }\n        if (brackets[i] == '>') {\n            count--;\n        }\n    }\n    if (count == 0) {\n        return false;\n    }\n    return true;",
    "grade-0": {
      "execution": 0
    },
    "1": "std::string open_bracket = \"<\";\n  std::string close_bracket = \">\";\n  std::string result = \"True\";\n  for (int i = 0; i < brackets.length(); ++i) {\n    if (brackets[i] == open_bracket) {\n      if (brackets[i+1] == close_bracket) {\n        result = \"False\";\n        break;\n      }\n    }\n  }\n  std::cout << result << std::endl;\n  return result == \"True\";",
    "grade-1": {
      "execution": 0
    },
    "2": "// for each \"<\", we check if there is a corresponding \">\".\n    // for each \">\", we check if there is a corresponding \"<\".\n    // for each pair of \"<\", we check that the \"->\" is not followed by \"->\".\n    // for each pair of \">\", we check that the \"->\" is not preceeded by \"->\".\n    for (int i = 0; i < brackets.length(); i++) {\n        if (brackets[i] != '<') return false;\n        if (brackets[i + 1] != '>') return false;\n        if (brackets[i + 2] != '<') return false;\n        if (brackets[i + 3] != '>') return false;\n        if (brackets[i + 4] != '<') return false;\n        if (brackets[i + 5] != '>') return false;\n    }\n    return true;",
    "grade-2": {
      "execution": 0
    },
    "3": "// put your code here:\n  int count = 0;\n  for (int i = 0; i < brackets.size(); i++) {\n    if (brackets[i] == '<') {\n      count++;\n    } else {\n      count--;\n    }\n    if (count < 0) {\n      return false;\n    }\n  }\n  if (count == 0) {\n    return true;\n  } else {\n    return false;\n  }",
    "grade-3": {
      "execution": 1
    },
    "4": "// Write your code here.\n    int count=0;\n    for(auto i:brackets){\n        if(i=='<'){\n            count++;\n        }\n        else{\n            count--;\n        }\n        if(count<0){\n            return false;\n        }\n    }\n    if(count==0){\n        return true;\n    }\n    else{\n        return false;\n    }",
    "grade-4": {
      "execution": 1
    },
    "5": "// YOUR CODE HERE\n  std::stack<char> s;\n  char c;\n  for(int i=0;i<brackets.length();i++){\n      if(brackets[i]=='<'){\n          s.push(brackets[i]);\n      }\n      else{\n          if(s.empty()){\n              return false;\n          }\n          else{\n              s.pop();\n          }\n      }\n  }\n  if(s.empty()){\n      return true;\n  }\n  else{\n      return false;\n  }\n  //return false;",
    "grade-5": {
      "execution": 1
    }
  },
  {
    "intent": "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\", 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nstd::vector<std::string> select_words(std::string s, long n) {\n",
    "task_id": "117",
    "prompt": "/*\nGiven a string s and a natural number n, you have been tasked to implement \na function that returns a vector of all words from string s that contain exactly \nn consonants, in order these words appear in the string s.\nIf the string s is empty then the function should return an empty vector.\nNote: you may assume the input string contains only letters and spaces.\nExamples:\nselect_words(\"Mary had a little lamb\", 4) ==> {\"little\"}\nselect_words(\"Mary had a little lamb\", 3) ==> {\"Mary\", \"lamb\"}\nselect_words('simple white space\", 2) ==> {}\nselect_words(\"Hello world\", 4) ==> {\"world\"}\nselect_words(\"Uncle sam\", 3) ==> {\"Uncle\"}\n*/\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\nvector<string> select_words(string s,int n){\n",
    "simplified_intent": "Given a string s and a natural number n, you have been tasked to implement a function that returns a list of all words from string s that contain exactly n consonants, in order these words appear in the string s. If the string s is empty then the function should return an empty list. Note: you may assume the input string contains only letters and spaces.",
    "snippet": [
      "    string vowels=\"aeiouAEIOU\";\n    string current=\"\";\n    vector<string> out={};\n    int numc=0;\n    s=s+' ';\n    for (int i=0;i<s.length();i++)\n        if (s[i]==' ')\n        {\n            if (numc==n) out.push_back(current);\n            current=\"\";\n            numc=0;\n        }\n        else\n        {\n            current=current+s[i];\n            if ((s[i]>=65 and s[i]<=90) or (s[i]>=97 and s[i]<=122))\n            if (find(vowels.begin(),vowels.end(),s[i])==vowels.end())\n                numc+=1;\n        }\n    return out;\n}\n"
    ],
    "sample_from": {
      "0": "incoder",
      "1": "incoder",
      "2": "incoder",
      "3": "codex",
      "4": "codex",
      "5": "codex"
    },
    "0": "std::vector<std::string> res;\n    for (size_t i = 0; i < s.size(); i++) {\n        if (s.at(i) == ' ' || s.at(i) == '-') {\n            if (s.at(i) == ' ' && s.at(i - 1) != ' ') {\n                res.push_back(s.substr(0, i));\n            } else {\n                res.push_back(s.substr(i));\n            }\n        }\n    }\n    return res;",
    "grade-0": {
      "execution": 0
    },
    "1": "std::vector<std::string> res;\n    // your code goes here\n    res.push_back(\"\");\n    std::string temp;\n    int counter = 0;\n    long counter2 = 0;\n    for (int i = 0; i < s.size(); i++) {\n        if (s[i] == ' ') {\n            counter++;\n        }\n        if (s[i] == 'a') {\n            counter2++;\n        }\n    }\n    for (int i = 0; i < s.size(); i++) {\n        if (s[i] == ' ') {\n            counter--;\n        }\n        if (s[i] == 'a') {\n            counter2--;\n        }\n    }\n    while (counter > 0 || counter2 > 0) {\n        if (counter > 0 && counter2 == 0) {\n            temp = temp + \" \";\n        }\n        if (counter2 == 0 && counter > 0) {\n            temp = temp + \" \";\n        }\n        if (counter == 0 && counter2 > 0) {\n            temp = temp + \" \";\n        }\n        if (counter == 0 && counter < counter2) {\n            res.push_back(temp);\n            counter = 0;\n        }\n        if (counter > 0 && counter2 == counter) {\n            res.push_back(temp);\n            counter = 0;\n        }\n        if (counter2 == 0 && counter < counter2) {\n            res.push_back(temp);\n            counter2 = 0;\n        }\n        if (counter > 0 && counter2 < counter) {\n            res.push_back(temp);\n            counter2 = 0;\n        }\n        if (counter2 < 0 && counter < counter2) {\n            res.push_back(temp);\n            counter2 = 0;\n        }\n        if (counter2 == 0 && counter2 < counter) {\n            res.push_back(temp);\n            counter2 = 0;\n        }\n        if (counter > 0 && counter2 < counter) {\n            res.push_back(temp);\n            counter2 = 0;\n        }\n        if (counter2 < 0 && counter < counter2) {\n            res.push_back(temp);\n            counter2 = 0;\n        }\n    }\n    return res;",
    "grade-1": {
      "execution": 0
    },
    "2": "std::vector<std::string> v;\n    // your code goes here",
    "grade-2": {
      "execution": 0
    },
    "3": "std::vector<std::string> vs;\n    std::stringstream ss(s);\n    std::string word;\n    while(ss >> word) {\n        if(std::count_if(word.begin(), word.end(), ::isalpha) == n) {\n            vs.push_back(word);\n        }\n    }\n    return vs;",
    "grade-3": {
      "execution": 0
    },
    "4": "vector<string> words;\n    stringstream ss(s);\n    string temp;\n    while(ss >> temp){\n        long count=0;\n        for(int i=0;i<temp.length();i++){\n            if(temp[i]=='a'||temp[i]=='e'||temp[i]=='i'||temp[i]=='o'||temp[i]=='u'){\n                count++;\n            }\n        }\n        if(temp.length()-count==n){\n            words.push_back(temp);\n        }\n    }\n    return words;",
    "grade-4": {
      "execution": 0
    },
    "5": "std::vector<std::string> words{};\n    std::string current_word{};\n    long cons_count{};\n    for (int i{}; i < s.size(); i++) {\n        if (s[i] == ' ') {\n            if (cons_count == n) {\n                words.push_back(current_word);\n            }\n            current_word = \"\";\n            cons_count = 0;\n        } else {\n            current_word += s[i];\n            if (isalpha(s[i])) {\n                if (!strchr(\"aeiouAEIOU\", s[i])) {\n                    cons_count++;\n                }\n            }\n        }\n    }\n    if (cons_count == n) {\n        words.push_back(current_word);\n    }\n    return words;",
    "grade-5": {
      "execution": 1
    }
  },
  {
    "intent": "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to write a function that receives \n// a hexadecimal number as a string and counts the number of hexadecimal \n// digits that are primes (prime number, or a prime, is a natural number \n// greater than 1 that is not a product of two smaller natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal 11), D (=decimal 13).\n// Note: you may assume the input is always correct or empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n// For num = \"AB\" the output should be 1.\n// For num = \"1077E\" the output should be 2.\n// For num = \"ABED1A33\" the output should be 4.\n// For num = \"123456789ABCDEF0\" the output should be 6.\n// For num = \"2020\" the output should be 2.\nlong hex_key(std::string num) {\n",
    "task_id": "78",
    "prompt": "/*\nYou have been tasked to write a function that receives \na hexadecimal number as a string and counts the number of hexadecimal \ndigits that are primes (prime number, or a prime, is a natural number \ngreater than 1 that is not a product of two smaller natural numbers).\nHexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\nPrime numbers are 2, 3, 5, 7, 11, 13, 17,...\nSo you have to determine a number of the following digits: 2, 3, 5, 7, \nB (=decimal 11), D (=decimal 13).\nNote: you may assume the input is always correct or empty string, \nand symbols A,B,C,D,E,F are always uppercase.\nExamples:\nFor num = \"AB\" the output should be 1.\nFor num = \"1077E\" the output should be 2.\nFor num = \"ABED1A33\" the output should be 4.\nFor num = \"123456789ABCDEF0\" the output should be 6.\nFor num = \"2020\" the output should be 2.\n*/\n#include<stdio.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\nint hex_key(string num){\n",
    "simplified_intent": "You have been tasked to write a function that receives a hexadecimal number as a string and counts the number of hexadecimal digits that are primes (prime number, or a prime, is a natural number greater than 1 that is not a product of two smaller natural numbers). Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F. Prime numbers are 2, 3, 5, 7, 11, 13, 17,... So you have to determine a number of the following digits: 2, 3, 5, 7, B (=decimal 11), D (=decimal 13). Note: you may assume the input is always correct or empty string, and symbols A,B,C,D,E,F are always uppercase.",
    "snippet": [
      "    string key=\"2357BD\";\n    int out=0;\n    for (int i=0;i<num.length();i++)\n    if (find(key.begin(),key.end(),num[i])!=key.end()) out+=1;\n    return out;\n}\n"
    ],
    "sample_from": {
      "0": "incoder",
      "1": "incoder",
      "2": "incoder",
      "3": "codex",
      "4": "codex",
      "5": "codex"
    },
    "0": "if (num.length() == 0) return 0;\n    int base = 10;\n    long key = 0;\n    while (base >= 2) {\n        if (num[base] == 'A') return 0;\n        else if (num[base] == 'B') return 0;\n        else if (num[base] == 'C') return 0;\n        else if (num[base] == 'D') return 0;\n        else if (num[base] == 'E') return 0;\n        else if (num[base] == 'F') return 0;\n        else if (num[base] == '0') break;\n        else if (num[base] == '1') break;\n        else if (num[base] >= '2' && num[base] <= '9') break;\n        base = base / 2;\n    }\n    for (size_t i = 0; i < num.length(); ++i) {\n        if (num[i] == 'A') key = key + 1;\n        else if (num[i] == 'B') key = key + 2;\n        else if (num[i] == 'C') key = key + 3;\n        else if (num[i] == 'D') key = key + 4;\n        else if (num[i] == 'E') key = key + 5;\n        else if (num[i] == 'F') key = key + 6;\n        else if (num[i] == '0') key = key + 7;\n        else if (num[i] == '1') key = key + 8;\n        else if (num[i] == '2') key = key + 9;\n        else if (num[i] == '3') key = key + 10;\n        else if (num[i] == '4') key = key + 11;\n        else if (num[i] == '5') key = key + 12;\n        else if (num[i] == '6') key = key + 13;\n        else if (num[i] == '7') key = key + 14;\n        else if (num[i] == '8') key = key + 15;\n        else if (num[i] == '9') key = key + 16;\n    }\n    return key;",
    "grade-0": {
      "execution": 0
    },
    "1": "if (num.length() == 0)\n        return 0;\n    long ans = 0;\n    long base = 10;\n    long counter = 1;\n    for (int i = 0; i < num.length(); i++) {\n        char c = num.at(i);\n        long lc = c - '0';\n        ans += lc * base;\n        counter = counter * base;\n        base *= 16;\n    }\n    return ans + counter;",
    "grade-1": {
      "execution": 0
    },
    "2": "long ans = 0;\n    long len = 0;\n    while (num.size() != 0) {\n        num = num.substr(0, num.size() - 1);\n        len++;\n    }\n    long an = len + 1;\n    if (an*len == num.size()) {\n        // check if all digits are hexadecimal digits\n        for (int i = 0; i < an; i++) {\n            if ((num[i]<'0') || (num[i]>'9'))\n                ans = 0;\n            else if ((num[i]<'A') || (num[i]>'F'))\n                ans = 0;\n            else if ((num[i]=='0') || (num[i]=='1') || (num[i]=='2') ||\n                     (num[i]=='3') || (num[i]=='4') || (num[i]=='5') ||\n                     (num[i]=='6') || (num[i]=='7') || (num[i]=='8') ||\n                     (num[i]=='9') || (num[i]=='A') || (num[i]=='B') ||\n                     (num[i]=='C') || (num[i]=='D') || (num[i]=='E') ||\n                     (num[i]=='F'))\n                ans = 0;\n        }\n    }\n    return ans;",
    "grade-2": {
      "execution": 0
    },
    "3": "long res = 0;\n\tfor (char c : num) {\n\t\tif (isdigit(c)) {\n\t\t\tres += (long)c - 48;\n\t\t}\n\t\telse if (c >= 'A' && c <= 'F') {\n\t\t\tres += (long)c - 55;\n\t\t}\n\t}\n\treturn res;",
    "grade-3": {
      "execution": 0
    },
    "4": "std::string::iterator it = num.begin();\n    long result = 0;\n    while (it != num.end()) {\n        switch (*it) {\n            case '2': result += 1; break;\n            case '3': result += 1; break;\n            case '5': result += 1; break;\n            case '7': result += 1; break;\n            case 'B': result += 1; break;\n            case 'D': result += 1; break;\n            default: break;\n        }\n        it++;\n    }\n    return result;",
    "grade-4": {
      "execution": 1
    },
    "5": "long total = 0;\n  long count = 0;\n  for (int i = 0; i < num.length(); i++) {\n    if (num[i] == '2' || num[i] == '3' || num[i] == '5' || num[i] == '7' ||\n        num[i] == 'B' || num[i] == 'D') {\n      count++;\n    }\n  }\n  return count;",
    "grade-5": {
      "execution": 1
    }
  },
  {
    "intent": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string s.\n// Your task is to check if the string is happy or not.\n// A string is happy if its length is at least 3 and every 3 consecutive letters are distinct\n// For example:\n// is_happy(a) => False\n// is_happy(aa) => False\n// is_happy(abcd) => True\n// is_happy(aabb) => False\n// is_happy(adb) => True\n// is_happy(xyy) => False\nbool is_happy(std::string s) {\n",
    "task_id": "80",
    "prompt": "/*\nYou are given a string s.\nYour task is to check if the string is happy or not.\nA string is happy if its length is at least 3 and every 3 consecutive letters are distinct\nFor example:\nis_happy(\"a\") => false\nis_happy(\"aa\") => false\nis_happy(\"abcd\") => true\nis_happy(\"aabb\") => false\nis_happy(\"adb\") => true\nis_happy(\"xyy\") => false\n*/\n#include<stdio.h>\n#include<string>\nusing namespace std;\nbool is_happy(string s){\n",
    "simplified_intent": "You are given a string s. Your task is to check if the string is happy or not. A string is happy if its length is at least 3 and every 3 consecutive letters are distinct",
    "snippet": [
      "    if (s.length()<3) return false;\n    for (int i=2;i<s.length();i++)\n    if (s[i]==s[i-1] or s[i]==s[i-2]) return false;\n    return true;\n}\n"
    ],
    "sample_from": {
      "0": "incoder",
      "1": "incoder",
      "2": "incoder",
      "3": "codex",
      "4": "codex",
      "5": "codex"
    },
    "0": "// your code here\n  int n = s.length();\n  bool ans = n >= 3 && n == 0 || (n == 1 && s[0] == s[0]);\n  for (int i = 0; i < n - 1; i++) {\n    for (int j = 0; j < n - i - 1; j++) {\n      assert(s[i] == s[j]);\n    }\n  }\n  return ans;",
    "grade-0": {
      "execution": 0
    },
    "1": "int n = s.size();\n  if (n < 3) return false; // Empty string is a happy string\n  for (int i = 0; i < n - 3; i++)\n  {\n    // Check only first 3 characters\n    if (s[i] != s[i + 1] && s[i] != s[i + 2] && s[i] != s[i + 3])\n      return false;\n  }\n  return true;",
    "grade-1": {
      "execution": 0
    },
    "2": "unordered_set<char> hash;\n    for (auto c : s) {\n        hash.insert(c);\n    }\n    return s.size() >= 3 && s.size() <= s.size() + 3 && hash.size() >= s.size() / 3 && hash.size() <= s.size() / 3;",
    "grade-2": {
      "execution": 0
    },
    "3": "// your code here\n    if(s.length()<3)\n        return false;\n    char c1=s[0];\n    char c2=s[1];\n    char c3=s[2];\n    for(int i=3;i<s.length();i++){\n        if(c1==c2 || c2==c3 || c1==c3)\n            return false;\n        c1=c2;\n        c2=c3;\n        c3=s[i];\n    }\n    return true;",
    "grade-3": {
      "execution": 0
    },
    "4": "if(s.length()<3) return false;\n    bool flag = true;\n    for(int i=0;i<s.length()-3;i++){\n        flag = true;\n        for(int j=i+1;j<i+3;j++){\n            if(s[i]==s[j]) {\n                flag = false;\n                break;\n            }\n        }\n        if(!flag) break;\n    }\n    return flag;",
    "grade-4": {
      "execution": 0
    },
    "5": "std::cout << s << std::endl;\n    if (s.length() < 3) {\n        return false;\n    } else {\n        for (int i = 0; i < s.length() - 2; i++) {\n            if (s[i] == s[i + 1] && s[i] == s[i + 2]) {\n                return false;\n            }\n        }\n        return true;\n    }",
    "grade-5": {
      "execution": 0
    }
  },
  {
    "intent": "#include<assert.h>\n#include<bits/stdc++.h>\n// A simple program which should return the value of x if n is \n// a prime number and should return the value of y otherwise.\n// Examples:\n// for x_or_y(7, 34, 12) == 34\n// for x_or_y(15, 8, 5) == 5\nlong x_or_y(long n, long x, long y) {\n",
    "task_id": "150",
    "prompt": "/*\nA simple program which should return the value of x if n is \na prime number and should return the value of y otherwise.\n\nExamples:\nfor x_or_y(7, 34, 12) == 34\nfor x_or_y(15, 8, 5) == 5\n\n*/\n#include<stdio.h>\nusing namespace std;\nint x_or_y(int n,int x,int y){\n",
    "simplified_intent": "A simple program which should return the value of x if n is a prime number and should return the value of y otherwise.",
    "snippet": [
      "    bool isp=true;\n    if (n<2) isp=false;\n    for (int i=2;i*i<=n;i++)\n    if (n%i==0) isp=false;\n    if (isp) return x;\n    return y;\n}\n"
    ],
    "sample_from": {
      "0": "incoder",
      "1": "incoder",
      "2": "incoder",
      "3": "codex",
      "4": "codex",
      "5": "codex"
    },
    "0": "int i;\n    long ans = x;\n    if (n%2 == 0) {\n        for(i = 3; i <= (n / 2); i += 2)\n        {\n            if (n % i == 0)\n            {\n                ans = y;\n                break;\n            }\n        }\n    }\n    else\n    {\n        for(i = 3; i <= (n / 2); i += 2)\n        {\n            if (n % (i + 1) == 0)\n            {\n                ans = y;\n                break;\n            }\n        }\n    }\n    return ans;",
    "grade-0": {
      "execution": 0
    },
    "1": "// Complete this function\n    if (n == 2) return x;\n    if (n < 3) return y;\n    if (n & 1) return x_or_y(n - 2, x, y);\n    return x_or_y(n >> 1, x, y);",
    "grade-1": {
      "execution": 0
    },
    "2": "if (n % x == 0 && n % y == 0) return x;\n\telse return y;",
    "grade-2": {
      "execution": 0
    },
    "3": "long i;\n    if(n == 2 || n == 3){\n        return x;\n    }\n    for(i = 2; i <= n/2; i++){\n        if(n % i == 0){\n            return y;\n        }\n    }\n    return x;",
    "grade-3": {
      "execution": 0
    },
    "4": "int i;\n  for(i=2;i<=n/2;i++)\n  {\n    if(n%i==0)\n      return y;\n  }\n  return x;",
    "grade-4": {
      "execution": 0
    },
    "5": "long b = 1;\n    for (long i = 2; i <= sqrt(n); i++) {\n        if (n % i == 0) {\n            b = 0;\n            break;\n        }\n    }\n    return b == 1 ? x : y;",
    "grade-5": {
      "execution": 0
    }
  },
  {
    "intent": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that accepts a list of strings as a parameter,\n// deletes the strings that have odd lengths from it,\n// and returns the resulted list with a sorted order,\n// The list is always a list of strings and never an array of numbers,\n// and it may contain duplicates.\n// The order of the list should be ascending by length of each word, and you\n// should return the list sorted by that rule.\n// If two words have the same length, sort the list alphabetically.\n// The function should return a list of strings in sorted order.\n// You may assume that all words will have the same length.\n// For example:\n// assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n// assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nstd::vector<std::string> sorted_list_sum(std::vector<std::string> lst) {\n",
    "task_id": "149",
    "prompt": "/*\nWrite a function that accepts a vector of strings as a parameter,\ndeletes the strings that have odd lengths from it,\nand returns the resulted vector with a sorted order,\nThe vector is always a vector of strings and never a vector of numbers,\nand it may contain duplicates.\nThe order of the vector should be ascending by length of each word, and you\nshould return the vector sorted by that rule.\nIf two words have the same length, sort the vector alphabetically.\nThe function should return a vector of strings in sorted order.\nYou may assume that all words will have the same length.\nFor example:\nassert vector_sort({\"aa\", \"a\", \"aaa\"}) => {\"aa\"}\nassert vector_sort({\"ab\", \"a\", \"aaa\", \"cd\"}) => {\"ab\", \"cd\"}\n*/\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\nvector<string> sorted_list_sum(vector<string> lst){\n",
    "simplified_intent": "Write a function that accepts a list of strings as a parameter, deletes the strings that have odd lengths from it, and returns the resulted list with a sorted order, The list is always a list of strings and never an array of numbers, and it may contain duplicates. The order of the list should be ascending by length of each word, and you should return the list sorted by that rule. If two words have the same length, sort the list alphabetically. The function should return a list of strings in sorted order. You may assume that all words will have the same length.",
    "snippet": [
      "    vector<string> out={};\n    for (int i=0;i<lst.size();i++)\n    if (lst[i].length()%2==0) out.push_back(lst[i]);\n    string mid;\n    sort(out.begin(),out.end());\n    for (int i=0;i<out.size();i++)\n    for (int j=1;j<out.size();j++)\n    if (out[j].length()<out[j-1].length())\n    {\n        mid=out[j];out[j]=out[j-1];out[j-1]=mid;\n    }\n    return out;\n}\n"
    ],
    "sample_from": {
      "0": "incoder",
      "1": "incoder",
      "2": "incoder",
      "3": "codex",
      "4": "codex",
      "5": "codex"
    },
    "0": "int n = lst.size();\n    std::vector<std::string> res;\n    for (int i = 0; i < n; i++) {\n        if (lst[i].size() % 2 == 1) {\n            res.emplace_back(lst[i]);\n        }\n    }\n    std::sort(res.begin(), res.end());\n    return res;",
    "grade-0": {
      "execution": 0
    },
    "1": "std::vector<std::string> ls;\n    for (auto s : lst) {\n        ls.push_back(s);\n    }\n    std::sort(ls.begin(), ls.end());\n    return ls;",
    "grade-1": {
      "execution": 0
    },
    "2": "std::sort(lst.begin(), lst.end());\n  std::unique_copy(lst.begin(), lst.end(), std::back_inserter(lst));\n  return lst;",
    "grade-2": {
      "execution": 0
    },
    "3": "std::sort(lst.begin(), lst.end());\n  return lst;",
    "grade-3": {
      "execution": 0
    },
    "4": "std::vector<std::string> ans;\n    for (auto x : lst) {\n        auto it = ans.begin();\n        for (; it != ans.end(); it++) {\n            if (x.size() < it->size()) {\n                break;\n            }\n            if (x.size() == it->size() && x > *it) {\n                break;\n            }\n        }\n        ans.insert(it, x);\n    }\n    return ans;",
    "grade-4": {
      "execution": 0
    },
    "5": "for (int i = 0; i < lst.size(); i++) {\n\t\tfor (int j = i + 1; j < lst.size(); j++) {\n\t\t\tif (lst[i].length() > lst[j].length()) {\n\t\t\t\tstd::string temp = lst[i];\n\t\t\t\tlst[i] = lst[j];\n\t\t\t\tlst[j] = temp;\n\t\t\t}\n\t\t}\n\t}\n\treturn lst;",
    "grade-5": {
      "execution": 0
    }
  },
  {
    "intent": "#include<assert.h>\n#include<bits/stdc++.h>\n// Given an integer. return a tuple that has the number of even and odd digits respectively.\n// Example:\n// even_odd_count(-12) ==> (1, 1)\n// even_odd_count(123) ==> (1, 2)\nstd::tuple<long, long> even_odd_count(long num) {\n",
    "task_id": "155",
    "prompt": "/*\nGiven an integer. return a vector that has the number of even and odd digits respectively.\n\n Example:\n    even_odd_count(-12) ==> {1, 1}\n    even_odd_count(123) ==> {1, 2}\n*/\n#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<vector>\nusing namespace std;\nvector<int> even_odd_count(int num){\n",
    "simplified_intent": "Given an integer. return a tuple that has the number of even and odd digits respectively.",
    "snippet": [
      "    string w=to_string(abs(num));\n    int n1=0,n2=0;\n    for (int i=0;i<w.length();i++)\n    if (w[i]%2==1) n1+=1;\n    else n2+=1;\n    return {n2,n1};\n}\n"
    ],
    "sample_from": {
      "0": "incoder",
      "1": "incoder",
      "2": "incoder",
      "3": "codex",
      "4": "codex",
      "5": "codex"
    },
    "0": "auto l = num % 10;\n    num /= 10;\n    auto n = num % 10;\n    num /= 10;\n    auto m = num % 10;\n    num /= 10;\n    auto o = num % 10;\n    num /= 10;\n    return std::make_tuple(l, n, m, o);",
    "grade-0": {
      "execution": 0
    },
    "1": "long even = 0;\n    long odd = 0;\n    while (num) {\n        long d = num % 10;\n        if (d == 0) {\n            even++;\n        } else {\n            odd++;\n        }\n        num /= 10;\n    }\n    return std::make_tuple(even, odd);",
    "grade-1": {
      "execution": 0
    },
    "2": "long even = 0, odd = 0;\n    while (num > 0) {\n        long remainder = num % 10;\n        if (remainder % 2 == 0) {\n            even++;\n        } else {\n            odd++;\n        }\n        num /= 10;\n    }\n    return std::make_tuple(even, odd);",
    "grade-2": {
      "execution": 0
    },
    "3": "// your code here\n    long even=0,odd=0;\n    int c = std::abs(num);\n    for(int i=c;i>0;i/=10){\n      int d = i%10;\n      if(d%2 == 0) even++;\n      else odd++;\n    }\n    return std::make_tuple(even,odd);",
    "grade-3": {
      "execution": 0
    },
    "4": "long odd = 0, even = 0;\n\twhile (num != 0) {\n\t\tint rem = num % 10;\n\t\tif (rem % 2 == 0)\n\t\t\teven++;\n\t\telse\n\t\t\todd++;\n\t\tnum /= 10;\n\t}\n\treturn std::make_tuple(even, odd);",
    "grade-4": {
      "execution": 0
    },
    "5": "long odd_count = 0;\n  long even_count = 0;\n  while (num != 0) {\n    if (abs(num % 10) % 2 == 0) {\n      even_count++;\n    } else {\n      odd_count++;\n    }\n    num /= 10;\n  }\n  return std::make_tuple(even_count, odd_count);",
    "grade-5": {
      "execution": 0
    }
  },
  {
    "intent": "#include<assert.h>\n#include<bits/stdc++.h>\n// This function takes a list l and returns a list l' such that\n// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n// to the values of the corresponding indicies of l, but sorted.\n// >>> sort_third([1, 2, 3])\n// [1, 2, 3]\n// >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n// [2, 6, 3, 4, 8, 9, 5]\nstd::vector<long> sort_third(std::vector<long> l) {\n",
    "task_id": "33",
    "prompt": "/*\nThis function takes a vector l and returns a vector l' such that\nl' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\nto the values of the corresponding indicies of l, but sorted.\n>>> sort_third({1, 2, 3})\n{1, 2, 3}\n>>> sort_third({5, 6, 3, 4, 8, 9, 2})\n{2, 6, 3, 4, 8, 9, 5}\n*/\n#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nvector<int> sort_third(vector<int> l){\n",
    "simplified_intent": "This function takes a list l and returns a list l' such that l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal to the values of the corresponding indicies of l, but sorted.",
    "snippet": [
      "    vector<int> third={};\n    int i;\n    for (i=0;i*3<l.size();i++)\n        third.push_back(l[i*3]);\n    \n    sort(third.begin(),third.end());\n\n    vector<int> out={};\n    for (i=0;i<l.size();i++)\n    {\n        if (i%3==0) {out.push_back(third[i/3]);}\n        else out.push_back(l[i]);\n    }\n    return out;\n\n}\n"
    ],
    "sample_from": {
      "0": "incoder",
      "1": "incoder",
      "2": "incoder",
      "3": "codex",
      "4": "codex",
      "5": "codex"
    },
    "0": "std::vector<long> l1;\n    l1.reserve(l.size());\n    for (long i : l) {\n        if (i % 3 == 0) {\n            l1.push_back(i);\n        } else {\n            l1.push_back(l[0]);\n        }\n    }\n    std::sort(l1.begin(), l1.end());\n    return l1;",
    "grade-0": {
      "execution": 0
    },
    "1": "std::vector<long> lv(l.size());\n    std::vector<long> lvp(l.size());\n    lvp.reserve(l.size());\n    for (long i = 0; i < l.size(); i++) {\n        if (i % 3 == 0) {\n            lvp.push_back(i);\n        }\n    }\n    lv.insert(lv.begin(), lvp.begin(), lvp.end());\n    std::vector<long> lvp(l.size());\n    for (long i = 0; i < l.size(); i++) {\n        if (i % 3 == 1) {\n            lvp.push_back(i);\n        }\n    }\n    lv.insert(lv.begin() + lvp.size(), lvp.begin(), lvp.end());\n    lv.insert(lv.begin() + 2 * lvp.size(), lvp.begin() + 1, lvp.end());\n    std::vector<long> lvp(l.size());\n    for (long i = 0; i < l.size(); i++) {\n        if (i % 3 == 2) {\n            lvp.push_back(i);\n        }\n    }\n    lv.insert(lv.begin() + 3 * lvp.size(), lvp.begin() + 2, lvp.end());\n    return lv;",
    "grade-1": {
      "execution": 0
    },
    "2": "std::vector<long> l0(l.size());\n    for (size_t i = 0; i < l.size(); ++i) {\n        if (i % (l.size() / 3) == 0) {\n            l0[i] = l[i % l.size()];\n        }\n        else {\n            l0[i] = l[(i + 3) % l.size()];\n        }\n    }\n    std::vector<long> l1(l.size());\n    for (size_t i = 0; i < l.size(); ++i) {\n        if (i % (l.size() / 3) == 0) {\n            long s = l[i % l.size()];\n            long t = l[(i + 3) % l.size()];\n            l1[i] = std::min(std::min(s, t), l0[i]);\n        }\n        else {\n            long s = l[(i + 3) % l.size()];\n            long t = l[i % l.size()];\n            l1[i] = std::max(std::max(s, t), l0[i]);\n        }\n    }\n    return l1;",
    "grade-2": {
      "execution": 0
    },
    "3": "// Do not edit this space!\n  int size = l.size();\n  std::vector<long> ans;\n  for (int i = 0; i < size; i++) {\n    if (i % 3 == 0) {\n      sort(l.begin() + i, l.begin() + i + 3);\n    }\n    ans.push_back(l[i]);\n  }\n  return ans;\n  // Do not edit this space!",
    "grade-3": {
      "execution": 0
    },
    "4": "std::vector<long> sorted;\n\tstd::vector<long> l_third;\n\tstd::vector<long> l_not_third;\n\tfor (int i = 0; i < l.size(); i++) {\n\t\tif (i % 3 == 0) {\n\t\t\tl_third.push_back(l[i]);\n\t\t}\n\t\telse {\n\t\t\tl_not_third.push_back(l[i]);\n\t\t}\n\t}\n\tstd::sort(l_third.begin(), l_third.end());\n\tint j = 0;\n\tfor (int i = 0; i < l.size(); i++) {\n\t\tif (i % 3 == 0) {\n\t\t\tsorted.push_back(l_third[j]);\n\t\t\tj++;\n\t\t}\n\t\telse {\n\t\t\tsorted.push_back(l_not_third[i - j]);\n\t\t}\n\t}\n\treturn sorted;",
    "grade-4": {
      "execution": 1
    },
    "5": "std::vector<long> ans(l.size());\n    int n = (int)l.size();\n    int st = 0;\n    while (st < n) {\n        std::vector<long> now;\n        for (int i = st; i < n && i < st + 3; i++) {\n            now.push_back(l[i]);\n        }\n        st += 3;\n        sort(now.begin(), now.end());\n        for (int i = 0; i < now.size(); i++) {\n            ans[st - 3 + i] = now[i];\n        }\n    }\n    return ans;",
    "grade-5": {
      "execution": 0
    }
  },
  {
    "intent": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that returns True if the last character\n// of a given string is an alphabetical character and is not\n// a part of a word, and False otherwise.\n// Note: \"word\" is a group of characters separated by space.\n// Examples:\n// check_if_last_char_is_a_letter(\"apple pie\") \u279e False\n// check_if_last_char_is_a_letter(\"apple pi e\") \u279e True\n// check_if_last_char_is_a_letter(\"apple pi e \") \u279e False\n// check_if_last_char_is_a_letter(\"\") \u279e False\nbool check_if_last_char_is_a_letter(std::string txt) {\n",
    "task_id": "134",
    "prompt": "/*\nCreate a function that returns true if the last character\nof a given string is an alphabetical character and is not\na part of a word, and false otherwise.\nNote: \"word\" is a group of characters separated by space.\n\nExamples:\ncheck_if_last_char_is_a_letter(\"apple pie\") \u279e false\ncheck_if_last_char_is_a_letter(\"apple pi e\") \u279e true\ncheck_if_last_char_is_a_letter(\"apple pi e \") \u279e false\ncheck_if_last_char_is_a_letter(\"\") \u279e false \n*/\n#include<stdio.h>\n#include<string>\nusing namespace std;\nbool check_if_last_char_is_a_letter(string txt){\n",
    "simplified_intent": "Create a function that returns True if the last character of a given string is an alphabetical character and is not a part of a word, and False otherwise. Note: \"word\" is a group of characters separated by space.",
    "snippet": [
      "    if (txt.length()==0) return false;\n    char chr=txt[txt.length()-1];\n    if (chr<65 or (chr>90 and chr<97) or chr>122) return false;\n    if (txt.length()==1) return true;\n    chr=txt[txt.length()-2];\n    if ((chr>=65 and chr<=90) or (chr>=97 and chr<=122)) return false;\n    return true;\n}\n"
    ],
    "sample_from": {
      "0": "incoder",
      "1": "incoder",
      "2": "incoder",
      "3": "codex",
      "4": "codex",
      "5": "codex"
    },
    "0": "std::string words = txt.substr(0, txt.length()-1);\n    std::string last_word = words.substr(words.length()-1, words.length());\n    std::string all_chars = words.substr(0, words.length()-1);\n    return all_chars.find_last_not_of(all_chars)!= std::string::npos\n            && all_chars.find_last_not_of(all_chars)!= std::string::npos\n            && all_chars.find_last_not_of(all_chars)!= std::string::npos\n            && all_chars.find_last_not_of(all_chars)!= std::string::npos\n            && all_chars.find_last_not_of(all_chars)!= std::string::npos\n            && !last_word.empty();",
    "grade-0": {
      "execution": 0
    },
    "1": "bool flag = false;\n    for (int i = 0; i < txt.length(); i++) {\n        if (isalpha(txt[i]) == true) {\n            if (i == (txt.length() - 1)) {\n                flag = true;\n                break;\n            }\n            else if (txt[i+1] != ' ') {\n                flag = false;\n                break;\n            }\n        }\n    }\n    return flag;",
    "grade-1": {
      "execution": 0
    },
    "2": "int last_index = txt.find_last_of(' ');\n  assert(last_index != std::string::npos);\n  char last_char = txt[last_index];\n  bool is_a_letter = ('A' <= last_char && last_char <= 'Z') || ('a' <= last_char && last_char <= 'z');\n  return !is_a_letter;",
    "grade-2": {
      "execution": 0
    },
    "3": "bool check=false;\n\tint i=txt.length()-1;\n\tchar f=txt[i];\n\tif(f>='a' && f<='z' || f>='A' && f<='Z')\n\t{\n\t\tcheck=true;\n\t}\n\tif(txt[i-1]>='a' && txt[i-1]<='z' || txt[i-1]>='A' && txt[i-1]<='Z')\n\t{\n\t\tcheck=false;\n\t}\n\treturn check;",
    "grade-3": {
      "execution": 1
    },
    "4": "if(txt.length()==0){\n    return false;\n  }\n  else{\n    std::string last_char;\n    last_char=txt.substr(txt.length()-1,txt.length());\n    return(last_char.find(' ')==std::string::npos);\n  }",
    "grade-4": {
      "execution": 0
    },
    "5": "for (int i = 0; i < txt.length(); i++) {\n\t\tif (txt[i] == ' ') {\n\t\t\tif (i + 1 != txt.length()) {\n\t\t\t\tif (txt[i + 1] != ' ') {\n\t\t\t\t\tif (txt[i + 1] >= 'a' && txt[i + 1] <= 'z') {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn false;",
    "grade-5": {
      "execution": 0
    }
  },
  {
    "intent": "#include<assert.h>\n#include<bits/stdc++.h>\n// Find how many times a given substring can be found in the original string. Count overlaping cases.\n// >>> how_many_times('', 'a')\n// 0\n// >>> how_many_times('aaa', 'a')\n// 3\n// >>> how_many_times('aaaa', 'aa')\n// 3\nlong how_many_times(std::string string, std::string substring) {\n",
    "task_id": "18",
    "prompt": "/*\nFind how many times a given substring can be found in the original string. Count overlaping cases.\n>>> how_many_times(\"\", \"a\")\n0\n>>> how_many_times(\"aaa\", \"a\")\n3\n>>> how_many_times(\"aaaa\", \"aa\")\n3\n*/\n#include<stdio.h>\n#include<string>\nusing namespace std;\nint how_many_times(string str,string substring){\n",
    "simplified_intent": "Find how many times a given substring can be found in the original string. Count overlaping cases.",
    "snippet": [
      "    int out=0;\n    if (str.length()==0) return 0;\n    for (int i=0;i<=str.length()-substring.length();i++)\n    if (str.substr(i,substring.length())==substring)\n        out+=1;\n    return out;\n}\n"
    ],
    "sample_from": {
      "0": "incoder",
      "1": "incoder",
      "2": "incoder",
      "3": "codex",
      "4": "codex",
      "5": "codex"
    },
    "0": "size_t found = string.find(substring);\n    if (found == std::string::npos)\n        return 0;\n\n    long ret = 1;\n\n    for (size_t i = found + 1; i < string.size(); i++)\n    {\n        if (string[i] == substring[found])\n        {\n            ret++;\n        }\n    }\n\n    return ret;",
    "grade-0": {
      "execution": 0
    },
    "1": "auto it = string.find(substring);\n    if(it == string.length())\n        return 0;\n    long count = std::count(string.begin(), string.end(), substring);\n    while(it != string.length() && count == 0)\n    {\n        it = string.find(substring, it + 1);\n        count++;\n    }\n    return count;",
    "grade-1": {
      "execution": 0
    },
    "2": "long count = 0;\n    for (int i = 0; i < string.size(); i++) {\n        if (string.at(i) == substring.at(0)) {\n            count++;\n        }\n        if (string.at(i) == substring.at(1)) {\n            count++;\n        }\n        if (string.at(i) == substring.at(2)) {\n            count++;\n        }\n    }\n    return count;",
    "grade-2": {
      "execution": 0
    },
    "3": "long c = 0;\n  for (int i = 0; i < string.length(); i++) {\n    if (string.substr(i, substring.length()) == substring) {\n      c++;\n    }\n  }\n  return c;",
    "grade-3": {
      "execution": 1
    },
    "4": "long count = 0;\n    size_t npos = std::string::npos;\n    size_t pos = 0;\n    while((pos = string.find(substring, pos)) != npos) {\n        ++count;\n        ++pos;\n    }\n    return count;",
    "grade-4": {
      "execution": 1
    },
    "5": "long count = 0;\n  for (long i = 0; i <= string.size() - substring.size(); i++) {\n    if (string.substr(i, substring.size()) == substring) {\n      count++;\n    }\n  }\n  return count;",
    "grade-5": {
      "execution": 0
    }
  },
  {
    "intent": "#include<assert.h>\n#include<bits/stdc++.h>\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the array will be randomly ordered. Your task is to determine if\n// it is possible to get an array sorted in non-decreasing order by performing \n// the following operation on the given array:\n// You are allowed to perform right shift operation any number of times.\n// One right shift operation means shifting all elements of the array by one\n// position in the right direction. The last element of the array will be moved to\n// the starting position in the array i.e. 0th index. \n// If it is possible to obtain the sorted array by performing the above operation\n// then return True else return False.\n// If the given array is empty then return True.\n// Note: The given list is guaranteed to have unique elements.\n// For Example:\n// move_one_ball([3, 4, 5, 1, 2])==>True\n// Explanation: By performin 2 right shift operations, non-decreasing order can\n// be achieved for the given array.\n// move_one_ball([3, 5, 4, 1, 2])==>False\n// Explanation:It is not possible to get non-decreasing order for the given\n// array by performing any number of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n",
    "task_id": "109",
    "prompt": "/*\nWe have a vector \"arr\" of N integers arr[1], arr[2], ..., arr[N].The\nnumbers in the vector will be randomly ordered. Your task is to determine if\nit is possible to get a vector sorted in non-decreasing order by performing \nthe following operation on the given vector:\n    You are allowed to perform right shift operation any number of times.\n\nOne right shift operation means shifting all elements of the vector by one\nposition in the right direction. The last element of the vector will be moved to\nthe starting position in the vector i.e. 0th index. \n\nIf it is possible to obtain the sorted vector by performing the above operation\nthen return true else return false.\nIf the given vector is empty then return true.\n\nNote: The given vector is guaranteed to have unique elements.\n\nFor Example:\n\nmove_one_ball({3, 4, 5, 1, 2})==>true\nExplanation: By performing 2 right shift operations, non-decreasing order can\n             be achieved for the given vector.\nmove_one_ball({3, 5, 4, 1, 2})==>false\nExplanation:It is not possible to get non-decreasing order for the given\n            vector by performing any number of right shift operations.\n            \n*/\n#include<stdio.h>\n#include<vector>\nusing namespace std;\nbool move_one_ball(vector<int> arr){\n",
    "simplified_intent": "We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The numbers in the array will be randomly ordered. Your task is to determine if it is possible to get an array sorted in non-decreasing order by performing the following operation on the given array: You are allowed to perform right shift operation any number of times. One right shift operation means shifting all elements of the array by one position in the right direction. The last element of the array will be moved to the starting position in the array i.e. 0th index. If it is possible to obtain the sorted array by performing the above operation then return True else return False. If the given array is empty then return True. Note: The given list is guaranteed to have unique elements. For",
    "snippet": [
      "    int num=0;\n    if (arr.size()==0) return true;\n    for (int i=1;i<arr.size();i++)\n        if (arr[i]<arr[i-1]) num+=1;\n    if (arr[arr.size()-1]>arr[0]) num+=1;\n    if (num<2) return true;\n    return false;\n}\n"
    ],
    "sample_from": {
      "0": "incoder",
      "1": "incoder",
      "2": "incoder",
      "3": "codex",
      "4": "codex",
      "5": "codex"
    },
    "0": "assert(arr.size() != 0);\n    std::stack<long> st;\n    // The size of the stack is equal to the size of the given array\n    // because only one shift operation is allowed on it.\n    st.push(arr.back());\n    long temp = arr[arr.size()-1];\n    while(st.size() != 0){\n        arr[st.top()] = temp;\n        st.pop();\n    }\n    return arr.size() == 1;",
    "grade-0": {
      "execution": 0
    },
    "1": "int n = (int)arr.size();\n    int k = (int)arr[n-1];\n    std::vector<bool> visited(n, false);\n    int count = 0;\n    for(int i = 0; i < n-1; ++i) {\n        if(visited[i]) {\n            continue;\n        }\n        if(k == arr[i]) {\n            visited[i] = true;\n            ++count;\n        }\n        if(count == arr[i]) {\n            return true;\n        }\n    }\n    return false;",
    "grade-1": {
      "execution": 0
    },
    "2": "// Your code goes here\n  int i, temp, counter = 0, count = 0;\n  long start = arr[0], end = arr[0];\n  for (i = 0; i < arr.size(); i++) {\n    if (arr[i] > end) {\n      temp = 0;\n      for (counter = 0; counter < i; counter++) {\n        temp = arr[i] + temp;\n      }\n      arr[i - 1] = temp;\n      end = temp;\n    }\n    else if (arr[i] > start) {\n      temp = 0;\n      for (counter = 0; counter < i; counter++) {\n        temp = arr[i] + temp;\n      }\n      arr[i] = temp;\n      start = temp;\n    }\n    if (temp > start) {\n      count++;\n    }\n  }\n  if (count == 0) {\n    return true;\n  } else {\n    return false;\n  }",
    "grade-2": {
      "execution": 0
    },
    "3": "if(arr.size()<2)\n        return true;\n    bool flag = false;\n    long count = 0;\n    for(int i=0;i<arr.size()-1;i++){\n        if(arr[i]<arr[i+1])\n            continue;\n        count++;\n        if(count==1)\n            i++;\n        else\n            return false;\n    }\n    return true;",
    "grade-3": {
      "execution": 0
    },
    "4": "if(arr.size() == 0)\n        return true;\n    int maxx = INT_MIN;\n    int count = 0;\n    for(int i = 0; i < arr.size(); i++) {\n        if(arr[i] > maxx) {\n            maxx = arr[i];\n            count++;\n        }\n    }\n    if(count == arr.size())\n        return true;\n    return false;",
    "grade-4": {
      "execution": 0
    },
    "5": "// WRITE YOUR CODE HERE\n  if(arr.size()==0)\n  {\n    return true;\n  }\n  for(int i=1;i<arr.size();i++)\n  {\n    if(arr[i]<arr[i-1])\n    {\n      return false;\n    }\n  }\n  return true;",
    "grade-5": {
      "execution": 0
    }
  },
  {
    "intent": "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a dictionary, return True if all keys are strings in lower \n// case or all keys are strings in upper case, else return False.\n// The function should return False is the given dictionary is empty.\n// Examples:\n// check_dict_case({\"a\":\"apple\", \"b\":\"banana\"}) should return True.\n// check_dict_case({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return False.\n// check_dict_case({\"a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n// check_dict_case({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\nbool check_dict_case(std::map<std::string, std::string> dict) {\n",
    "task_id": "95",
    "prompt": "/*\nGiven a map, return true if all keys are strings in lower \ncase or all keys are strings in upper case, else return false.\nThe function should return false is the given map is empty.\nExamples:\ncheck_map_case({{\"a\",\"apple\"}, {\"b\",\"banana\"}}) should return true.\ncheck_map_case({{\"a\",\"apple\"}, {\"A\",\"banana\"}, {\"B\",\"banana\"}}) should return false.\ncheck_map_case({{\"a\",\"apple\"}, {\"8\",\"banana\"}, {\"a\",\"apple\"}}) should return false.\ncheck_map_case({{\"Name\",\"John\"}, {\"Age\",\"36\"}, {\"City\",\"Houston\"}}) should return false.\ncheck_map_case({{\"STATE\",\"NC\"}, {\"ZIP\",\"12345\"} }) should return true.\n*/\n#include<stdio.h>\n#include<string>\n#include<map>\nusing namespace std;\nbool check_dict_case(map<string,string> dict){\n",
    "simplified_intent": "Given a dictionary, return True if all keys are strings in lower case or all keys are strings in upper case, else return False. The function should return False is the given dictionary is empty.",
    "snippet": [
      "    map<string,string>::iterator it;\n    int islower=0,isupper=0;\n    if (dict.size()==0) return false;\n    for (it=dict.begin();it!=dict.end();it++)\n    {\n        string key=it->first;\n    \n        for (int i=0;i<key.length();i++)\n        {\n            if (key[i]<65 or (key[i]>90 and key[i]<97) or key[i]>122) return false;\n            if (key[i]>=65 and key[i]<=90) isupper=1;\n            if (key[i]>=97 and key[i]<=122) islower=1;\n            if (isupper+islower==2) return false;\n        }\n\n    }\n    return true;\n}\n"
    ],
    "sample_from": {
      "0": "incoder",
      "1": "incoder",
      "2": "incoder",
      "3": "codex",
      "4": "codex",
      "5": "codex"
    },
    "0": "// Your code here",
    "grade-0": {
      "execution": 0
    },
    "1": "// TODO : your code here\n    // Your code here\n    return true;",
    "grade-1": {
      "execution": 0
    },
    "2": "if (dict.empty()) return true;\n    for (auto iter = dict.begin(); iter != dict.end(); iter++) {\n        // If key is in lower case, then it's ok.\n        if (iter->first.length() > 0 && iter->first.compare(0, iter->first.length(), iter->first) == 0) {\n            continue;\n        }\n        // If key is in upper case, then it's ok.\n        else if (iter->first.length() > 0 && iter->first.compare(0, iter->first.length(), iter->first.upper()) == 0) {\n            continue;\n        }\n        else {\n            return false;\n        }\n    }\n    return true;",
    "grade-2": {
      "execution": 0
    },
    "3": "",
    "grade-3": {
      "execution": 0
    },
    "4": "if (dict.size() == 0) {\n\t\treturn false;\n\t}\n\t\n\tbool all_lower = true;\n\tfor (auto kv : dict) {\n\t\tfor (auto c : kv.first) {\n\t\t\tif (c < 'a' || c > 'z') {\n\t\t\t\tall_lower = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tif (all_lower) {\n\t\treturn true;\n\t}\n\t\n\tfor (auto kv : dict) {\n\t\tfor (auto c : kv.first) {\n\t\t\tif (c < 'A' || c > 'Z') {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn true;",
    "grade-4": {
      "execution": 1
    },
    "5": "if(dict.size() == 0)\n        return false;\n    bool in_lower = false;\n    bool in_upper = false;\n    std::map<std::string, std::string>::iterator iter;\n    for(iter = dict.begin(); iter != dict.end(); iter++) {\n        //std::cout << \"key = \" << iter->first << \" value = \" << iter->second << std::endl;\n        if(isupper(iter->first[0])) {\n            in_upper = true;\n        } else {\n            in_lower = true;\n        }\n    }\n    return (in_lower == in_upper);",
    "grade-5": {
      "execution": 0
    }
  },
  {
    "intent": "#include<assert.h>\n#include<bits/stdc++.h>\n// Return list of all prefixes from shortest to longest of the input string\n// >>> all_prefixes('abc')\n// ['a', 'ab', 'abc']\nstd::vector<std::string> all_prefixes(std::string string) {\n",
    "task_id": "14",
    "prompt": "/*\nReturn vector of all prefixes from shortest to longest of the input string\n>>> all_prefixes(\"abc\")\n{\"a\", \"ab\", \"abc\"}\n*/\n#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\nvector<string> all_prefixes(string str){\n",
    "simplified_intent": "Return list of all prefixes from shortest to longest of the input string",
    "snippet": [
      "    vector<string> out;\n    string current=\"\";\n    for (int i=0;i<str.length();i++)\n    {\n        current=current+str[i];\n        out.push_back(current);\n    }\n    return out;\n}\n"
    ],
    "sample_from": {
      "0": "incoder",
      "1": "incoder",
      "2": "incoder",
      "3": "codex",
      "4": "codex",
      "5": "codex"
    },
    "0": "int n = string.length();\n  std::vector<std::string> prefixes(n + 1, string);\n  for (int i = 0; i < n; ++i)\n    prefixes[i] = string.substr(0, i);\n  return prefixes;",
    "grade-0": {
      "execution": 0
    },
    "1": "std::vector<std::string> strings;\n  for (int i = 0; i < string.size(); i++) {\n    strings.push_back(string.substr(0, i));\n  }\n  return strings;",
    "grade-1": {
      "execution": 0
    },
    "2": "// Find the length of the string\n  int length = string.length();\n  std::vector<std::string> prefixes(length);\n  // Iterate over the string from left to right\n  for (int i = 1; i < length; ++i) {\n    // Add the prefix of this index to the prefix of i\n    prefixes[i - 1] += string.substr(0, i);\n  }\n  return prefixes;",
    "grade-2": {
      "execution": 0
    },
    "3": "std::vector<std::string>prefixes;\n  for (int i = 0; i < string.size(); i++) {\n    prefixes.push_back(string.substr(0, i + 1));\n  }\n  return prefixes;",
    "grade-3": {
      "execution": 1
    },
    "4": "std::vector<std::string> result;\n  int size = string.size();\n  for (int i = 0; i < size; i++) {\n    std::string substring = string.substr(0, i + 1);\n    result.push_back(substring);\n  }\n  return result;",
    "grade-4": {
      "execution": 1
    },
    "5": "std::vector<std::string> r;\n    for (int i = 1; i <= string.size(); i++) {\n        r.push_back(string.substr(0, i));\n    }\n    return r;",
    "grade-5": {
      "execution": 1
    }
  },
  {
    "intent": "#include<assert.h>\n#include<bits/stdc++.h>\n// Given list of numbers (of at least two elements), apply a linear transform to that list,\n// such that the smallest number will become 0 and the largest will become 1\n// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\nstd::vector<float> rescale_to_unit(std::vector<float> numbers) {\n",
    "task_id": "21",
    "prompt": "/*\nGiven vector of numbers (of at least two elements), apply a linear transform to that vector,\nsuch that the smallest number will become 0 and the largest will become 1\n>>> rescale_to_unit({1.0, 2.0, 3.0, 4.0, 5.0})\n{0.0, 0.25, 0.5, 0.75, 1.0}\n*/\n#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\nvector<float> rescale_to_unit(vector<float> numbers){ \n",
    "simplified_intent": "Given list of numbers (of at least two elements), apply a linear transform to that list, such that the smallest number will become 0 and the largest will become 1",
    "snippet": [
      "    float min=100000,max=-100000;\n    for (int i=0;i<numbers.size();i++)\n        {\n            if (numbers[i]<min) min=numbers[i];\n            if (numbers[i]>max) max=numbers[i];\n        }\n    for (int i=0;i<numbers.size();i++)\n        numbers[i]=(numbers[i]-min)/(max-min);\n    return numbers;\n}\n"
    ],
    "sample_from": {
      "0": "incoder",
      "1": "incoder",
      "2": "incoder",
      "3": "codex",
      "4": "codex",
      "5": "codex"
    },
    "0": "std::vector<float> unit;\n  // Rescale all numbers to [0, 1]\n  for (auto x : numbers)\n    unit.push_back((x - numbers[0]) / (numbers[1] - numbers[0]));\n  // Scale smallest number if all numbers are positive\n  if (unit.back() <= 0) {\n    unit.push_back(unit.back());\n    unit.front() = 0;\n  }\n  return unit;",
    "grade-0": {
      "execution": 0
    },
    "1": "std::vector<float> rescaled_number(numbers.begin(), numbers.end());\n    assert(rescaled_number.size() > 1);\n    rescaled_number[0] = 0.0;\n    rescaled_number.back = 1.0;\n    float sum = 0;\n    for (auto number : rescaled_number) {\n        sum += number;\n    }\n    float inverse = 1.0 / sum;\n    for (auto number : rescaled_number) {\n        rescaled_number[0] += number * inverse;\n    }\n    return rescaled_number;",
    "grade-1": {
      "execution": 0
    },
    "2": "int n = numbers.size();\n    std::vector<float> tmp(n);\n    for (size_t i = 0; i < n; i++) {\n        tmp[i] = numbers[i] * 2.0 - 1.0;\n    }\n    sort(tmp.begin(), tmp.end());\n    tmp[0] = 0.0;\n    tmp[n-1] = 1.0;\n    return tmp;",
    "grade-2": {
      "execution": 0
    },
    "3": "// Implement this\n  std::vector<float> v;\n  float min = *min_element(numbers.begin(), numbers.end());\n  float max = *max_element(numbers.begin(), numbers.end());\n  for (float n : numbers) {\n    float r = (n - min) / (max - min);\n    v.push_back(r);\n  }\n  return v;",
    "grade-3": {
      "execution": 1
    },
    "4": "assert(numbers.size() >= 2);\n  float min = *min_element(numbers.begin(), numbers.end());\n  float max = *max_element(numbers.begin(), numbers.end());\n  float range = max - min;\n  std::vector<float> rescaled;\n  for (auto number : numbers) {\n    rescaled.push_back((number - min) / range);\n  }\n  return rescaled;",
    "grade-4": {
      "execution": 1
    },
    "5": "float max_val = -1, min_val = std::numeric_limits<float>::max();\n    for (auto it = numbers.begin(); it != numbers.end(); ++it) {\n        if (*it > max_val) {\n            max_val = *it;\n        }\n        if (*it < min_val) {\n            min_val = *it;\n        }\n    }\n    std::cout << \"Min \" << min_val << \" max \" << max_val << std::endl;\n    float val_range = max_val - min_val;\n    if (val_range == 0) {\n        return std::vector<float>(numbers.size(), 0);\n    }\n    for (auto it = numbers.begin(); it != numbers.end(); ++it) {\n        *it = (*it - min_val) / val_range;\n    }\n    return numbers;",
    "grade-5": {
      "execution": 1
    }
  },
  {
    "intent": "#include<assert.h>\n#include<bits/stdc++.h>\n// For a given list of input numbers, calculate Mean Absolute Deviation\n// around the mean of this dataset.\n// Mean Absolute Deviation is the average absolute difference between each\n// element and a centerpoint (mean in this case):\n// MAD = average | x - x_mean |\n// >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n// 1.0\nfloat mean_absolute_deviation(std::vector<float> numbers) {\n",
    "task_id": "4",
    "prompt": "/*\nFor a given vector of input numbers, calculate Mean Absolute Deviation\naround the mean of this dataset.\nMean Absolute Deviation is the average absolute difference between each\nelement and a centerpoint (mean in this case):\nMAD = average | x - x_mean |\n>>> mean_absolute_deviation({1.0, 2.0, 3.0, 4.0})\n1.0\n*/\n#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\nfloat mean_absolute_deviation(vector<float> numbers){\n",
    "simplified_intent": "For a given list of input numbers, calculate Mean Absolute Deviation around the mean of this dataset. Mean Absolute Deviation is the average absolute difference between each element and a centerpoint (mean in this case): MAD = average | x - x_mean |",
    "snippet": [
      "    float sum=0;\n    float avg,msum,mavg;\n    int i=0;\n    for (i=0;i<numbers.size();i++)\n        sum+=numbers[i];\n    avg=sum/numbers.size();\n    msum=0;\n    for (i=0;i<numbers.size();i++)\n        msum+=abs(numbers[i]-avg);\n    return msum/numbers.size();\n}\n"
    ],
    "sample_from": {
      "0": "incoder",
      "1": "incoder",
      "2": "incoder",
      "3": "codex",
      "4": "codex",
      "5": "codex"
    },
    "0": "float sum = 0;\n    for (float number : numbers) {\n        sum += powf(number - mean, 2);\n    }\n    return sum / numbers.size();",
    "grade-0": {
      "execution": 0
    },
    "1": "assert(numbers.size() > 0);\n    float mean = numbers.at(0);\n    float sum = 0;\n    for (size_t i = 0; i < numbers.size(); i++) {\n        sum += fabs(numbers.at(i) - mean);\n    }\n    return sum / numbers.size();",
    "grade-1": {
      "execution": 0
    },
    "2": "// For this exercise, we use the following formula:\n    // https://en.wikipedia.org/wiki/Mean_square_deviation\n    // MAD = (sum((x - average)**2) /\n    //         (size(x) - 1))\n    float average = numbers.back();\n    float sum = 0;\n    for (float number : numbers) {\n        sum += (number - average) * (number - average);\n    }\n    return std::sqrt(sum / static_cast<float>(numbers.size() - 1));",
    "grade-2": {
      "execution": 0
    },
    "3": "float sum = 0.0;\n\tfor (int i = 0; i < numbers.size(); i++) {\n\t\tsum += numbers[i];\n\t}\n\tfloat mean = sum / (float)numbers.size();\n\tfloat sum_of_differences = 0.0;\n\tfor (int i = 0; i < numbers.size(); i++) {\n\t\tsum_of_differences += fabs(numbers[i] - mean);\n\t}\n\treturn sum_of_differences / (float)numbers.size();",
    "grade-3": {
      "execution": 0
    },
    "4": "float sum = 0;\n    float mean = 0;\n    float absolute_difference = 0;\n    float MAD = 0;\n    // find mean\n    for (int i = 0; i < numbers.size(); i++) {\n        sum += numbers[i];\n    }\n    mean = sum / numbers.size();\n    // find MAD\n    for (int i = 0; i < numbers.size(); i++) {\n        absolute_difference += std::abs(numbers[i] - mean);\n    }\n    MAD = absolute_difference / numbers.size();\n    return MAD;",
    "grade-4": {
      "execution": 0
    },
    "5": "assert(numbers.size() > 0);\n    // TODO: Update this to actually calculate Mean Absolute Deviation.\n    float mad = 0.0;\n    float sum = 0.0;\n    float mean = 0.0;\n    float mean_deviation = 0.0;\n    float deviate = 0.0;\n    float abs_deviation = 0.0;\n    float abs_deviation_avg = 0.0;\n    for (float num : numbers) {\n        sum += num;\n    }\n    mean = sum / numbers.size();\n    for (float num : numbers) {\n        mean_deviation = num - mean;\n        deviate += mean_deviation;\n        abs_deviation = abs(deviate);\n        abs_deviation_avg = abs_deviation / numbers.size();\n    }\n    mad = abs_deviation_avg;\n    return mad;",
    "grade-5": {
      "execution": 0
    }
  },
  {
    "intent": "#include<assert.h>\n#include<bits/stdc++.h>\n// The Brazilian factorial is defined as:\n// brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n// where n > 0\n// For example:\n// >>> special_factorial(4)\n// 288\n// The function will receive an integer as input and should return the special\n// factorial of this integer.\nlong special_factorial(long n) {\n",
    "task_id": "139",
    "prompt": "/*\nThe Brazilian factorial is defined as:\nbrazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\nwhere n > 0\n\nFor example:\n>>> special_factorial(4)\n288\n\nThe function will receive an integer as input and should return the special\nfactorial of this integer.\n*/\n#include<stdio.h>\nusing namespace std;\nlong long special_factorial(int n){\n",
    "simplified_intent": "The Brazilian factorial is defined as: brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1! where n > 0",
    "snippet": [
      "    long long fact=1,bfact=1;\n    for (int i=1;i<=n;i++)\n    {\n        fact=fact*i;\n        bfact=bfact*fact;\n    }\n    return bfact;\n}\n"
    ],
    "sample_from": {
      "0": "incoder",
      "1": "incoder",
      "2": "incoder",
      "3": "codex",
      "4": "codex",
      "5": "codex"
    },
    "0": "if (n < 2) {\n        return 1;\n    }\n    long res = 1;\n    for (long i = 2; i <= n; ++i) {\n        res = res * i;\n    }\n    return res;",
    "grade-0": {
      "execution": 0
    },
    "1": "assert(n >= 0);\n  long ans = 1;\n  for (long i = 2; i <= n; i++)\n    ans *= i;\n  return ans;",
    "grade-1": {
      "execution": 0
    },
    "2": "if (n < 2)\n        return 1;\n    else\n        return n * special_factorial(n - 1);",
    "grade-2": {
      "execution": 0
    },
    "3": "if (n <= 1) {\n\t\treturn 1;\n\t}\n\tlong result = n;\n\tfor (int i = n - 1; i > 0; i--) {\n\t\tresult *= i;\n\t}\n\treturn result;",
    "grade-3": {
      "execution": 0
    },
    "4": "// To be implemented\n    int fact = 1;\n    for(int i = 1; i <= n; i++)\n    {\n        fact = fact * i;\n    }\n    return fact;",
    "grade-4": {
      "execution": 0
    },
    "5": "// Your code here\n    long b=1;\n    long c=1;\n    while(n>0)\n    {\n        b*=n;\n        c*=b;\n        n--;\n    }\n    return c;",
    "grade-5": {
      "execution": 0
    }
  },
  {
    "intent": "#include<assert.h>\n#include<bits/stdc++.h>\n// You have to write a function which validates a given date string and\n// returns True if the date is valid otherwise False.\n// The date is valid if all of the following rules are satisfied:\n// 1. The date string is not empty.\n// 2. The number of days is not less than 1 or higher than 31 days for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30 days for months 4,6,9,11. And, the number of days is not less than 1 or higher than 29 for the month 2.\n// 3. The months should not be less than 1 or higher than 12.\n// 4. The date should be in the format: mm-dd-yyyy\n// for example: \n// valid_date('03-11-2000') => True\n// valid_date('15-01-2012') => False\n// valid_date('04-0-2040') => False\n// valid_date('06-04-2020') => True\n// valid_date('06/04/2020') => False\nbool valid_date(std::string date) {\n",
    "task_id": "124",
    "prompt": "/*\nYou have to write a function which validates a given date string and\nreturns true if the date is valid otherwise false.\nThe date is valid if all of the following rules are satisfied:\n1. The date string is not empty.\n2. The number of days is not less than 1 or higher than 31 days for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30 days for months 4,6,9,11. And, the number of days is not less than 1 or higher than 29 for the month 2.\n3. The months should not be less than 1 or higher than 12.\n4. The date should be in the format: mm-dd-yyyy\n\nfor example: \nvalid_date(\"03-11-2000\") => true\n\nvalid_date(\"15-01-2012\") => false\n\nvalid_date(\"04-0-2040\") => false\n\nvalid_date(\"06-04-2020\") => true\n\nvalid_date(\"06/04/2020\") => false\n*/\n#include<stdio.h>\n#include<string>\nusing namespace std;\nbool valid_date(string date){\n",
    "simplified_intent": "You have to write a function which validates a given date string and returns True if the date is valid otherwise False. The date is valid if all of the following rules are satisfied: 1. The date string is not empty. 2. The number of days is not less than 1 or higher than 31 days for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30 days for months 4,6,9,11. And, the number of days is not less than 1 or higher than 29 for the month 2. 3. The months should not be less than 1 or higher than 12. 4. The date should be in the format: mm-dd-yyyy",
    "snippet": [
      "    int mm,dd,yy,i;\n    if (date.length()!=10) return false;\n    for (int i=0;i<10;i++)\n        if (i==2 or i==5)\n        {\n            if (date[i]!='-') return false;\n        }\n        else\n            if (date[i]<48 or date[i]>57) return false;\n\n    mm=atoi(date.substr(0,2).c_str());\n    dd=atoi(date.substr(3,2).c_str());\n    yy=atoi(date.substr(6,4).c_str());\n    if (mm<1 or mm>12) return false;\n    if (dd<1 or dd>31) return false;\n    if (dd==31 and (mm==4 or mm==6 or mm==9 or mm==11 or mm==2)) return false;\n    if (dd==30 and mm==2) return false;\n    return true;\n\n}\n"
    ],
    "sample_from": {
      "0": "incoder",
      "1": "incoder",
      "2": "incoder",
      "3": "codex",
      "4": "codex",
      "5": "codex"
    },
    "0": "size_t pos = 0;\n    int month;\n    int day;\n    int year;\n\n    pos = date.find_first_not_of(\"-\");\n    if(pos == string::npos) return false;\n\n    month = stoi(date.substr(0,pos).c_str());\n    day = stoi(date.substr(pos+1,2).c_str());\n    year = stoi(date.substr(pos+3,4).c_str());\n\n    if(month<1 || month>12) return false;\n    if(day<1 || day>30) return false;\n    if(year<1000 || year>3000) return false;\n\n    while(month==2 || month==4 || month==6 || month==9 || month==11 || month==12 || month==0) {\n        month++;\n    }\n    \n    if(month<1 || month>12) return false;\n    if(day<1 || day>29) return false;\n    if(year<1000 || year>3000) return false;\n\n    while(day==1 || day==3 || day==5 || day==7 || day==8 || day==10 || day==12) {\n        day++;\n    }\n    \n    if(day<1 || day>29) return false;\n    if(year<1000 || year>3000) return false;\n\n    return true;",
    "grade-0": {
      "execution": 0
    },
    "1": "struct tm time;\n    bool isvalid = false;\n    // Check the length of the string is greater than 0\n    if (date.size() > 0) {\n        // Check the length of the string is correct (9 characters and 1 hyphen)\n        if (date.size() != 9 || date[6] != '-' || date[5] != '-' || date[4] != '-') {\n            return false;\n        }\n        // Convert the date string to time\n        strptime(date.c_str(), \"%d-%m-%Y\", &time);\n        isvalid = true;\n    }\n    // Check day\n    if (isvalid && time.tm_mday < 1 || time.tm_mday > 31) {\n        return false;\n    }\n    // Check month\n    if (isvalid && time.tm_mon < 1 || time.tm_mon > 12) {\n        return false;\n    }\n    // Check year\n    if (isvalid && time.tm_year < 1000 || time.tm_year > 3000) {\n        return false;\n    }\n    return isvalid;",
    "grade-1": {
      "execution": 0
    },
    "2": "// Write your code here\n    int month, day;\n    std::string days[] = {\n        \"31\",\n        \"30\",\n        \"29\",\n    };\n    int months[] = {\n        0,\n        1,\n        3,\n        5,\n        7,\n        8,\n        10,\n        12\n    };\n    int year;\n    std::istringstream ss(date);\n    ss >> month >> day >> year;\n    if (month < 1 || month > 12 || day < 1 || day > days[month - 2] || year < 2000 || year > 2020) {\n        return false;\n    }\n    return months[month - 1] <= day && day <= days[month - 2]\n            && year == std::stoi(date.substr(3, 4));",
    "grade-2": {
      "execution": 0
    },
    "3": "std::regex reg(\"^(?:(?:31(\\\\/|-|\\\\.)(?:0?[13578]|1[02]))\\\\1|(?:(?:29|30)(\\\\/|-|\\\\.)(?:0?[1,3-9]|1[0-2])\\\\2))(?:(?:1[6-9]|[2-9]\\\\d)?\\\\d{2})$|^(?:29(\\\\/|-|\\\\.)0?2\\\\3(?:(?:(?:1[6-9]|[2-9]\\\\d)?(?:0[48]|[2468][048]|[13579][26])|(?:(?:16|[2468][048]|[3579][26])00))))$|^(?:0?[1-9]|1\\\\d|2[0-8])(\\\\/|-|\\\\.)(?:(?:0?[1-9])|(?:1[0-2]))\\\\4(?:(?:1[6-9]|[2-9]\\\\d)?\\\\d{2})$\");\n   return std::regex_match(date, reg);",
    "grade-3": {
      "execution": 0
    },
    "4": "if(date.size() == 0)\n        return false;\n    if(date.find(\"-\") == std::string::npos)\n        return false;\n    std::string datepart[3];\n    int datepart_i = 0;\n    for(int i = 0; i < date.size(); i++) {\n        if(date[i] == '-') {\n            datepart_i++;\n            continue;\n        }\n        if(datepart_i > 2)\n            return false;\n        datepart[datepart_i] += date[i];\n    }\n    int d = std::stoi(datepart[1]);\n    int m = std::stoi(datepart[0]);\n    if(m < 1 || m > 12)\n        return false;\n    if(m == 2) {\n        if(d < 1 || d > 29)\n            return false;\n    }\n    else if(m == 1 || m == 3 || m == 5 || m == 7 || m == 8 || m == 10 || m == 12) {\n        if(d < 1 || d > 31)\n            return false;\n    }\n    else {\n        if(d < 1 || d > 30)\n            return false;\n    }\n    return true;",
    "grade-4": {
      "execution": 1
    },
    "5": "int dd, mm, yyyy;\n  if(sscanf(date.c_str(), \"%d-%d-%d\", &mm, &dd, &yyyy) != 3) return false;\n  if(yyyy < 0) return false;\n  switch(mm) {\n    case 1: case 3: case 5: case 7: case 8: case 10: case 12:\n      if(dd < 1 || dd > 31) return false;\n      break;\n    case 4: case 6: case 9: case 11:\n      if(dd < 1 || dd > 30) return false;\n      break;\n    case 2:\n      if(dd < 1 || dd > 29) return false;\n      break;\n    default:\n      return false;\n  }\n  return true;",
    "grade-5": {
      "execution": 1
    }
  },
  {
    "intent": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a non-empty list of positive integers. Return the greatest integer that is greater than \n// zero, and has a frequency greater than or equal to the value of the integer itself. \n// The frequency of an integer is the number of times it appears in the list.\n// If no such a value exist, return -1.\n// Examples:\n// search([4, 1, 2, 2, 3, 1]) == 2\n// search([1, 2, 2, 3, 3, 3, 4, 4, 4]) == 3\n// search([5, 5, 4, 4, 4]) == -1\nlong search(std::vector<long> lst) {\n",
    "task_id": "69",
    "prompt": "/*\nYou are given a non-empty vector of positive integers. Return the greatest integer that is greater than \nzero, and has a frequency greater than or equal to the value of the integer itself. \nThe frequency of an integer is the number of times it appears in the vector.\nIf no such a value exist, return -1.\nExamples:\n    search({4, 1, 2, 2, 3, 1}) == 2\n    search({1, 2, 2, 3, 3, 3, 4, 4, 4}) == 3\n    search({5, 5, 4, 4, 4}) == -1\n*/\n#include<stdio.h>\n#include<vector>\nusing namespace std;\nint search(vector<int> lst){\n",
    "simplified_intent": "You are given a non-empty list of positive integers. Return the greatest integer that is greater than zero, and has a frequency greater than or equal to the value of the integer itself. The frequency of an integer is the number of times it appears in the list. If no such a value exist, return -1.",
    "snippet": [
      "    vector<vector<int>> freq={};\n    int max=-1;\n    for (int i=0;i<lst.size();i++)\n    {\n        bool has=false;\n        for (int j=0;j<freq.size();j++)\n            if (lst[i]==freq[j][0]) \n            {\n            freq[j][1]+=1;\n            has=true;\n            if (freq[j][1]>=freq[j][0] and freq[j][0]>max) max=freq[j][0];\n            }\n        if (not(has)) \n        {\n        freq.push_back({lst[i],1});\n        if (max==-1 and lst[i]==1) max=1;\n        }\n    }\n    return max;\n}\n"
    ],
    "sample_from": {
      "0": "incoder",
      "1": "incoder",
      "2": "incoder",
      "3": "codex",
      "4": "codex",
      "5": "codex"
    },
    "0": "// Write your code here\n    // auto result = std::max_element(lst.begin(), lst.end());\n    auto result = std::max_element(lst.begin(), lst.end());\n    if(lst.front() == -1){\n        return -1;\n    }\n    long x = lst.front();\n    auto it = std::count_if(lst.begin(), lst.end(), [&](auto y){\n        return y > x;\n    });\n    if (it > lst.front())\n        return lst.front();\n    return lst.back();",
    "grade-0": {
      "execution": 0
    },
    "1": "long greatest;\n    long freq;\n    long i;\n    long max=0;\n    for(i=lst.size()-1;i>=0;i--)\n    {\n        max = lst[i];\n        if(lst.size()>0)\n        {\n            freq = lst.at(0);\n        }\n        else\n        {\n            freq = 1;\n        }\n        for(j=0;j<=freq;j++)\n        {\n            if(j==freq)\n            {\n                if(freq>lst.at(j))\n                {\n                    greatest = lst[j];\n                }\n                else\n                {\n                    greatest = lst[j];\n                }\n            }\n            else\n            {\n                if(lst.at(j)==max)\n                {\n                    if(freq>lst.at(j))\n                    {\n                        greatest = lst[j];\n                    }\n                }\n                else\n                {\n                    greatest = max;\n                }\n            }\n        }\n    }\n    return greatest;",
    "grade-1": {
      "execution": 0
    },
    "2": "sort(lst.begin(), lst.end()); \n    long ret = 0;\n    long i = 0;\n    while (i + 1 < lst.size() && lst[i] >= lst[i + 1]) ++i;\n    if (lst[i] >= 0) {\n        for (; i <= lst.size() - 1; ++i) {\n            if (lst[i] >= lst[i + 1]) {\n                ret = lst[i + 1];\n            }\n        }\n    }\n    return ret >= 0 ? ret : -1;",
    "grade-2": {
      "execution": 0
    },
    "3": "long largest = 0;\n\tstd::map<long, long> mp;\n\tfor (int i = 0; i < lst.size(); i++) {\n\t\tmp[lst[i]]++;\n\t\tif (mp[lst[i]] >= lst[i]) {\n\t\t\tlargest = std::max(largest, lst[i]);\n\t\t}\n\t}\n\treturn largest == 0 ? -1 : largest;",
    "grade-3": {
      "execution": 1
    },
    "4": "map<long,long> myMap;\n  map<long,long>::iterator it;\n  for(long i = 0; i < lst.size(); i++){\n    if(myMap.find(lst[i]) == myMap.end()){\n      myMap.insert(pair<long,long>(lst[i],1));\n    }\n    else{\n      myMap[lst[i]] += 1;\n    }\n  }\n  //now iterate through the list and see if a number exists that is the same value\n  //as the freq of a number\n  long greatest = -1;\n  long curr_greatest = -1;\n  long count = 0;\n  for(it = myMap.begin(); it != myMap.end(); it++){\n    if(it->first == it->second){\n      if(it->first > curr_greatest){\n        curr_greatest = it->first;\n      }\n      count++;\n    }\n  }\n  if(count != 0){\n    greatest = curr_greatest;\n  }\n  return greatest;",
    "grade-4": {
      "execution": 0
    },
    "5": "unordered_map<long, long> mp;\n    for(long i = 0; i < lst.size(); i++) {\n        mp[lst[i]]++;\n    }\n    long ans = -1;\n    for(long i = 0; i < lst.size(); i++) {\n        if(mp[lst[i]] >= lst[i]) {\n            ans = max(ans, lst[i]);\n        }\n    }\n    return ans;",
    "grade-5": {
      "execution": 0
    }
  },
  {
    "intent": "#include<assert.h>\n#include<bits/stdc++.h>\n// From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n// other and return them in order (smaller number, larger number).\n// >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n// (2.0, 2.2)\n// >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n// (2.0, 2.0)\nstd::tuple<float, float> find_closest_elements(std::vector<float> numbers) {\n",
    "task_id": "20",
    "prompt": "/*\nFrom a supplied vector of numbers (of length at least two) select and return two that are the closest to each\nother and return them in order (smaller number, larger number).\n>>> find_closest_elements({1.0, 2.0, 3.0, 4.0, 5.0, 2.2})\n(2.0, 2.2)\n>>> find_closest_elements({1.0, 2.0, 3.0, 4.0, 5.0, 2.0})\n(2.0, 2.0)\n*/\n#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\nvector<float> find_closest_elements(vector<float> numbers){\n",
    "simplified_intent": "From a supplied list of numbers (of length at least two) select and return two that are the closest to each other and return them in order (smaller number, larger number).",
    "snippet": [
      "    vector<float> out={};\n    for (int i=0;i<numbers.size();i++)\n    for (int j=i+1;j<numbers.size();j++)\n        if (out.size()==0 or abs(numbers[i]-numbers[j])<abs(out[0]-out[1]))\n            out={numbers[i],numbers[j]};\n    if (out[0]>out[1])\n        out={out[1],out[0]};\n    return out;\n}\n"
    ],
    "sample_from": {
      "0": "incoder",
      "1": "incoder",
      "2": "incoder",
      "3": "codex",
      "4": "codex",
      "5": "codex"
    },
    "0": "numbers.sort();\n    auto a = numbers.front();\n    auto b = numbers[0];\n    auto c = numbers[1];\n    for (size_t i = 1; i < numbers.size(); i++) {\n        auto d = numbers[i];\n        if (a > d) {\n            a = d;\n        } else if (b < d) {\n            b = d;\n        } else {\n            c = d;\n        }\n    }\n    return std::make_tuple(a, b, c);",
    "grade-0": {
      "execution": 0
    },
    "1": "if (numbers.empty()) {\n        return {0.0f, 0.0f};\n    }\n    auto max_abs_val = numbers.back();\n    auto min_abs_val = numbers[0];\n    for (float val : numbers) {\n        max_abs_val = std::max(max_abs_val, val);\n        min_abs_val = std::min(min_abs_val, val);\n    }\n    auto diff = max_abs_val - min_abs_val;\n    auto min_diff = std::min(diff, numbers.back() - numbers.front());\n    auto max_diff = std::max(diff, numbers.front() - numbers.back());\n    // If the difference between max and min is equal to zero, there are two numbers that are\n    // equidistant from each other. We take one of them arbitrarily.\n    if (min_diff == 0.0f && max_diff == 0.0f) {\n        auto first_val = numbers[0];\n        return {first_val, numbers[0]};\n    }\n    // If the difference between max and min is greater than zero, the two numbers are equidistant\n    // from each other. Take the smaller number as the smallest difference and the larger number\n    // as the largest difference.\n    if (max_diff > 0.0f && min_diff > 0.0f) {\n        if (diff > 0.0f) {\n            return {min_abs_val, numbers[0]};\n        } else {\n            return {numbers[0], max_abs_val};\n        }\n    }\n    // If the difference between max and min is less than zero, the two numbers are equidistant\n    // from each other. Take the larger number as the smallest difference and the smaller number\n    // as the largest difference.\n    if (max_diff < 0.0f && min_diff < 0.0f) {\n        if (diff < 0.0f) {\n            return {numbers[0], max_abs_val};\n        } else {\n            return {max_abs_val, min_abs_val};\n        }\n    }\n    // All other cases: numbers are equidistant from each other.\n    // Use the smaller number as the smallest difference and the larger number as the largest\n    // difference.\n    auto first_val = numbers[0];\n    return {numbers[0], numbers[0]};",
    "grade-1": {
      "execution": 0
    },
    "2": "std::vector<std::pair<float, float>> smallest;\n    std::vector<std::pair<float, float>> largest;\n\n    std::vector<std::pair<float, float>> sorted_elements;\n\n    for (const auto& num : numbers) {\n        sorted_elements.emplace_back(num, num);\n    }\n    std::sort(sorted_elements.begin(), sorted_elements.end(),\n              [&sorted_elements](std::pair<float, float> a, std::pair<float, float> b) {\n                  return a.second < b.second;\n              });\n\n    smallest.emplace_back(sorted_elements[0], sorted_elements[0]);\n    largest.emplace_back(sorted_elements[0], sorted_elements[0]);\n    for (size_t i = 1; i < sorted_elements.size() - 1; ++i) {\n        auto smaller = sorted_elements[i];\n        auto greater = sorted_elements[i - 1];\n        if (smaller.second < greater.second) {\n            smallest.emplace_back(smaller, greater);\n        } else {\n            largest.emplace_back(smaller, greater);\n        }\n    }\n\n    return std::make_tuple(std::get<0>(smallest), std::get<1>(largest));",
    "grade-2": {
      "execution": 0
    },
    "3": "assert(numbers.size() >= 2);\n    std::tuple<float, float> closest_tuple;\n    float min_difference = fabs(numbers[0] - numbers[1]);\n    closest_tuple = std::make_tuple(numbers[0], numbers[1]);\n    for (int i = 0; i < numbers.size(); i++) {\n        for (int j = i + 1; j < numbers.size(); j++) {\n            if (fabs(numbers[i] - numbers[j]) < min_difference) {\n                min_difference = fabs(numbers[i] - numbers[j]);\n                closest_tuple = std::make_tuple(numbers[i], numbers[j]);\n            }\n        }\n    }\n    return closest_tuple;",
    "grade-3": {
      "execution": 0
    },
    "4": "assert(numbers.size() >= 2);\n    float smallest_difference = numbers[1] - numbers[0];\n    int smallest_difference_index = 0;\n    for (int i = 1; i < numbers.size() - 1; i++) {\n        float difference = numbers[i + 1] - numbers[i];\n        if (difference < smallest_difference) {\n            smallest_difference = difference;\n            smallest_difference_index = i;\n        }\n    }\n    std::tuple<float, float> answer(numbers[smallest_difference_index], numbers[smallest_difference_index + 1]);\n    return answer;",
    "grade-4": {
      "execution": 0
    },
    "5": "// Write your implementation of the function here.\n  float min = std::numeric_limits<float>::max();\n  float closest1, closest2;\n  std::sort(numbers.begin(), numbers.end());\n  for (auto i = 0; i < numbers.size() - 1; i++) {\n    if (min > abs(numbers[i] - numbers[i + 1])) {\n      min = abs(numbers[i] - numbers[i + 1]);\n      closest1 = numbers[i];\n      closest2 = numbers[i + 1];\n    }\n  }\n  std::tuple<float, float> result(closest1, closest2);\n  return result;",
    "grade-5": {
      "execution": 0
    }
  },
  {
    "intent": "#include<assert.h>\n#include<bits/stdc++.h>\n// Return sorted unique common elements for two lists.\n// >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n// [1, 5, 653]\n// >>> common([5, 3, 2, 8], [3, 2])\n// [2, 3]\nstd::vector<long> common(std::vector<long> l1, std::vector<long> l2) {\n",
    "task_id": "58",
    "prompt": "/*\nReturn sorted unique common elements for two vectors.\n>>> common({1, 4, 3, 34, 653, 2, 5}, {5, 7, 1, 5, 9, 653, 121})\n{1, 5, 653}\n>>> common({5, 3, 2, 8}, {3, 2})\n{2, 3}\n\n*/\n#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nvector<int> common(vector<int> l1,vector<int> l2){\n",
    "simplified_intent": "Return sorted unique common elements for two lists.",
    "snippet": [
      "    vector<int> out={};\n    for (int i=0;i<l1.size();i++)\n        if (find(out.begin(),out.end(),l1[i])==out.end())\n            if (find(l2.begin(),l2.end(),l1[i])!=l2.end())\n                out.push_back(l1[i]);\n    sort(out.begin(),out.end());\n    return out;\n}\n"
    ],
    "sample_from": {
      "0": "incoder",
      "1": "incoder",
      "2": "incoder",
      "3": "codex",
      "4": "codex",
      "5": "codex"
    },
    "0": "std::vector<long> result;\n    std::set<long> l1(l1.begin(), l1.end());\n    std::set<long> l2(l2.begin(), l2.end());\n    l1.erase(l2.begin(), l2.end());\n    l2.erase(l1.begin(), l1.end());\n    for (long c : l1) {\n        if (l2.find(c) != l2.end()) {\n            result.push_back(c);\n        }\n    }\n    for (long c : l2) {\n        if (l1.find(c) != l1.end()) {\n            result.push_back(c);\n        }\n    }\n    std::sort(result.begin(), result.end());\n    return result;",
    "grade-0": {
      "execution": 0
    },
    "1": "std::vector<long> l3;\n    l3.reserve(l1.size() + l2.size());\n    l3.insert(l3.begin(), l1.begin(), l1.end());\n    for (auto i = l1.begin() + 1; i <= l1.end(); ++i) {\n        for (auto j = l2.begin() + 1; j <= l2.end(); ++j) {\n            if (*i == *j) {\n                l3.push_back(*i);\n                ++i;\n                ++j;\n            }\n        }\n    }\n    return l3;",
    "grade-1": {
      "execution": 0
    },
    "2": "std::vector<long> res(l1.size());\n    // If one list is empty, return other list.\n    if (l1.empty() || l2.empty())\n        return l2;\n    // If both lists are same size, return it.\n    if (l1.size() == l2.size())\n        return l1;\n    // If one is sorted, other one must be sorted, else they can't be common.\n    if (l1[l1.size() - 1] < l2[0])\n        return l2;\n    if (l2[l2.size() - 1] < l1[0])\n        return l1;\n    // Find the first element of first list.\n    auto it = std::find(l1.begin(), l1.end(), l1[0]);\n    long curr_idx = 0;\n    // Iterate over both lists until first common element is found.\n    while (it != l1.end()) {\n        // Check if first list current element is same as current element of second list.\n        if (l2[curr_idx] == *it) {\n            ++curr_idx;\n        }\n        ++it;\n    }\n    // Return only unique elements.\n    for (long i = curr_idx; i < l2.size(); ++i) {\n        res[i - curr_idx] = l2[i];\n    }\n    return res;",
    "grade-2": {
      "execution": 0
    },
    "3": "//remove duplicates\n    std::sort(l1.begin(), l1.end());\n    l1.erase(std::unique(l1.begin(), l1.end()), l1.end());\n    std::sort(l2.begin(), l2.end());\n    l2.erase(std::unique(l2.begin(), l2.end()), l2.end());\n    std::vector<long> result;\n    // compare both lists at one iteration\n    for (int i = 0, j = 0; i < l1.size() && j < l2.size();) {\n        if (l1[i] == l2[j]) {\n            result.push_back(l1[i]);\n            i++;\n            j++;\n        } else if (l1[i] < l2[j]) {\n            i++;\n        } else {\n            j++;\n        }\n    }\n    return result;",
    "grade-3": {
      "execution": 1
    },
    "4": "std::vector<long>::iterator it;\n\tstd::vector<long> commonVector;\n\tstd::sort(l1.begin(), l1.end());\n\tstd::sort(l2.begin(), l2.end());\n\t// create a set of elements of 1 vector\n\tstd::set<long> s1(l1.begin(), l1.end());\n\tfor (it = l2.begin(); it != l2.end(); it++) {\n\t\tif (s1.find(*it) != s1.end()) {\n\t\t\tcommonVector.push_back(*it);\n\t\t}\n\t}\n\treturn commonVector;",
    "grade-4": {
      "execution": 0
    },
    "5": "std::vector<long> result;\n\tint len1 = l1.size();\n\tint len2 = l2.size();\n\tint i = 0, j = 0;\n\twhile (i < len1 && j < len2) {\n\t\tif (l1[i] < l2[j]) {\n\t\t\ti++;\n\t\t} else if (l1[i] > l2[j]) {\n\t\t\tj++;\n\t\t} else {\n\t\t\tresult.push_back(l1[i]);\n\t\t\ti++;\n\t\t\tj++;\n\t\t}\n\t}\n\treturn result;",
    "grade-5": {
      "execution": 0
    }
  },
  {
    "intent": "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string 'text', return its md5 hash equivalent string.\n// If 'text' is an empty string, return None.\n// >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\nstd::optional<std::string> string_to_md5(std::string text) {\n",
    "task_id": "162",
    "prompt": "/*\nGiven a string 'text\", return its md5 hash equivalent string.\nIf 'text\" is an empty string, return None.\n\n>>> string_to_md5(\"Hello world\") == \"3e25960a79dbc69b674cd4ec67a72c62\"\n*/\n#include<stdio.h>\n#include<string>\n#include<openssl/md5.h>\nusing namespace std;\nstring string_to_md5(string text){\n",
    "simplified_intent": "Given a string 'text', return its md5 hash equivalent string. If 'text' is an empty string, return None.",
    "snippet": [
      "    unsigned char md[16];\n    if (text.length()==0) return \"None\";\n    MD5_CTX c;\n    int i;\n   MD5_Init(&c);\n   MD5_Update(&c, (unsigned char*)text.c_str(), text.length());\n    MD5_Final(md, &c);\n    string out_str=\"\";\n    for (int i=0;i<16;i++)\n        {\n            char w;\n            if (md[i]<160) w=48+md[i]/16;\n            else w=87+md[i]/16;\n            out_str=out_str+w;\n            if (md[i]%16<10) w=48+md[i]%16;\n            else w=87+md[i]%16;\n            out_str=out_str+w;\n        }\n    return out_str;\n}\n"
    ],
    "sample_from": {
      "0": "incoder",
      "1": "incoder",
      "2": "incoder",
      "3": "codex",
      "4": "codex",
      "5": "codex"
    },
    "0": "if (text.empty()) return std::nullopt;\n    char digest[MD5_DIGEST_LENGTH];\n    MD5(text.c_str(), text.length(), digest);\n    std::string result;\n    for (size_t i = 0; i < MD5_DIGEST_LENGTH; i++) {\n        result += std::to_string(digest[i] & 0xff);\n    }\n    return result;",
    "grade-0": {
      "execution": 0
    },
    "1": "if(!text) return std::nullopt;\n    std::string md5(const std::string &);\n    size_t md5_len = md5.size();\n    std::vector<unsigned char> hash_text(md5(text));\n    std::string ret{std::string((const char *)hash_text.data(), md5_len)};\n    return std::move(ret + \"\\n\");",
    "grade-1": {
      "execution": 0
    },
    "2": "// Convert the string to a binary string.\n  std::bitset<256> binary;\n  for (char c : text) {\n    binary.set(c);\n  }\n  // Get the hash code of the binary string.\n  int hashcode = int(binary.to_ulong());\n  // Hash the binary string to get the md5 hash equivalent string.\n  unsigned char md5sum[MD5_SIZE];\n  MD5(md5sum, sizeof(md5sum), &hashcode);\n  std::string md5hash(\"md5\");\n  for (int i = 0; i < MD5_SIZE; i++) {\n    md5hash += std::to_string(md5sum[i]);\n  }\n  return md5hash;",
    "grade-2": {
      "execution": 0
    },
    "3": "if (text.empty())\n\t\treturn std::nullopt;\n\tstd::size_t const len = text.length();\n\tstd::size_t const blocks = len / 64 + 1;\n\n\tuint32_t* M = new uint32_t[blocks * 16];\n\tmemset(M, 0, blocks * 16 * sizeof(uint32_t));\n\n\tfor (std::size_t i = 0; i < len; ++i)\n\t\tM[i / 4] |= (text[i] << ((i % 4) * 8));\n\tM[len / 4] |= 0x80 << ((len % 4) * 8);\n\n\tM[blocks * 16 - 2] = len * 8;\n\n\tuint32_t* H = new uint32_t[4];\n\tmemset(H, 0, 4 * sizeof(uint32_t));\n\tH[0] = 0x67452301;\n\tH[1] = 0xefcdab89;\n\tH[2] = 0x98badcfe;\n\tH[3] = 0x10325476;\n\n\tuint32_t* W = new uint32_t[16];\n\tmemset(W, 0, 16 * sizeof(uint32_t));\n\n\tuint32_t a, b, c, d, f, g, temp;\n\n\tfor (std::size_t i = 0; i < blocks; ++i) {\n\t\tfor (std::size_t t = 0; t < 16; ++t)\n\t\t\tW[t] = M[i * 16 + t];\n\n\t\ta = H[0];\n\t\tb = H[1];\n\t\tc = H[2];\n\t\td = H[3];\n\n\t\tfor (std::size_t t = 0; t < 64; ++t) {\n\t\t\tif (t < 16) {\n\t\t\t\tf = (b & c) | ((~b) & d);\n\t\t\t\tg = t;\n\t\t\t}\n\t\t\telse if (t < 32) {\n\t\t\t\tf = (d & b) | ((~d) & c);",
    "grade-3": {
      "execution": 0
    },
    "4": "// Your code here.\n  \n  char flag[(MD5_DIGEST_LENGTH*2)+1];\n  unsigned char digest[MD5_DIGEST_LENGTH];\n  MD5_CTX ctx;\n  MD5_Init(&ctx);\n  MD5_Update(&ctx, text.c_str(), text.length());\n  MD5_Final(digest, &ctx);\n  for (int i = 0; i < MD5_DIGEST_LENGTH; i++) {\n    sprintf(&flag[i*2], \"%02x\", (unsigned int)digest[i]);\n  }\n  return std::string(flag);",
    "grade-4": {
      "execution": 0
    },
    "5": "if (text.length() == 0) {\n        return std::nullopt;\n    }\n    std::string hash = std::to_string(std::hash<std::string>{}(text));\n    std::string res;\n    std::reverse(hash.begin(), hash.end());\n    while (hash.length() < 32) {\n        hash.append(\"0\");\n    }\n    for (char ch : hash) {\n        if (ch >= '0' && ch <= '9') {\n            res.push_back(ch);\n        } else {\n            int no = ch - 'A' + 10;\n            int dig1 = no % 16;\n            int dig2 = no / 16;\n            res.push_back(dig1 + '0');\n            res.push_back(dig2 + '0');\n        }\n    }\n    return res;",
    "grade-5": {
      "execution": 0
    }
  },
  {
    "intent": "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer n, return the count of the numbers of n-digit\n// positive integers that start or end with 1.\nlong starts_one_ends(long n) {\n",
    "task_id": "83",
    "prompt": "/*\nGiven a positive integer n, return the count of the numbers of n-digit\npositive integers that start or end with 1.\n*/\n#include<stdio.h>\nusing namespace std;\nint starts_one_ends(int n){\n",
    "simplified_intent": "Given a positive integer n, return the count of the numbers of n-digit positive integers that start or end with 1.",
    "snippet": [
      "    if (n<1) return 0;\n    if (n==1) return 1;\n    int out=18;\n    for (int i=2;i<n;i++)\n        out=out*10;\n    return out;\n}\n"
    ],
    "sample_from": {
      "0": "incoder",
      "1": "incoder",
      "2": "incoder",
      "3": "codex",
      "4": "codex",
      "5": "codex"
    },
    "0": "long count = 0;\n    long a = 1;\n    while (n > 0) {\n        long temp = n % 10;\n        if ((n / temp) == a)\n            ++count;\n        a <<= 1;\n    }\n    return count;",
    "grade-0": {
      "execution": 0
    },
    "1": "// Your code here\n  assert(n>0);\n  long ans=0;\n  while(n!=0){\n    ans=ans+(n%10);\n    n/=10;\n  }\n  if(ans==n){\n    return 1;\n  }\n  else{\n    return ans;\n  }",
    "grade-1": {
      "execution": 0
    },
    "2": "long count = 0;\n  // We start from n-1 and increase by 1 while we go deeper into the tree\n  // until we hit 1. At each step we increment count by 1.\n  while (n != 1) {\n    count += __builtin_popcount(n);\n    n /= 10;\n  }\n  return count;",
    "grade-2": {
      "execution": 0
    },
    "3": "std::vector<long> dp(n+1, 1);\n  for (long i = 1; i < n; ++i) {\n    for (long j = 1; j <= i; ++j) {\n      dp[i] += dp[j-1] * std::pow(10, (i-j));\n    }\n  }\n  return dp[n-1];",
    "grade-3": {
      "execution": 0
    },
    "4": "long long array[n + 1];\n  array[0] = 0;\n  array[1] = 1;\n  array[2] = 1;\n  array[3] = 1;\n  for (long i = 4; i <= n; i++) {\n    array[i] = array[i - 1] + array[i - 2];\n  }\n  return array[n];",
    "grade-4": {
      "execution": 0
    },
    "5": "assert(n > 0);\n  long counts = 0;\n  int i;\n  if (n == 1) {\n    return 1;\n  }\n  else {\n    for (i = 0; i < n; i++) {\n      counts += pow(9, i) * pow(10, n - i - 1);\n    }\n    return counts;\n  }",
    "grade-5": {
      "execution": 0
    }
  },
  {
    "intent": "#include<assert.h>\n#include<bits/stdc++.h>\n// Return True is list elements are monotonically increasing or decreasing.\n// >>> monotonic([1, 2, 4, 20])\n// True\n// >>> monotonic([1, 20, 4, 10])\n// False\n// >>> monotonic([4, 1, 0, -10])\n// True\nbool monotonic(std::vector<long> l) {\n",
    "task_id": "57",
    "prompt": "/*\nReturn true is vector elements are monotonically increasing or decreasing.\n>>> monotonic({1, 2, 4, 20})\ntrue\n>>> monotonic({1, 20, 4, 10})\nfalse\n>>> monotonic({4, 1, 0, -10})\ntrue\n*/\n#include<stdio.h>\n#include<vector>\nusing namespace std;\nbool monotonic(vector<float> l){\n",
    "simplified_intent": "Return True is list elements are monotonically increasing or decreasing.",
    "snippet": [
      "    int incr,decr;\n    incr=0;decr=0;\n    for (int i=1;i<l.size();i++)\n    {\n        if (l[i]>l[i-1]) incr=1;\n        if (l[i]<l[i-1]) decr=1;\n    }\n    if (incr+decr==2) return false;\n    return true;\n}\n"
    ],
    "sample_from": {
      "0": "incoder",
      "1": "incoder",
      "2": "incoder",
      "3": "codex",
      "4": "codex",
      "5": "codex"
    },
    "0": "if(l.size() == 1) return true;\n    if(l.size() <= 3) return true;\n    auto f1 = [](long i, long j) { return i > j; };\n    auto f2 = [](long i, long j) { return i < j; };\n    long x1 = l[0];\n    long x2 = l[1];\n    long x3 = l[2];\n    long x4 = l[3];\n\n    long min_f = f1(l[0], l[1]);\n    long max_f = f2(l[0], l[1]);\n\n    if(min_f > max_f)\n        return false;\n\n    for(long i = 2; i < l.size(); i++) {\n        long xi = l[i];\n\n        if(f1(xi, x1) > min_f) {\n            min_f = f1;\n            if(xi > x3) x3 = xi;\n            if(xi < x2) x2 = xi;\n        }\n        if(f2(xi, x2) > min_f) {\n            min_f = f2;\n            if(xi > x4) x4 = xi;\n            if(xi < x3) x3 = xi;\n        }\n    }\n    return true;",
    "grade-0": {
      "execution": 0
    },
    "1": "long long ans = INT_MAX;\n  for (long long i = 1; i < l.size(); ++i) {\n    if (l[i] < l[i-1]) ans = i;\n  }\n  return ans == INT_MAX;",
    "grade-1": {
      "execution": 0
    },
    "2": "for (long i = 1; i < l.size(); i++) {\n    if (l[i] < l[i - 1]) {\n      return false;\n    } else if (l[i] > l[i - 1]) {\n      return true;\n    }\n  }\n  return true;",
    "grade-2": {
      "execution": 0
    },
    "3": "if (l.size() <= 1)\n\t\treturn true;\n\tint i = 0;\n\tint j = l.size() - 1;\n\twhile (i <= j) {\n\t\tif (l[i] > l[i + 1])\n\t\t\treturn false;\n\t\ti++;\n\t}\n\twhile (j >= 0) {\n\t\tif (l[j] < l[j - 1])\n\t\t\treturn false;\n\t\tj--;\n\t}\n\treturn true;",
    "grade-3": {
      "execution": 0
    },
    "4": "long prev = l[0];\n\tlong curr = 0;\n\tint c = 0;\n\tfor (int i = 1; i < l.size(); i++) {\n\t\tcurr = l[i];\n\t\tif (prev > curr) {\n\t\t\tc--;\n\t\t}\n\t\telse if (prev < curr) {\n\t\t\tc++;\n\t\t}\n\t\tprev = curr;\n\t}\n\treturn (c == 0 || abs(c) == l.size() - 1);",
    "grade-4": {
      "execution": 0
    },
    "5": "bool isInc = false;\n\tbool isDec = false;\n\tint sz = l.size();\n\tfor (int i = 0; i < sz - 1; i++) {\n\t\tif (l[i] > l[i + 1]) {\n\t\t\tisDec = true;\n\t\t}\n\t\tif (l[i] < l[i + 1]) {\n\t\t\tisInc = true;\n\t\t}\n\t}\n\treturn !(isInc && isDec);",
    "grade-5": {
      "execution": 1
    }
  },
  {
    "intent": "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman(19) == 'xix'\n// >>> int_to_mini_roman(152) == 'clii'\n// >>> int_to_mini_roman(426) == 'cdxxvi'\nstd::string int_to_mini_roman(long number) {\n",
    "task_id": "156",
    "prompt": "/*\nGiven a positive integer, obtain its roman numeral equivalent as a string,\nand return it in lowercase.\nRestrictions: 1 <= num <= 1000\n\nExamples:\n>>> int_to_mini_roman(19) == \"xix\"\n>>> int_to_mini_roman(152) == \"clii\"\n>>> int_to_mini_roman(426) == \"cdxxvi\"\n*/\n#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\nstring int_to_mini_romank(int number){\n",
    "simplified_intent": "Given a positive integer, obtain its roman numeral equivalent as a string, and return it in lowercase. Restrictions: 1 <= num <= 1000",
    "snippet": [
      "    string current=\"\";\n    vector<string> rep={\"m\",\"cm\",\"d\",\"cd\",\"c\",\"xc\",\"l\",\"xl\",\"x\",\"ix\",\"v\",\"iv\",\"i\"};\n    vector<int> num={1000,900,500,400,100,90,50,40,10,9,5,4,1};\n    int pos=0;\n    while(number>0)\n    {\n        while (number>=num[pos])\n        {\n            current=current+rep[pos];\n            number-=num[pos];\n        }\n        if (number>0) pos+=1;\n    }\n    return current;\n}\n"
    ],
    "sample_from": {
      "0": "incoder",
      "1": "incoder",
      "2": "incoder",
      "3": "codex",
      "4": "codex",
      "5": "codex"
    },
    "0": "std::string roman = \"\";\n    int digit = 0;\n    do {\n        digit = number % 10;\n        roman = (roman[digit] + ((number / 10) % 10)) < 10 ? roman\n            : roman.insert(0, \"0\");\n        number /= 10;\n    } while (number > 0);\n    return roman;",
    "grade-0": {
      "execution": 0
    },
    "1": "assert(number <= 1000);\n  int digits = number / 1000;\n  number %= 1000;\n  int i = 1;\n  // Traverse the string.\n  while (digits) {\n    string temp = int_to_roman(number % 10);\n    i++;\n    if (temp.size() > 0) {\n      temp = temp + int_to_roman(i / 10) + int_to_roman(i % 10);\n    }\n    number /= 10;\n    digits = number / 1000;\n  }\n  return int_to_roman(number % 10) + int_to_roman(i / 10) + int_to_roman(i % 10);",
    "grade-1": {
      "execution": 0
    },
    "2": "assert(number > 0);\n    std::string mini_roman;\n    while (number >= 1000) {\n        mini_roman += int_to_mini_roman(number / 1000) + \"i\";\n        number %= 1000;\n    }\n    mini_roman += int_to_mini_roman(number) + \"m\";\n    return mini_roman;",
    "grade-2": {
      "execution": 0
    },
    "3": "std::string roman_numeral = \"\";\n    std::string roman_digits[] = {\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"};\n    int arabic_digits[] = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n    for (int i = 0; i < 13; i++) {\n        while (number >= arabic_digits[i]) {\n            number -= arabic_digits[i];\n            roman_numeral += roman_digits[i];\n        }\n    }\n    return roman_numeral;",
    "grade-3": {
      "execution": 1
    },
    "4": "std::string result{};\n    while (number >= 1000) {\n        result += \"m\";\n        number -= 1000;\n    }\n    if (number >= 900) {\n        result += \"cm\";\n        number -= 900;\n    }\n    if (number >= 500) {\n        result += \"d\";\n        number -= 500;\n    }\n    if (number >= 400) {\n        result += \"cd\";\n        number -= 400;\n    }\n    while (number >= 100) {\n        result += \"c\";\n        number -= 100;\n    }\n    if (number >= 90) {\n        result += \"xc\";\n        number -= 90;\n    }\n    if (number >= 50) {\n        result += \"l\";\n        number -= 50;\n    }\n    if (number >= 40) {\n        result += \"xl\";\n        number -= 40;\n    }\n    while (number >= 10) {\n        result += \"x\";\n        number -= 10;\n    }\n    if (number >= 9) {\n        result += \"ix\";\n        number -= 9;\n    }\n    if (number >= 5) {\n        result += \"v\";\n        number -= 5;\n    }\n    if (number >= 4) {\n        result += \"iv\";\n        number -= 4;\n    }\n    while (number >= 1) {\n        result += \"i\";\n        number -= 1;\n    }\n    return result;",
    "grade-4": {
      "execution": 1
    },
    "5": "std::string rom[] = {\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"};\n  int num[] = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n  std::string res = \"\";\n  for (int i = 0; i < 13; i++) {\n    while (number >= num[i]) {\n      number -= num[i];\n      res += rom[i];\n    }\n  }\n  return res;",
    "grade-5": {
      "execution": 1
    }
  },
  {
    "intent": "#include<assert.h>\n#include<bits/stdc++.h>\nunion Union_std_string_long{\n    std::string f0;\n    long f1;    Union_std_string_long(std::string _f0) : f0(_f0) {}\n    Union_std_string_long(long _f1) : f1(_f1) {}\n    ~Union_std_string_long() {}\n    bool operator==(Union_std_string_long u2) {\n        return f0 == u2.f0 || f1 == u2.f1 ;\n    }\n};\n// You are given two positive integers n and m, and your task is to compute the\n// average of the integers from n through m (including n and m). \n// Round the answer to the nearest integer and convert that to binary.\n// If n is greater than m, return -1.\n// Example:\n// rounded_avg(1, 5) => \"0b11\"\n// rounded_avg(7, 5) => -1\n// rounded_avg(10, 20) => \"0b1111\"\n// rounded_avg(20, 33) => \"0b11010\"\nUnion_std_string_long rounded_avg(long n, long m) {\n",
    "task_id": "103",
    "prompt": "/*\nYou are given two positive integers n and m, and your task is to compute the\naverage of the integers from n through m (including n and m). \nRound the answer to the nearest integer(smaller one) and convert that to binary.\nIf n is greater than m, return \"-1\".\nExample:\nrounded_avg(1, 5) => \"11\"\nrounded_avg(7, 5) => \"-1\"\nrounded_avg(10, 20) => \"1111\"\nrounded_avg(20, 33) => \"11010\"\n*/\n#include<stdio.h>\n#include<math.h>\n#include<string>\nusing namespace std;\nstring rounded_avg(int n,int m){\n",
    "simplified_intent": "You are given two positive integers n and m, and your task is to compute the average of the integers from n through m (including n and m). Round the answer to the nearest integer and convert that to binary. If n is greater than m, return -1.",
    "snippet": [
      "    if (n>m) return \"-1\";\n    int num=(m+n)/2;\n    string out=\"\";\n    while (num>0)\n    {\n        out=to_string(num%2)+out;\n        num=num/2;\n    }\n    return out;\n}\n"
    ],
    "sample_from": {
      "0": "incoder",
      "1": "incoder",
      "2": "incoder",
      "3": "codex",
      "4": "codex",
      "5": "codex"
    },
    "0": "if (m > n) {\n        return Union_std_string_long();\n    }\n    auto a = (n / 2) * 2;\n    auto b = (m / 2) * 2;\n    auto c = a + b;\n    auto d = n / 2;\n    auto e = m / 2;\n    if (c > d + e) return Union_std_string_long((d - c) / 2) + Union_std_string_long((e - b) / 2);\n    return Union_std_string_long((e - b) / 2) + Union_std_string_long((d - c) / 2);",
    "grade-0": {
      "execution": 0
    },
    "1": "Union_std_string_long u;\n    long i;\n    for(i = n;i<=m;i++){\n        u.f0 = std::to_string(i);\n        u.f1 = i;\n        if(u.f0 == std::to_string(n))\n            return u;\n    }\n    return -1;",
    "grade-1": {
      "execution": 0
    },
    "2": "assert(n >= 0 && m >= 0);\n    Union_std_string_long u(\"\");\n    std::string binary = \"\";\n    for(long i = 0; i <= m; i++){\n        if(n == i)\n            u += std::to_string(1);\n        else\n            u += std::to_string(n%2) + std::to_string(m-i%2);\n        n = (n - i) / 2;\n    }\n    std::reverse(u.f0.begin(), u.f0.end());\n    std::reverse(binary.begin(), binary.end());\n    u = Union_std_string_long(binary);\n    std::stringstream ss;\n    ss << u;\n    return ss.str();",
    "grade-2": {
      "execution": 0
    },
    "3": "if (n > m) {\n        return -1;\n    }\n    long sum = 0;\n    for (long i = n; i <= m; i++) {\n        sum += i;\n    }\n    long rounded_avg = std::round(sum / (m - n + 1));\n    std::stringstream sstream;\n    sstream << std::bitset<32>(rounded_avg);\n    std::string binary_as_string = sstream.str();\n    return \"0b\" + binary_as_string;",
    "grade-3": {
      "execution": 0
    },
    "4": "Union_std_string_long r = Union_std_string_long(std::string(\"0b0\"));\n    if (n > m) {\n        r = Union_std_string_long(long(-1));\n    } else {\n        long sum = n;\n        for (long i = n + 1; i <= m; i++) {\n            sum += i;\n        }\n        r = Union_std_string_long(std::string(\"0b\") + std::bitset<16>(sum / (m - n + 1)).to_string());\n    }\n    return r;",
    "grade-4": {
      "execution": 0
    },
    "5": "if (n > m) {\n        return Union_std_string_long((long)-1);\n    }\n    long sum = 0;\n    for (int i = n; i <= m; i++) {\n        sum += i;\n    }\n    long avg = sum / (m - n + 1);\n    std::string output = \"0b\";\n    std::vector<int> bits;\n    for (int i = 0; i < 32; i++) {\n        if (avg >= 1) {\n            bits.push_back(avg % 2);\n            avg /= 2;\n        } else {\n            bits.push_back(0);\n        }\n    }\n    for (int i = bits.size() - 1; i >= 0; i--) {\n        if (bits[i] == 1) {\n            output += \"1\";\n        } else {\n            output += \"0\";\n        }\n    }\n    output = output.substr(0, output.find_last_of(\"1\") + 1);\n    return Union_std_string_long(output);",
    "grade-5": {
      "execution": 0
    }
  },
  {
    "intent": "#include<assert.h>\n#include<bits/stdc++.h>\n// Return True if all numbers in the list l are below threshold t.\n// >>> below_threshold([1, 2, 4, 10], 100)\n// True\n// >>> below_threshold([1, 20, 4, 10], 5)\n// False\nbool below_threshold(std::vector<long> l, long t) {\n",
    "task_id": "52",
    "prompt": "/*\nReturn true if all numbers in the vector l are below threshold t.\n>>> below_threshold({1, 2, 4, 10}, 100)\ntrue\n>>> below_threshold({1, 20, 4, 10}, 5)\nfalse\n*/\n#include<stdio.h>\n#include<vector>\nusing namespace std;\nbool below_threshold(vector<int>l, int t){\n",
    "simplified_intent": "Return True if all numbers in the list l are below threshold t.",
    "snippet": [
      "    for (int i=0;i<l.size();i++)\n        if (l[i]>=t) return false;\n    return true;\n}\n"
    ],
    "sample_from": {
      "0": "incoder",
      "1": "incoder",
      "2": "incoder",
      "3": "codex",
      "4": "codex",
      "5": "codex"
    },
    "0": "std::sort(l.begin(), l.end());\n  return std::all_of(l.begin(), l.end(), [&](int i) { return i <= t; });",
    "grade-0": {
      "execution": 0
    },
    "1": "long long cnt = 0;\n    for (long i = 0; i < l.size(); ++i) {\n        if (l[i] > t) {\n            return false;\n        }\n        cnt += 1;\n    }\n    return (cnt > 0);",
    "grade-1": {
      "execution": 0
    },
    "2": "std::vector<long> tmp(l);\n    std::sort(tmp.begin(), tmp.end());\n    long prev = tmp[0];\n    for (long i : tmp) {\n        if (i - prev >= t) {\n            return false;\n        }\n        prev = i;\n    }\n    return true;",
    "grade-2": {
      "execution": 0
    },
    "3": "// Write your code here\n    int count = 0;\n    for(int i = 0; i < l.size(); i++){\n        if(l[i] < t){\n            count++;\n        }\n    }\n    if(count == l.size()){\n        return true;\n    }\n    else\n    {\n        return false;\n    }",
    "grade-3": {
      "execution": 1
    },
    "4": "for(long n : l) {\n        if(n >= t) {\n            return false;\n        }\n    }\n    return true;",
    "grade-4": {
      "execution": 1
    },
    "5": "for (int i = 0; i < l.size(); i++) {\n\t\tif (l[i] > t) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;",
    "grade-5": {
      "execution": 0
    }
  },
  {
    "intent": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that takes a string and returns True if the string\n// length is a prime number or False otherwise\n// Examples\n// prime_length('Hello') == True\n// prime_length('abcdcba') == True\n// prime_length('kittens') == True\n// prime_length('orange') == False\nbool prime_length(std::string string) {\n",
    "task_id": "82",
    "prompt": "/*\nWrite a function that takes a string and returns true if the string\nlength is a prime number or false otherwise\nExamples\nprime_length(\"Hello\") == true\nprime_length(\"abcdcba\") == true\nprime_length(\"kittens\") == true\nprime_length(\"orange\") == false\n*/\n#include<stdio.h>\n#include<string>\nusing namespace std;\nbool prime_length(string str){\n",
    "simplified_intent": "Write a function that takes a string and returns True if the string length is a prime number or False otherwise",
    "snippet": [
      "    int l,i;\n    l=str.length();\n    if (l<2) return false;\n    for (i=2;i*i<=l;i++)\n    if (l%i==0) return false;\n    return true;\n}\n"
    ],
    "sample_from": {
      "0": "incoder",
      "1": "incoder",
      "2": "incoder",
      "3": "codex",
      "4": "codex",
      "5": "codex"
    },
    "0": "int n = string.size();\n  // Prime number has only non-zero digits except at 0 and 2.\n  // We are checking for these two cases seperately as they are independent.\n  int n_digits_except_0 = n - (n / 10);\n  int n_digits_except_2 = n - (n / 100);\n  // If string has length 0 or 1 then return False else True is returned.\n  if (n_digits_except_0 < 2 || n_digits_except_2 <= 2) {\n    return false;\n  }\n  // Initialise the list of prime numbers\n  bool prime_number_list[n];\n  // Initialise the count of prime numbers\n  int count = 0;\n  // Start counting from 2 as we only care about odd numbers\n  for (int i = 3; i < n; i += 2) {\n    // Check if current digit of string is divisible by any prime number in list\n    // If so add that prime number to list\n    if (n_digits_except_0 % i == 0) {\n      prime_number_list[count++] = i;\n    }\n  }\n  // Return True if number of prime numbers in list matches with count\n  return count == prime_number_list[0];",
    "grade-0": {
      "execution": 0
    },
    "1": "int count = 0;\n    int len = string.length();\n    for (int i = 2; i <= len / 2; i++) {\n        if (len % i == 0) {\n            count++;\n        }\n    }\n    if (count == 0) {\n        return true;\n    }\n    return false;",
    "grade-1": {
      "execution": 0
    },
    "2": "int n = string.length();\n    if(n < 2) return false;\n    \n    for (int i = 1; i < n; i++) {\n        if(string[i] == '0') {\n            // If we have an even number of digits return False\n            if(i == 2) return false;\n            // Otherwise if we have a 0, return False\n            if(i == 1) return false;\n            // Otherwise return True\n            int j;\n            for(j = 2; j <= i/j; j++);\n            return j == i;\n        }\n    }\n    return true;",
    "grade-2": {
      "execution": 0
    },
    "3": "assert(string.length() >= 1);\n    std::vector<int> primes = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997};\n    int len = string.length();\n    return std::find(primes.begin(), primes.end(), len) != primes.end();",
    "grade-3": {
      "execution": 0
    },
    "4": "// Type your solution here\n    int len = string.length();\n    if(len==2 || len==3 || len==5 || len==7 || len==11 || len==13 || len==17 || len==19 || len==23)\n        return true;\n    else\n        return false;",
    "grade-4": {
      "execution": 1
    },
    "5": "return false;",
    "grade-5": {
      "execution": 0
    }
  },
  {
    "intent": "#include<assert.h>\n#include<bits/stdc++.h>\n// Check if in given list of numbers, are any two numbers closer to each other than\n// given threshold.\n// >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n// False\n// >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n// True\nbool has_close_elements(std::vector<float> numbers, float threshold) {\n",
    "task_id": "0",
    "prompt": "/*\nCheck if in given vector of numbers, are any two numbers closer to each other than\ngiven threshold.\n>>> has_close_elements({1.0, 2.0, 3.0}, 0.5)\nfalse\n>>> has_close_elements({1.0, 2.8, 3.0, 4.0, 5.0, 2.0}, 0.3)\ntrue\n*/\n#include<stdio.h>\n#include<vector>\n#include<math.h>\nusing namespace std;\nbool has_close_elements(vector<float> numbers, float threshold){\n",
    "simplified_intent": "Check if in given list of numbers, are any two numbers closer to each other than given threshold.",
    "snippet": [
      "    int i,j;\n    \n    for (i=0;i<numbers.size();i++)\n    for (j=i+1;j<numbers.size();j++)\n    if (abs(numbers[i]-numbers[j])<threshold)\n    return true;\n\n    return false;\n}\n\n"
    ],
    "sample_from": {
      "0": "incoder",
      "1": "incoder",
      "2": "incoder",
      "3": "codex",
      "4": "codex",
      "5": "codex"
    },
    "0": "int n = numbers.size();\n    bool ans = false;\n    for (int i = 0; i < n; i++) {\n        for (int j = i + 1; j < n; j++) {\n            float diff = abs(numbers[i] - numbers[j]);\n            ans = diff <= threshold;\n            if (ans) {\n                return ans;\n            }\n        }\n    }\n    return ans;",
    "grade-0": {
      "execution": 0
    },
    "1": "return std::any_of(numbers.begin(), numbers.end(), [threshold](float n) {\n        return std::abs(n - threshold) < threshold;\n    });",
    "grade-1": {
      "execution": 0
    },
    "2": "// Your code here\n    std::vector<int> vec1(numbers.size(), 0);\n    std::vector<int> vec2(numbers.size(), 0);\n    for (unsigned int i = 0; i < numbers.size(); ++i)\n    {\n        if (numbers[i] != 0)\n        {\n            int idx = abs(numbers[i] - threshold);\n            vec1[i] = idx;\n        }\n    }\n    for (unsigned int i = 0; i < numbers.size(); ++i)\n    {\n        if (numbers[i] != 0)\n        {\n            int idx = abs(numbers[i] - threshold);\n            vec2[i] = idx;\n        }\n    }\n    std::vector<bool> result(numbers.size(), true);\n    bool flag = true;\n    for (unsigned int i = 0; i < numbers.size(); ++i)\n    {\n        if (numbers[i] != 0)\n        {\n            int idx1 = vec1[i];\n            int idx2 = vec2[i];\n            if (idx1 != 0)\n            {\n                for (unsigned int j = 0; j < numbers.size(); ++j)\n                {\n                    if (j != i)\n                    {\n                        int idx3 = vec2[j];\n                        if (idx2 == 0)\n                        {\n                            if (idx3 != 0)\n                            {\n                                result[j] = false;\n                                flag = false;\n                                break;\n                            }\n                        }\n                        else if (idx1 == 0)\n                        {\n                            if (idx3 == 0)\n                            {\n                                result[j] = false;\n                                flag = false;\n                                break;\n                            }\n                        }\n                        else if (idx3 == 0)\n                        {\n                            result[j] = false;\n                            flag = false;\n                            break;\n                        }\n                        else if (idx2 > idx1)\n                        {\n                            result[j] = false;\n                            flag = false;\n                            break;\n                        }\n                        else if (idx2 < idx1)\n                        {\n                            result[j] = false;\n                            flag = false;\n                            break;\n                        }\n                        else if (idx1 > idx2)\n                        {\n                            result[j] = false;\n                            flag = false;\n                            break;\n                        }\n                        else if (idx1 < idx2)\n                        {\n                            result[j] = false;\n                            flag = false;\n                            break;\n                        }\n                    }\n                }\n            }\n            else if (idx2 != 0)\n            {\n                for (unsigned int j = 0; j < numbers.size(); ++j)\n                {\n                    if (j != i)\n                    {\n                        int idx3 = vec1[j];\n                        if (idx2 == 0)\n                        {\n                            if (idx3 != 0)\n                            {\n                                result[j] = false;\n                                flag = false;\n                                break;\n                            }\n                        }\n                        else if (idx1 == 0)\n                        {\n                            if (idx3 == 0)\n                            {\n                                result[j] = false;\n                                flag = false;\n                                break;\n                            }\n                        }\n                        else if (idx3 == 0)\n                        {\n                            result[j] = false;\n                            flag = false;\n                            break;\n                        }\n                        else if (idx",
    "grade-2": {
      "execution": 0
    },
    "3": "std::sort(numbers.begin(), numbers.end());\n    for (auto i = 0; i < numbers.size() - 1; i++) {\n        if (numbers[i+1] - numbers[i] < threshold) {\n            return true;\n        }\n    }\n    return false;",
    "grade-3": {
      "execution": 1
    },
    "4": "for (auto i : numbers) {\n        for (auto j : numbers) {\n            if (fabs(i - j) < threshold)\n                return true;\n        }\n    }\n    return false;",
    "grade-4": {
      "execution": 0
    },
    "5": "assert(threshold > 0);\n    assert(numbers.size() > 0);\n    std::sort(numbers.begin(), numbers.end());\n    float diff;\n    for (auto i = 0; i < numbers.size() - 1; i++) {\n        diff = numbers[i + 1] - numbers[i];\n        if (diff < threshold) {\n            return true;\n        }\n    }\n    return false;",
    "grade-5": {
      "execution": 1
    }
  },
  {
    "intent": "#include<assert.h>\n#include<bits/stdc++.h>\n// Task\n// We are given two strings s and c, you have to deleted all the characters in s that are equal to any character in c\n// then check if the result string is palindrome.\n// A string is called palindrome if it reads the same backward as forward.\n// You should return a tuple containing the result string and True/False for the check.\n// Example\n// For s = \"abcde\", c = \"ae\", the result should be ('bcd',False)\n// For s = \"abcdef\", c = \"b\"  the result should be ('acdef',False)\n// For s = \"abcdedcba\", c = \"ab\", the result should be ('cdedc',True)\nstd::tuple<std::string, bool> reverse_delete(std::string s, std::string c) {\n",
    "task_id": "112",
    "prompt": "/*\nTask\nWe are given two strings s and c, you have to deleted all the characters in s that are equal to any character in c\nthen check if the result string is palindrome.\nA string is called palindrome if it reads the same backward as forward.\nYou should return a vector containing the result string and \"True\"/\"False\" for the check.\nExample\nFor s = \"abcde\", c = \"ae\", the result should be (\"bcd\",\"False\")\nFor s = \"abcdef\", c = \"b\"  the result should be (\"acdef\",\"False\")\nFor s = \"abcdedcba\", c = \"ab\", the result should be (\"cdedc\",\"True\")\n*/\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\nvector<string> reverse_delete(string s,string c){\n",
    "simplified_intent": "Task We are given two strings s and c, you have to deleted all the characters in s that are equal to any character in c then check if the result string is palindrome. A string is called palindrome if it reads the same backward as forward. You should return a tuple containing the result string and True/False for the check.",
    "snippet": [
      "    string n=\"\";\n    for (int i=0;i<s.length();i++)\n    if (find(c.begin(),c.end(),s[i])==c.end())\n        n=n+s[i]; \n    if (n.length()==0) return {n,\"True\"};\n    string w(n.rbegin(),n.rend());\n    if (w==n) return {n,\"True\"};\n    return {n,\"False\"};\n}\n"
    ],
    "sample_from": {
      "0": "incoder",
      "1": "incoder",
      "2": "incoder",
      "3": "codex",
      "4": "codex",
      "5": "codex"
    },
    "0": "// your code goes here\n    for(int i=0;i<s.size();i++){\n        if(s[i] == c[i]){\n            s.erase(s.begin()+i);\n            i--;\n        }\n    }\n    std::string result = s;\n    if(s == result){\n        return std::make_tuple(result,true);\n    }\n    return std::make_tuple(result,false);",
    "grade-0": {
      "execution": 0
    },
    "1": "std::string ans = s;\n\t// If there is no common characters\n\tif (s.size() == 0 || c.size() == 0) {\n\t\treturn std::make_tuple(ans, false);\n\t}\n\t// If common characters are not same\n\tif (s.size() != c.size()) {\n\t\treturn std::make_tuple(ans, false);\n\t}\n\tauto it = s.begin();\n\tauto end = s.end();\n\tauto startIterator = c.begin();\n\tauto endIterator = c.end();\n\tbool flag = true;\n\t// For every character in common characters, check if it exists in ans string\n\twhile (it != end && startIterator != endIterator) {\n\t\twhile (it != end && startIterator != endIterator && it == s.end()) {\n\t\t\tit = s.begin();\n\t\t\tstartIterator = c.begin();\n\t\t}\n\t\t\n\t\tif (startIterator == endIterator) {\n\t\t\tbreak;\n\t\t}\n\n\t\tif (*it == *startIterator) {\n\t\t\tans = ans.erase(it, ++it);\n\t\t\tstartIterator = startIterator + 1;\n\t\t\tendIterator = endIterator + 1;\n\t\t} else {\n\t\t\tit = s.erase(it);\n\t\t\tstartIterator = startIterator + 1;\n\t\t\tendIterator = endIterator + 1;\n\t\t}\n\t}\n\n\tif (it == end) {\n\t\treturn std::make_tuple(ans, false);\n\t} else {\n\t\treturn std::make_tuple(ans, true);\n\t}",
    "grade-1": {
      "execution": 0
    },
    "2": "// code here\n    if(s.size() == 0 || c.size() == 0)\n    {\n        return std::make_tuple(\"\", false);\n    }\n    \n    if(s.size() != c.size())\n    {\n        return std::make_tuple(\"\", false);\n    }\n    \n    if(s[0] != c[0])\n    {\n        return std::make_tuple(\"\", false);\n    }\n    \n    int start = 0, end = s.size();\n    \n    while(start <= end)\n    {\n        if(s[start] != c[end])\n        {\n            end = start - 1;\n        }\n        else if(s[start] == c[end])\n        {\n            start = start + 1;\n        }\n        else if(s[start] != c[end])\n        {\n            end = end - 1;\n        }\n    }\n    \n    if(s[start] == c[end])\n    {\n        return std::make_tuple(s, true);\n    }\n    else if(s[start] != c[end])\n    {\n        return std::make_tuple(s.substr(start, end - start + 1), false);\n    }",
    "grade-2": {
      "execution": 0
    },
    "3": "std::string result;\n    std::for_each(s.begin(), s.end(), [&result, &c](char a) {\n        if (c.find(a) == std::string::npos)\n            result += a;\n    });\n    return std::make_tuple(result, result == std::string(result.rbegin(), result.rend()));",
    "grade-3": {
      "execution": 1
    },
    "4": "std::set<char> set;\n\tfor (auto elem : c) {\n\t\tset.insert(elem);\n\t}\n\tstd::string res = \"\";\n\tfor (auto elem : s) {\n\t\tif (set.find(elem) == set.end()) {\n\t\t\tres += elem;\n\t\t}\n\t}\n\tbool is_palindrome = true;\n\tint left = 0;\n\tint right = res.size() - 1;\n\twhile (left < right) {\n\t\tif (res[left] != res[right]) {\n\t\t\tis_palindrome = false;\n\t\t\tbreak;\n\t\t}\n\t\tleft++;\n\t\tright--;\n\t}\n\treturn std::make_tuple(res, is_palindrome);",
    "grade-4": {
      "execution": 1
    },
    "5": "string res;\n  bool tf=true;\n  for(auto x:s){\n    if(c.find(x)==string::npos){\n      res.push_back(x);\n    }\n  }\n  if(res!=string(res.rbegin(),res.rend())){\n    tf=false;\n  }\n  return make_tuple(res,tf);",
    "grade-5": {
      "execution": 0
    }
  },
  {
    "intent": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return True if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// is_nested('[[]]') \u279e True\n// is_nested('[]]]]]]][[[[[]') \u279e False\n// is_nested('[][]') \u279e False\n// is_nested('[]') \u279e False\n// is_nested('[[][]]') \u279e True\n// is_nested('[[]][[') \u279e True\nbool is_nested(std::string string) {\n",
    "task_id": "132",
    "prompt": "/*\nCreate a function that takes a string as input which contains only square brackets.\nThe function should return true if and only if there is a valid subsequence of brackets\nwhere at least one bracket in the subsequence is nested.\n\nis_nested(\"[[]]\") \u279e true\nis_nested(\"[]]]]]]][[[[[]\") \u279e false\nis_nested(\"[][]\") \u279e false\nis_nested(\"[]\") \u279e false\nis_nested(\"[[][]]\") \u279e true\nis_nested(\"[[]][[\") \u279e true\n*/\n#include<stdio.h>\n#include<string>\nusing namespace std;\nbool is_nested(string str){\n",
    "simplified_intent": "Create a function that takes a string as input which contains only square brackets. The function should return True if and only if there is a valid subsequence of brackets where at least one bracket in the subsequence is nested.",
    "snippet": [
      "    int count=0,maxcount=0;\n    for (int i=0;i<str.length();i++)\n    {\n        if (str[i]=='[') count+=1;\n        if (str[i]==']') count-=1;\n        if (count<0) count=0;\n        if (count>maxcount) maxcount=count;\n        if (count<=maxcount-2) return  true;\n    }\n    return false;\n}\n"
    ],
    "sample_from": {
      "0": "incoder",
      "1": "incoder",
      "2": "incoder",
      "3": "codex",
      "4": "codex",
      "5": "codex"
    },
    "0": "int size = string.length();\n    for (int i = 0; i < size; i++) {\n        if (string[i] == '[' && string[i + 1] == '[' && string[i + 2] == ']' && string[i + 3] == ']') {\n            return true;\n        }\n    }\n    return false;",
    "grade-0": {
      "execution": 0
    },
    "1": "int brackets = 0;\n    for (int i = 0; i < string.size(); i++) {\n        if (string[i] == '[') {\n            brackets++;\n        } else if (string[i] == ']') {\n            if (brackets == 0) {\n                return false;\n            }\n            brackets--;\n        }\n    }\n    return brackets == 0;",
    "grade-1": {
      "execution": 0
    },
    "2": "std::stack<char> s;\n   s.push('[');\n   for(char c : string){\n      if(c=='[' || c=='('){\n         s.push(c);\n      } else if(c==']' || c==')'){\n         if(s.empty()) return false;\n         char top = s.top();\n         s.pop();\n         if(top==c){\n            s.push(c);\n         } else {\n            return false;\n         }\n      }\n   }\n   return true;",
    "grade-2": {
      "execution": 0
    },
    "3": "std::stack<char> S;\n\tfor (int i = 0; i < string.length(); i++) {\n\t\tif (string[i] == '[') {\n\t\t\tS.push(string[i]);\n\t\t}\n\t\telse if (string[i] == ']') {\n\t\t\tif (S.empty()) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tS.pop();\n\t\t}\n\t}\n\treturn S.empty();",
    "grade-3": {
      "execution": 0
    },
    "4": "int check=0;\n\tfor(int i=0;i<string.length();i++)\n\t{\n\t\t//count the occurance of [ and ]\n\t\tif(string[i]=='[')\n\t\t\tcheck++;\n\t\telse if(string[i]==']')\n\t\t\tcheck--;\n\t\t//if ] occur more then [ then we cant have valid subsequence\n\t\tif(check<0)\n\t\t\treturn false;\n\t}\n\treturn true;",
    "grade-4": {
      "execution": 0
    },
    "5": "int left = 0;\n    int right = 0;\n    for(int i = 0; i < string.length(); i++){\n        if(string[i] == '[')\n            left++;\n        else if(string[i] == ']')\n            right++;\n    }\n    if(left > right)\n        return true;\n    else\n        return false;",
    "grade-5": {
      "execution": 0
    }
  },
  {
    "intent": "#include<assert.h>\n#include<bits/stdc++.h>\n// This function takes a list l and returns a list l' such that\n// l' is identical to l in the odd indicies, while its values at the even indicies are equal\n// to the values of the even indicies of l, but sorted.\n// >>> sort_even([1, 2, 3])\n// [1, 2, 3]\n// >>> sort_even([5, 6, 3, 4])\n// [3, 6, 5, 4]\nstd::vector<long> sort_even(std::vector<long> l) {\n",
    "task_id": "37",
    "prompt": "/*\nThis function takes a vector l and returns a vector l' such that\nl' is identical to l in the odd indicies, while its values at the even indicies are equal\nto the values of the even indicies of l, but sorted.\n>>> sort_even({1, 2, 3})\n{1, 2, 3}\n>>> sort_even({5, 6, 3, 4})\n{3, 6, 5, 4}\n*/\n#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nvector<float> sort_even(vector<float> l){\n",
    "simplified_intent": "This function takes a list l and returns a list l' such that l' is identical to l in the odd indicies, while its values at the even indicies are equal to the values of the even indicies of l, but sorted.",
    "snippet": [
      "    vector<float> out={};\n    vector<float> even={};\n    for (int i=0;i*2<l.size();i++)\n        even.push_back(l[i*2]);\n    sort(even.begin(),even.end());\n    for (int i=0;i<l.size();i++)\n    {\n        if (i%2==0) out.push_back(even[i/2]);\n        if (i%2==1) out.push_back(l[i]);\n    }\n    return out;\n}\n"
    ],
    "sample_from": {
      "0": "incoder",
      "1": "incoder",
      "2": "incoder",
      "3": "codex",
      "4": "codex",
      "5": "codex"
    },
    "0": "std::vector<long> l1;\n  l1 = l;\n  std::vector<long> l2(l.size());\n  for (int i = 0; i < l.size(); i++) {\n    if (i % 2 != 0) {\n      l2[i] = l[i];\n    }\n  }\n  sort(l2.begin(), l2.end());\n  for (int i = 0; i < l.size(); i++) {\n    if (i % 2 != 0) {\n      l1[i] = l2[i];\n    }\n  }\n  return l1;",
    "grade-0": {
      "execution": 0
    },
    "1": "std::vector<long> l2(l.size());\n    std::iota(l2.begin(), l2.end(), 0);\n    for (int i = 0; i < l.size(); ++i) {\n        l2[i] = l[l2[i]];\n    }\n\n    // Find first even index\n    for (int i = 0; i < l2.size(); ++i) {\n        if (l2[i] % 2 == 0) {\n            std::swap(l2[i], l2[i + int(l2.size() / 2)]);\n        }\n    }\n    l2.resize(l2.size());\n\n    // Move even indices up one\n    int pos = 0;\n    for (int i = 0; i < l2.size(); ++i) {\n        if (l2[i] % 2 == 0) {\n            std::swap(l2[i], l2[i + 1 + pos]);\n            pos += 1;\n        }\n    }\n    l2.resize(l2.size());\n\n    return l2;",
    "grade-1": {
      "execution": 0
    },
    "2": "std::vector<long> l_even, l_odd;\n    for(long i : l) {\n        l_even.push_back(i);\n    }\n    for(long i : l) {\n        if(i % 2 == 0) {\n            l_odd.push_back(i);\n        } else {\n            while(l_even.size() > 0 && l_even.back() <= i) {\n                l_even.pop_back();\n            }\n        }\n    }\n    return l_odd;",
    "grade-2": {
      "execution": 0
    },
    "3": "std::vector<long> l2;\n    std::vector<long> l3;\n    for (int i = 0; i < l.size(); i++) {\n        if (i % 2 == 0) {\n            l2.push_back(l[i]);\n        } else {\n            l3.push_back(l[i]);\n        }\n    }\n    std::sort(l3.begin(), l3.end());\n    for (int i = 0; i < l3.size(); i++) {\n        l2.push_back(l3[i]);\n    }\n    return l2;",
    "grade-3": {
      "execution": 0
    },
    "4": "std::vector<long> sorted;\n\tfor (long i = 0; i < l.size(); i++) {\n\t\tif (i % 2 == 0) {\n\t\t\tsorted.push_back(l[i]);\n\t\t}\n\t\telse {\n\t\t\tstd::vector<long> temp = { l[i] };\n\t\t\tfor (long j = i; j < l.size(); j++) {\n\t\t\t\tif (j % 2 == 1) {\n\t\t\t\t\ttemp.push_back(l[j]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tsort(temp.begin(), temp.end());\n\t\t\tfor (long j = 0; j < temp.size(); j++) {\n\t\t\t\tsorted.push_back(temp[j]);\n\t\t\t}\n\t\t\ti += temp.size() - 1;\n\t\t}\n\t}\n\treturn sorted;",
    "grade-4": {
      "execution": 0
    },
    "5": "std::vector<long> sorted;\n\tstd::vector<long> odds;\n\tstd::vector<long> evens;\n\tfor (int i = 0; i < l.size(); i++) {\n\t\tif (i % 2 == 0) {\n\t\t\todds.push_back(l[i]);\n\t\t}\n\t\telse {\n\t\t\tevens.push_back(l[i]);\n\t\t}\n\t}\n\tstd::sort(evens.begin(), evens.end());\n\tfor (int i = 0; i < odds.size(); i++) {\n\t\tsorted.push_back(odds[i]);\n\t\tsorted.push_back(evens[i]);\n\t}\n\treturn sorted;",
    "grade-5": {
      "execution": 0
    }
  },
  {
    "intent": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes 3 numbers.\n// Returns true if one of the numbers is equal to the sum of the other two, and all numbers are integers.\n// Returns false in any other cases.\n// Examples\n// any_int(5, 2, 7) \u279e True\n// any_int(3, 2, 2) \u279e False\n// any_int(3, -2, 1) \u279e True\n// any_int(3.6, -2.2, 2) \u279e False\nbool any_int(float x, float y, float z) {\n",
    "task_id": "92",
    "prompt": "/*\nCreate a function that takes 3 numbers.\nReturns true if one of the numbers is equal to the sum of the other two, and all numbers are integers.\nReturns false in any other cases.\n\nExamples\nany_int(5, 2, 7) \u279e true\n\nany_int(3, 2, 2) \u279e false\n\nany_int(3, -2, 1) \u279e true\n\nany_int(3.6, -2.2, 2) \u279e false\n\n\n\n*/\n#include<stdio.h>\n#include<math.h>\nusing namespace std;\nbool any_int(float a,float b,float c){\n",
    "simplified_intent": "Create a function that takes 3 numbers. Returns true if one of the numbers is equal to the sum of the other two, and all numbers are integers. Returns false in any other cases.",
    "snippet": [
      "    if (round(a)!=a) return false;\n    if (round(b)!=b) return false;\n    if (round(c)!=c) return false;\n    if (a+b==c or a+c==b or b+c==a) return true;\n    return false;\n}\n"
    ],
    "sample_from": {
      "0": "incoder",
      "1": "incoder",
      "2": "incoder",
      "3": "codex",
      "4": "codex",
      "5": "codex"
    },
    "0": "int a, b;\n    a = ceil(log10(x));\n    b = ceil(log10(y));\n    if (a == 0 && b == 0) {\n        a = 1;\n        b = 1;\n    }\n    return ceil(x / pow(x, a)) == ceil(y / pow(y, b)) == z;",
    "grade-0": {
      "execution": 0
    },
    "1": "if(x>0 && y>0 && z>0){\n       return x == y+ z;\n    }\n    return false;",
    "grade-1": {
      "execution": 0
    },
    "2": "int a = x;\n    int b = y;\n    int c = z;\n    int sum = (a + b + c);\n    int num = std::max(std::min(a, b), std::min(c, sum));\n    return num == sum;",
    "grade-2": {
      "execution": 0
    },
    "3": "if (x == y + z || y == x + z || z == x + y)\n\t\treturn true;\n\telse\n\t\treturn false;",
    "grade-3": {
      "execution": 0
    },
    "4": "if(x==y+z||y==x+z||z==x+y)\n        return true;\n    else\n        return false;",
    "grade-4": {
      "execution": 0
    },
    "5": "if (x + y == z || x + z == y || y + z == x) {\n    return true;\n  }\n  return false;",
    "grade-5": {
      "execution": 0
    }
  },
  {
    "intent": "#include<assert.h>\n#include<bits/stdc++.h>\n// In this Kata, you have to sort an array of non-negative integers according to\n// number of ones in their binary representation in ascending order.\n// For similar number of ones, sort based on decimal value.\n// It must be implemented like this:\n// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n// >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n// >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nstd::vector<long> sort_array(std::vector<long> arr) {\n",
    "task_id": "116",
    "prompt": "/*\nIn this Kata, you have to sort a vector of non-negative integers according to\nnumber of ones in their binary representation in ascending order.\nFor similar number of ones, sort based on decimal value.\n\nIt must be implemented like this:\n>>> sort_vector({1, 5, 2, 3, 4}) == {1, 2, 3, 4, 5}\n>>> sort_vector({-2, -3, -4, -5, -6}) == {-6, -5, -4, -3, -2}\n>>> sort_vector({1, 0, 2, 3, 4}) == {0, 1, 2, 3, 4}\n*/\n#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nvector<int> sort_array(vector<int> arr){\n",
    "simplified_intent": "In this Kata, you have to sort an array of non-negative integers according to number of ones in their binary representation in ascending order. For similar number of ones, sort based on decimal value. It must be implemented like this:",
    "snippet": [
      "    vector<int> bin={};\n    int m;\n\n    for (int i=0;i<arr.size();i++)\n    {\n        int b=0,n=abs(arr[i]);\n        while (n>0)\n        {\n            b+=n%2;n=n/2;\n        }\n        bin.push_back(b);\n    }\n    for (int i=0;i<arr.size();i++)\n    for (int j=1;j<arr.size();j++)\n    if (bin[j]<bin[j-1] or (bin[j]==bin[j-1] and arr[j]<arr[j-1]))\n    {\n        m=arr[j];arr[j]=arr[j-1];arr[j-1]=m;\n        m=bin[j];bin[j]=bin[j-1];bin[j-1]=m;\n    }\n    return arr;\n}\n"
    ],
    "sample_from": {
      "0": "incoder",
      "1": "incoder",
      "2": "incoder",
      "3": "codex",
      "4": "codex",
      "5": "codex"
    },
    "0": "std::sort(arr.begin(), arr.end(), [](long l, long r){\n        return count_ones(l) > count_ones(r);\n    });\n    return arr;",
    "grade-0": {
      "execution": 0
    },
    "1": "long one = 0;\n  long two = 0;\n  for (long i : arr) {\n    one += i;\n    two += i % 2;\n  }\n  std::sort(arr.begin(), arr.end());\n  std::vector<long> res(arr.begin(), arr.end());\n  for (long i = 0; i < res.size(); i++) {\n    long s = i;\n    while (s == 0) {\n      s += two;\n      two += two;\n    }\n    long x = res[s];\n    res[s] = res[i];\n    res[i] = x;\n  }\n  return res;",
    "grade-1": {
      "execution": 0
    },
    "2": "// Write your code here\n    std::sort(arr.begin(), arr.end(), [](const long& a, const long& b) {\n        return a > b;\n    });\n    \n    std::sort(arr.begin(), arr.end(), [](const long& a, const long& b) {\n        return std::bitset<sizeof(a) * 8>(a).count() > std::bitset<sizeof(a) * 8>(b).count();\n    });\n    return arr;",
    "grade-2": {
      "execution": 0
    },
    "3": "//your code here\n  std::vector<long>::iterator it;\n  std::vector<long> res;\n  std::vector<long> binarr;\n  std::vector<long> sorted = arr;\n  std::cout << \"Initial array: \";\n  for (it = arr.begin(); it != arr.end(); it++) {\n    std::cout << *it << \" \";\n  }\n  std::cout << std::endl;\n  std::sort(sorted.begin(), sorted.end());\n  std::cout << \"Sorted array: \";\n  for (it = sorted.begin(); it != sorted.end(); it++) {\n    std::cout << *it << \" \";\n  }\n  std::cout << std::endl;\n  for (it = sorted.begin(); it != sorted.end(); it++) {\n    binarr.push_back(std::bitset<8>(*it).count());\n  }\n  std::cout << \"number of ones: \";\n  for (it = binarr.begin(); it != binarr.end(); it++) {\n    std::cout << *it << \" \";\n  }\n  std::cout << std::endl;\n  for (it = binarr.begin(); it != binarr.end(); it++) {\n    res.push_back(sorted[it - binarr.begin()]);\n  }\n  std::cout << \"sorted array: \";\n  for (it = res.begin(); it != res.end(); it++) {\n    std::cout << *it << \" \";\n  }\n  std::cout << std::endl;\n  return res;",
    "grade-3": {
      "execution": 0
    },
    "4": "std::vector<long> vec;\n  vec.reserve(arr.size());\n  std::map<int,std::vector<long>> myMap;\n  for(size_t i = 0; i < arr.size(); i++) {\n    int count = 0;\n    long num = arr[i];\n    while(num != 0) {\n      if(num % 2 == 1)\n        count++;\n      num = num/2;\n    }\n    myMap[count].push_back(arr[i]);\n  }\n  for(auto &x : myMap) {\n    sort(x.second.begin(), x.second.end());\n    for(size_t i = 0; i < x.second.size(); i++) {\n      vec.push_back(x.second[i]);\n    }\n  }\n  return vec;",
    "grade-4": {
      "execution": 0
    },
    "5": "std::vector<std::pair<int, long>> v;\n  for (auto i : arr) {\n    int num_ones = 0;\n    for (long n = i; n > 0; n >>= 1) {\n      if (n & 1) num_ones++;\n    }\n    v.push_back(std::make_pair(num_ones, i));\n  }\n  std::sort(v.begin(), v.end());\n  std::vector<long> answer;\n  for (auto p : v) {\n    answer.push_back(p.second);\n  }\n  return answer;",
    "grade-5": {
      "execution": 0
    }
  },
  {
    "intent": "#include<assert.h>\n#include<bits/stdc++.h>\n// Return only positive numbers in the list.\n// >>> get_positive([-1, 2, -4, 5, 6])\n// [2, 5, 6]\n// >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n// [5, 3, 2, 3, 9, 123, 1]\nstd::vector<long> get_positive(std::vector<long> l) {\n",
    "task_id": "30",
    "prompt": "/*\nReturn only positive numbers in the vector.\n>>> get_positive({-1, 2, -4, 5, 6})\n{2, 5, 6}\n>>> get_positive({5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10})\n{5, 3, 2, 3, 9, 123, 1}\n*/\n#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\nvector<float> get_positive(vector<float> l){\n",
    "simplified_intent": "Return only positive numbers in the list.",
    "snippet": [
      "    vector<float> out={};\n    for (int i=0;i<l.size();i++)\n        if (l[i]>0) out.push_back(l[i]);\n    return out;\n}\n"
    ],
    "sample_from": {
      "0": "incoder",
      "1": "incoder",
      "2": "incoder",
      "3": "codex",
      "4": "codex",
      "5": "codex"
    },
    "0": "std::sort(l.begin(), l.end());\n    auto it = l.begin();\n    std::vector<long> res;\n    while (it != l.end() && it->size() > 0) {\n        auto current = std::find(it, l.end(), 0);\n        res.push_back(std::distance(it, current));\n        it = current;\n    }\n    return res;",
    "grade-0": {
      "execution": 0
    },
    "1": "std::vector<long> res;\n    for (auto x : l) {\n        if (x >= 0) {\n            res.push_back(x);\n        }\n    }\n    return res;",
    "grade-1": {
      "execution": 0
    },
    "2": "std::sort(l.begin(), l.end());\n    std::vector<long> r;\n    auto begin = std::unique(l.begin(), l.end());\n    auto last = std::unique(begin, l.end());\n    std::copy(begin, last, std::back_inserter(r));\n    return r;",
    "grade-2": {
      "execution": 0
    },
    "3": "std::vector<long> positive_list;\n  for (int i = 0; i < l.size(); i++) {\n    if (l[i] > 0) {\n      positive_list.push_back(l[i]);\n    }\n  }\n  return positive_list;",
    "grade-3": {
      "execution": 1
    },
    "4": "// Todo: Code it up!\n    std::vector<long> result;\n    for(int i=0;i<l.size();i++){\n        if(l[i]>0){\n            result.push_back(l[i]);\n        }\n    }\n    return result;",
    "grade-4": {
      "execution": 1
    },
    "5": "std::vector<long> vec;\n    for(long i=0;i<l.size();i++){\n        if(l[i]>0){\n            vec.push_back(l[i]);\n        }\n    }\n    return vec;",
    "grade-5": {
      "execution": 1
    }
  },
  {
    "intent": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that takes a string and returns an ordered version of it.\n// Ordered version of string, is a string where all words (separated by space)\n// are replaced by a new word where all the characters arranged in\n// ascending order based on ascii value.\n// Note: You should keep the order of words and blank spaces in the sentence.\n// For example:\n// anti_shuffle('Hi') returns 'Hi'\n// anti_shuffle('hello') returns 'ehllo'\n// anti_shuffle('Hello World!!!') returns 'Hello !!!Wdlor'\nstd::string anti_shuffle(std::string s) {\n",
    "task_id": "86",
    "prompt": "/*\nWrite a function that takes a string and returns an ordered version of it.\nOrdered version of string, is a string where all words (separated by space)\nare replaced by a new word where all the characters arranged in\nascending order based on ascii value.\nNote: You should keep the order of words and blank spaces in the sentence.\n\nFor example:\nanti_shuffle(\"Hi\") returns \"Hi\"\nanti_shuffle(\"hello\") returns \"ehllo\"\nanti_shuffle(\"Hello World!!!\") returns \"Hello !!!Wdlor\"\n*/\n#include<stdio.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\nstring anti_shuffle(string s){\n",
    "simplified_intent": "Write a function that takes a string and returns an ordered version of it. Ordered version of string, is a string where all words (separated by space) are replaced by a new word where all the characters arranged in ascending order based on ascii value. Note: You should keep the order of words and blank spaces in the sentence.",
    "snippet": [
      "    string out=\"\";\n    string current=\"\";\n    s=s+' ';\n    for (int i=0;i<s.length();i++)\n    if (s[i]==' ')\n    {\n        sort(current.begin(),current.end());\n        if (out.length()>0) out=out+' ';\n        out=out+current;\n        current=\"\";\n    }\n    else current=current+s[i];\n    return out;\n}\n"
    ],
    "sample_from": {
      "0": "incoder",
      "1": "incoder",
      "2": "incoder",
      "3": "codex",
      "4": "codex",
      "5": "codex"
    },
    "0": "std::vector<std::string> words;\n    std::string new_s, w = \"\";\n    std::istringstream iss(s);\n    while (iss >> w) {\n        words.push_back(w);\n    }\n    std::sort(words.begin(), words.end(), [](const std::string& a, const std::string& b){\n        size_t n = a.length();\n        size_t m = b.length();\n        for (size_t i = 0; i < n; i++) {\n            int tmp = a[i] - b[i];\n            if (tmp != 0) {\n                return tmp;\n            }\n        }\n        return 0;\n    });\n    for (size_t i = 0; i < words.size(); i++) {\n        if (i != 0 && words[i].length() > words[i - 1].length()) {\n            new_s += \" \";\n        }\n        new_s += words[i];\n    }\n    return new_s;",
    "grade-0": {
      "execution": 0
    },
    "1": "std::stack<std::string> stk;\n  for (size_t i = 0; i < s.size(); i++) {\n    char ch = s[i];\n    if (std::isalpha(ch)) {\n      stk.push(s.substr(0, i) + ch +\n               s.substr(i + 1, s.size() - i));\n    }\n  }\n  std::cout << s << std::endl;\n  std::string ans;\n  while (!stk.empty()) {\n    std::string temp = stk.top();\n    stk.pop();\n    ans = temp + ans;\n  }\n  std::cout << ans << std::endl;\n  return ans;",
    "grade-1": {
      "execution": 0
    },
    "2": "assert(s.size() >= 2); // Do not handle empty or null strings.\n    std::string ret = \"\";\n    size_t begin = 0;\n    size_t end = s.size();\n    while (end > 0) {\n        // Find the first non-space character\n        while (begin < end && (s.at(begin) == ' ' || s.at(begin) == '\\0')) {\n            ++begin;\n        }\n        // Find the last non-space character\n        while (end > begin && (s.at(end) == ' ' || s.at(end) == '\\0')) {\n            --end;\n        }\n        std::string middle = s.substr(begin, end - begin + 1);\n        std::string before = s.substr(0, begin);\n        std::string after = s.substr(end + 1);\n        std::string rep = anti_shuffle(middle);\n        rep.append(before);\n        rep.append(after);\n        ret += rep;\n        begin = begin;\n        end = end;\n    }\n    return ret;",
    "grade-2": {
      "execution": 0
    },
    "3": "int n = s.length();\n  std::string anti_string = \"\";\n  std::string word = \"\";\n  // reverse the string\n  for (int i = n - 1; i >= 0; i--) {\n    // push letters into a string\n    if (s[i] != ' ') {\n      word += s[i];\n    }\n    // when there is a space, do this.\n    if (s[i] == ' ' || i == 0) {\n      // reverse the word, add the space and push it into the anti_string\n      reverse(word.begin(), word.end());\n      if (s[i] == ' ') {\n        anti_string += word + \" \";\n      } else {\n        anti_string += word;\n      }\n      // reset the word\n      word = \"\";\n    }\n  }\n  return anti_string;",
    "grade-3": {
      "execution": 0
    },
    "4": "// your code here\n  std::stringstream ss(s);\n  std::string token;\n  std::string temp = \"\";\n  while(std::getline(ss, token, ' ')) {\n    std::vector<char> char_token(token.begin(), token.end());\n    std::sort(char_token.begin(), char_token.end());\n    token = std::string(char_token.begin(), char_token.end());\n    temp += token + \" \";\n  }\n  temp.pop_back();\n  return temp;",
    "grade-4": {
      "execution": 0
    },
    "5": "std::cout << s;\n  return \"\";",
    "grade-5": {
      "execution": 0
    }
  },
  {
    "intent": "#include<assert.h>\n#include<bits/stdc++.h>\n// I think we all remember that feeling when the result of some long-awaited\n// event is finally known. The feelings and thoughts you have at that moment are\n// definitely worth noting down and comparing.\n// Your task is to determine if a person correctly guessed the results of a number of matches.\n// You are given two arrays of scores and guesses of equal length, where each index shows a match. \n// Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n// the value is 0, and if not, the value is the absolute difference between the guess and the score.\n// example:\n// compare([1,2,3,4,5,1],[1,2,3,4,2,-2]) -> [0,0,0,0,3,3]\n// compare([0,5,0,0,0,4],[4,1,1,0,0,-2]) -> [4,4,1,0,0,6]\nstd::vector<long> compare(std::vector<long> game, std::vector<long> guess) {\n",
    "task_id": "152",
    "prompt": "/*\nI think we all remember that feeling when the result of some long-awaited\nevent is finally known. The feelings and thoughts you have at that moment are\ndefinitely worth noting down and comparing.\nYour task is to determine if a person correctly guessed the results of a number of matches.\nYou are given two vectors of scores and guesses of equal length, where each index shows a match. \nReturn a vector of the same length denoting how far off each guess was. If they have guessed correctly,\nthe value is 0, and if not, the value is the absolute difference between the guess and the score.\n\n\nexample:\n\ncompare({1,2,3,4,5,1},{1,2,3,4,2,-2}) -> {0,0,0,0,3,3}\ncompare({0,5,0,0,0,4},{4,1,1,0,0,-2}) -> {4,4,1,0,0,6}\n*/\n#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\nvector<int> compare(vector<int> game,vector<int> guess){\n",
    "simplified_intent": "I think we all remember that feeling when the result of some long-awaited event is finally known. The feelings and thoughts you have at that moment are definitely worth noting down and comparing. Your task is to determine if a person correctly guessed the results of a number of matches. You are given two arrays of scores and guesses of equal length, where each index shows a match. Return an array of the same length denoting how far off each guess was. If they have guessed correctly, the value is 0, and if not, the value is the absolute difference between the guess and the score.",
    "snippet": [
      "    vector<int> out;\n    for (int i=0;i<game.size();i++)\n    out.push_back(abs(game[i]-guess[i]));\n    return out;\n}\n"
    ],
    "sample_from": {
      "0": "incoder",
      "1": "incoder",
      "2": "incoder",
      "3": "codex",
      "4": "codex",
      "5": "codex"
    },
    "0": "std::vector<long> winner(game.size());\n    std::map<long, long> score_map;\n    // Step 1. Store all scores and guesses in map by using the same index\n    for (long i = 0; i < game.size(); i++) {\n        if (game[i] != 0) {\n            score_map[game[i]] = i;\n        }\n    }\n    // Step 2. Initialize a score to zero and count how many times the guess\n    // is correct.\n    long count_correct = 0;\n    for (long i = 0; i < guess.size(); i++) {\n        long guess = guess[i];\n        if (guess == 0) {\n            continue;\n        }\n        if (score_map.find(guess) != score_map.end()) {\n            // Step 3. Increment the number of correct guesses\n            count_correct++;\n        }\n    }\n    // Step 4. Initialize a score to zero and count how many times the guess\n    // is incorrect.\n    long count_incorrect = 0;\n    for (long i = 0; i < game.size(); i++) {\n        long score = game[i];\n        if (score != 0) {\n            // Step 5. Iterate through all scores and guesses and update the score.\n            for (long j = 0; j < guess.size(); j++) {\n                long guess = guess[j];\n                if (guess == 0) {\n                    continue;\n                }\n                if (score_map.find(guess) != score_map.end()) {\n                    score = max(score, score_map[guess]);\n                }\n            }\n            // Step 6. Update the score.\n            if (score != 0) {\n                winner[score] = winner[score] | (1 << i);\n            }\n        }\n    }\n    // Step 7. Calculate an aggregate score\n    long final_score = 0;\n    for (long i = 0; i < game.size(); i++) {\n        if (winner[i] & (1 << i)) {\n            final_score += abs(winner.at(i) - i);\n        }\n    }\n    return std::vector<long>(winner.begin(), winner.end()) + std::vector<long>(final_score, final_score + game.size());",
    "grade-0": {
      "execution": 0
    },
    "1": "std::vector<long> result(game.size());\n  int k = 0;\n  // int l = game.size();\n  // std::cout<<\"k: \"<<k<<\"l: \"<<l<<std::endl;\n  for (int i = 0; i < game.size(); i++) {\n    for (int j = 0; j < guess.size(); j++) {\n      if (game[i] == guess[j]) {\n        result[i] = 0;\n        result[k] = 0;\n        result[k + 1] = result[k] + 1;\n        break;\n      }\n      if (game[i] > guess[j]) {\n        result[i] = abs(game[i] - guess[j]);\n        result[k + 1] = result[k];\n      }\n      else if (game[i] < guess[j]) {\n        result[i] = abs(guess[j] - game[i]);\n        result[k + 1] = result[k];\n      }\n    }\n    k++;\n  }\n  std::cout<<\"result: \"<<result<<std::endl;\n  return result;",
    "grade-1": {
      "execution": 0
    },
    "2": "if (game.size() != guess.size()) {\n        std::cerr << \"Not enough entries for compare.\" << std::endl;\n        exit(-1);\n    }\n    std::vector<long> result(game.size());\n    long score = 0;\n    for (int i = 0; i < game.size(); ++i) {\n        if (game[i] > guess[i]) {\n            score += abs(game[i] - guess[i]);\n        } else {\n            score += abs(guess[i] - game[i]);\n        }\n        result[i] = score;\n    }\n    return result;",
    "grade-2": {
      "execution": 0
    },
    "3": "//your code here\n  std::vector<long> result;\n  for(unsigned i = 0; i < game.size(); i++){\n      result.push_back(abs(game[i] - guess[i]));\n  }\n  return result;",
    "grade-3": {
      "execution": 1
    },
    "4": "int guess_size = guess.size();\n    std::vector<long> result;\n    for(int i = 0; i < guess_size; i++){\n        if(game[i] > guess[i]){\n            result.push_back(game[i] - guess[i]);\n        }else if(game[i] < guess[i]){\n            result.push_back(guess[i] - game[i]);\n        }else{\n            result.push_back(0);\n        }\n    }\n    return result;",
    "grade-4": {
      "execution": 1
    },
    "5": "vector<long> answer;\n    for(int i = 0; i < game.size(); i++){\n        answer.push_back(abs(game[i] - guess[i]));\n    }\n    return answer;",
    "grade-5": {
      "execution": 0
    }
  },
  {
    "intent": "#include<assert.h>\n#include<bits/stdc++.h>\n// Out of list of strings, return the longest one. Return the first one in case of multiple\n// strings of the same length. Return None in case the input list is empty.\n// >>> longest([])\n// >>> longest(['a', 'b', 'c'])\n// 'a'\n// >>> longest(['a', 'bb', 'ccc'])\n// 'ccc'\nstd::optional<std::string> longest(std::vector<std::string> strings) {\n",
    "task_id": "12",
    "prompt": "/*\nOut of vector of strings, return the longest one. Return the first one in case of multiple\nstrings of the same length. Return None in case the input vector is empty.\n>>> longest({})\n\n>>> longest({\"a\", \"b\", \"c\"})\n\"a\"\n>>> longest({\"a\", \"bb\", \"ccc\"})\n\"ccc\"\n*/\n#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\nstring longest(vector<string> strings){\n",
    "simplified_intent": "Out of list of strings, return the longest one. Return the first one in case of multiple strings of the same length. Return None in case the input list is empty.",
    "snippet": [
      "    string out;\n    for (int i=0;i<strings.size();i++)\n    {\n        if (strings[i].length()>out.length()) out=strings[i];\n    }\n    return out;\n}\n"
    ],
    "sample_from": {
      "0": "incoder",
      "1": "incoder",
      "2": "incoder",
      "3": "codex",
      "4": "codex",
      "5": "codex"
    },
    "0": "// We need to keep track of the longest string so we can find its index\n    // later.\n    std::optional<std::string> longestString;\n    std::string longestStringLength = std::to_string(strings[0].length());\n    for (auto string : strings) {\n        // Check if the new string is longer than the previous one.\n        if (string.length() > longestStringLength) {\n            // It is! Remember it.\n            longestString = string;\n            longestStringLength = string.length();\n        }\n    }\n    return longestString;",
    "grade-0": {
      "execution": 0
    },
    "1": "if (strings.empty()) return std::nullopt;\n\n    std::string max_string = *std::max_element(strings.cbegin(), strings.cend());\n    size_t max_index = std::count_if(strings.cbegin(), strings.cend(), [&](const std::string &str) {\n        return str.size() > max_string.size() &&\n               str.substr(0, max_string.size()) == max_string;\n    });\n\n    if (max_index == 1) return max_string;\n    return strings[max_index];",
    "grade-1": {
      "execution": 0
    },
    "2": "if (strings.size() == 0) {\n        return {};\n    }\n    std::string longestString = *std::max_element(strings.begin(), strings.end(), [](std::string a, std::string b) {\n        return a.length() < b.length();\n    });\n    return longestString;",
    "grade-2": {
      "execution": 1
    },
    "3": "if (strings.empty()) {\n        return std::nullopt;\n    }\n    auto result = strings[0];\n    for (auto s : strings) {\n        if (s.size() > result.size()) {\n            result = s;\n        }\n    }\n    return result;",
    "grade-3": {
      "execution": 1
    },
    "4": "if (strings.empty()) {\n        return std::nullopt;\n    }\n    int maxLen = 0;\n    std::string maxStr;\n    for (const auto& str : strings) {\n        if (str.length() > maxLen) {\n            maxLen = str.length();\n            maxStr = str;\n        }\n    }\n    return maxStr;",
    "grade-4": {
      "execution": 1
    },
    "5": "if (strings.empty()) return std::nullopt;\n    int max_len = 0;\n    std::string max_str = \"\";\n    for (auto &&s : strings) {\n        if (s.length() > max_len) {\n            max_len = s.length();\n            max_str = s;\n        }\n    }\n    return max_str;",
    "grade-5": {
      "execution": 1
    }
  },
  {
    "intent": "#include<assert.h>\n#include<bits/stdc++.h>\nunion Union_std_vector_std_string__long{\n    std::vector<std::string> f0;\n    long f1;    Union_std_vector_std_string__long(std::vector<std::string> _f0) : f0(_f0) {}\n    Union_std_vector_std_string__long(long _f1) : f1(_f1) {}\n    ~Union_std_vector_std_string__long() {}\n    bool operator==(Union_std_vector_std_string__long u2) {\n        return f0 == u2.f0 || f1 == u2.f1 ;\n    }\n};\n// Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// split_words(\"Hello world!\") \u279e [\"Hello\", \"world!\"]\n// split_words(\"Hello,world!\") \u279e [\"Hello\", \"world!\"]\n// split_words(\"abcdef\") == 3\nUnion_std_vector_std_string__long split_words(std::string txt) {\n",
    "task_id": "125",
    "prompt": "/*\nGiven a string of words, return a vector of words split on whitespace, if no whitespaces exists in the text you\nshould split on commas ',' if no commas exists you should return a vector with one element, the number of lower-case letters with odd order in the\nalphabet, ord(\"a\") = 0, ord(\"b\") = 1, ... ord(\"z\") = 25\nExamples\nsplit_words(\"Hello world!\") \u279e {\"Hello\", \"world!\"}\nsplit_words(\"Hello,world!\") \u279e {\"Hello\", \"world!\"}\nsplit_words(\"abcdef\") == {\"3\"} \n*/\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\nvector<string> split_words(string txt){\n",
    "simplified_intent": "Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25",
    "snippet": [
      "    int i;\n    string current=\"\";\n    vector<string> out={};\n    if (find(txt.begin(),txt.end(),' ')!=txt.end())\n    {\n        txt=txt+' ';\n        for (i=0;i<txt.length();i++)\n            if (txt[i]==' ') \n            {\n                if (current.length()>0)out.push_back(current); \n                current=\"\";\n            }\n            else current=current+txt[i];\n        return out;\n    }\n    if (find(txt.begin(),txt.end(),',')!=txt.end())\n    {\n        txt=txt+',';\n        for (i=0;i<txt.length();i++)\n            if (txt[i]==',') \n            {\n                if (current.length()>0)out.push_back(current); \n                current=\"\";\n            }\n            else current=current+txt[i];\n        return out;\n    }\n    int num=0;\n    for (i=0;i<txt.length();i++)\n        if (txt[i]>=97 and txt[i]<=122 and txt[i]%2==0)\n            num+=1;\n    return {to_string(num)};\n}\n"
    ],
    "sample_from": {
      "0": "incoder",
      "1": "incoder",
      "2": "incoder",
      "3": "codex",
      "4": "codex",
      "5": "codex"
    },
    "0": "std::vector<std::string> words;\n    std::unordered_set<std::string> letters;\n    for (auto &c : txt) {\n        if (c == ' ') {\n            words.push_back(\"\");\n        } else if (c == ',') {\n            words.push_back(\"\");\n        } else {\n            auto l = tolower(c);\n            if (letters.find(l) != letters.end()) {\n                words.back() += c;\n            } else {\n                words.push_back(\"\");\n                letters.insert(l);\n            }\n        }\n    }\n    if (words.size() % 2 != 0) {\n        words.push_back(\"\"); // this word does not have an even length\n    }\n    Union_std_vector_std_string__long ret;\n    for (auto &w : words) {\n        if (w.length() == 0 || w.length() == 1) {\n            ret.f0.push_back(\"\");\n        } else {\n            ret.f0.push_back(w.substr(0, w.length() / 2)); // divide word into two parts\n            ret.f0.push_back(w.substr(w.length() / 2, w.length())); // divide the second part from the first part\n        }\n    }\n    return ret;",
    "grade-0": {
      "execution": 0
    },
    "1": "std::vector<char> v;\n    std::string::size_type last_pos = 0;\n    std::string::size_type pos = 0;\n    for(pos = txt.find_first_not_of(\" ,\", 0); pos != std::string::npos; pos = txt.find_first_not_of(\" ,\", last_pos)){\n        v.push_back(txt[last_pos]);\n        last_pos = pos + 1;\n    }\n    if(last_pos < txt.length())\n        v.push_back(txt[last_pos]);\n    Union_std_vector_std_string__long ans;\n    ans.f0 = v;\n    return ans;",
    "grade-1": {
      "execution": 0
    },
    "2": "std::vector<std::vector<std::string>> words;\n    std::vector<std::string> word;\n    long count = 0;\n    size_t pos = 0;\n    if (txt != \"\") {\n        for (auto c : txt) {\n            word.clear();\n            if (std::isspace(c)) {\n                pos = txt.find(c, pos);\n            } else {\n                pos = txt.find(c, 0);\n            }\n            if (pos != std::string::npos) {\n                word.push_back(std::string(txt.begin() + pos, txt.begin() + pos + 1));\n            }\n            if (word.size() > 0) {\n                words.push_back(word);\n            }\n            ++count;\n        }\n        if (words.size() > 0) {\n            std::sort(words.begin(), words.end());\n            std::reverse(words.begin(), words.end());\n            while (words.size() > 1) {\n                std::vector<std::vector<std::string>> tmp;\n                tmp.push_back(words[0]);\n                words.erase(words.begin());\n                for (auto w : words) {\n                    std::string w = \"\";\n                    for (auto c : w) {\n                        if (islower(c)) {\n                            w += c;\n                        } else {\n                            if (w.size() == 0) {\n                                break;\n                            }\n                            if (isupper(w[w.size() - 1])) {\n                                w += c;\n                                break;\n                            } else {\n                                w += \",\";\n                            }\n                        }\n                    }\n                    tmp.push_back(std::move(w));\n                }\n                if (tmp.size() > 0) {\n                    words.swap(tmp);\n                }\n                std::sort(words.begin(), words.end());\n                std::reverse(words.begin(), words.end());\n            }\n            Union_std_vector_std_string__long tmp;\n            for (size_t i = 0; i < words.size(); i++) {\n                tmp.push_back(words[i]);\n            }\n            return tmp;\n        }\n    }\n    return Union_std_vector_std_string__long(count);",
    "grade-2": {
      "execution": 0
    },
    "3": "auto v = std::vector<std::string>{};\n    if (txt.find(' ') != std::string::npos) {\n        std::stringstream ss(txt);\n        std::string word;\n        while (std::getline(ss, word, ' ')) {\n            v.push_back(word);\n        }\n        return v;\n    }\n    else if (txt.find(',') != std::string::npos) {\n        std::stringstream ss(txt);\n        std::string word;\n        while (std::getline(ss, word, ',')) {\n            v.push_back(word);\n        }\n        return v;\n    }\n    else {\n        int count = 0;\n        for (auto c : txt) {\n            if (c - 'a' < 0 || c - 'a' > 25)\n                return -1;\n            if ((c - 'a') % 2 == 1) {\n                count++;\n            }\n        }\n        return count;\n    }",
    "grade-3": {
      "execution": 0
    },
    "4": "std::vector<std::string> ret;\n    long ret_;\n    std::stringstream str(txt);\n    std::string tmp;\n    while(std::getline(str, tmp, ' '))\n        ret.push_back(tmp);\n    if(ret.size() < 2) {\n        std::stringstream str(txt);\n        while(std::getline(str, tmp, ','))\n            ret.push_back(tmp);\n    }\n    if(ret.size() < 2) {\n        int cnt = 0;\n        for(int i = 0; i < txt.size(); i++) {\n            if(txt[i] - 'a' < 0 || txt[i] - 'a' > 25)\n                continue;\n            if((txt[i] - 'a') % 2 == 1)\n                cnt++;\n        }\n        ret_ = cnt;\n        return Union_std_vector_std_string__long(ret_);\n    }\n    return Union_std_vector_std_string__long(ret);",
    "grade-4": {
      "execution": 0
    },
    "5": "if (txt.find(\" \") != std::string::npos) {\n        std::vector<std::string> res;\n        std::stringstream ss(txt);\n        std::string item;\n        while (std::getline(ss, item, ' ')) {\n            res.push_back(item);\n        }\n        return Union_std_vector_std_string__long(res);\n    }\n    if (txt.find(\",\") != std::string::npos) {\n        std::vector<std::string> res;\n        std::stringstream ss(txt);\n        std::string item;\n        while (std::getline(ss, item, ',')) {\n            res.push_back(item);\n        }\n        return Union_std_vector_std_string__long(res);\n    }\n    int count = 0;\n    for (int i = 0; i < txt.size(); i++) {\n        if (txt[i] >= 'a' && txt[i] <= 'z' && ((txt[i] - 'a') % 2) == 1) {\n            count++;\n        }\n    }\n    return Union_std_vector_std_string__long(count);",
    "grade-5": {
      "execution": 1
    }
  },
  {
    "intent": "#include<assert.h>\n#include<bits/stdc++.h>\n// Given an array of non-negative integers, return a copy of the given array after sorting,\n// you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given array.\n// Examples:\n// * sort_array([]) => []\n// * sort_array([5]) => [5]\n// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\nstd::vector<long> sort_array(std::vector<long> array) {\n",
    "task_id": "88",
    "prompt": "/*\nGiven a vector of non-negative integers, return a copy of the given vector after sorting,\nyou will sort the given vector in ascending order if the sum( first index value, last index value) is odd,\nor sort it in descending order if the sum( first index value, last index value) is even.\n\nNote:\n* don't change the given vector.\n\nExamples:\n* sort_vector({}) => {}\n* sort_vector({5}) => {5}\n* sort_vector({2, 4, 3, 0, 1, 5}) => {0, 1, 2, 3, 4, 5}\n* sort_vector({2, 4, 3, 0, 1, 5, 6}) => {6, 5, 4, 3, 2, 1, 0}\n*/\n#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nvector<int> sort_array(vector<int> array){\n",
    "simplified_intent": "Given an array of non-negative integers, return a copy of the given array after sorting, you will sort the given array in ascending order if the sum( first index value, last index value) is odd, or sort it in descending order if the sum( first index value, last index value) is even. Note: * don't change the given array.",
    "snippet": [
      "    if (array.size()==0) return {};\n    if ((array[0]+array[array.size()-1]) %2==1)\n    {\n        sort(array.begin(),array.end());\n        return array;\n    }\n    else\n    {\n        sort(array.begin(),array.end());\n        vector<int> out={};\n        for (int i=array.size()-1;i>=0;i-=1)\n            out.push_back(array[i]);\n        return out;\n    }\n\n}\n"
    ],
    "sample_from": {
      "0": "incoder",
      "1": "incoder",
      "2": "incoder",
      "3": "codex",
      "4": "codex",
      "5": "codex"
    },
    "0": "std::vector<long> ans;\n    std::sort(array.begin(), array.end(), [] (const long &a, const long &b) {\n        return a + b > 0 ? a > b : a < b;\n    });\n    std::size_t sum = 0;\n    for (std::size_t i = 0; i < array.size(); i++) {\n        sum += array[i];\n        if (sum % 2 == 0) {\n            ans.push_back(array[i]);\n        } else {\n            ans.push_back(array[array.size() - 1 - i]);\n        }\n    }\n    return ans;",
    "grade-0": {
      "execution": 0
    },
    "1": "long sum = 0;\n    for(long i : array)\n        sum += i;\n    if (sum%2 == 1)\n        std::sort(array.begin(), array.end());\n    else\n        std::sort(array.begin(), array.end(), [](long a, long b) { return b > a; });\n    return array;",
    "grade-1": {
      "execution": 0
    },
    "2": "int sum = 0;\n    for (int i = 0; i < array.size(); i++) {\n        sum += array[i];\n    }\n    if (sum % 2) {\n        std::cout << \"descending order\\n\";\n        std::sort(array.begin(), array.end(), [&sum](int a, int b) { return b - a;});\n        return array;\n    }\n    else {\n        std::cout << \"ascending order\\n\";\n        std::sort(array.begin(), array.end(), [&sum](int a, int b) { return a - b;});\n        return array;\n    }",
    "grade-2": {
      "execution": 0
    },
    "3": "// write your code here",
    "grade-3": {
      "execution": 0
    },
    "4": "std::vector<long> res;\n    std::cout << array.size() << std::endl;\n    //if the array is empty or has only one element, return the array itself\n    if (array.size() == 0 || array.size() == 1) {\n        return array;\n    }\n    //the sum is even (the array is sorted in descending order)\n    else if ((array[0] + array[array.size() - 1]) % 2 == 0) {\n        std::sort(array.begin(), array.end(), std::greater<long>());\n        res = array;\n    }\n    //the sum is odd (the array is sorted in ascending order)\n    else {\n        std::sort(array.begin(), array.end());\n        res = array;\n    }\n    return res;",
    "grade-4": {
      "execution": 1
    },
    "5": "int length = array.size();\n    if (length == 0) {\n        return array;\n    }\n    bool isOdd = (array[0] + array[length - 1]) % 2 == 1;\n    std::vector<long> result(array);\n    if (isOdd) {\n        std::sort(result.begin(), result.end());\n    } else {\n        std::sort(result.begin(), result.end(), std::greater<long>());\n    }\n    return result;",
    "grade-5": {
      "execution": 1
    }
  },
  {
    "intent": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n// Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string words_in_sentence(std::string sentence) {\n",
    "task_id": "143",
    "prompt": "/*\nYou are given a string representing a sentence,\nthe sentence contains some words separated by a space,\nand you have to return a string that contains the words from the original sentence,\nwhose lengths are prime numbers,\nthe order of the words in the new string should be the same as the original one.\n\nExample 1:\n    Input: sentence = \"This is a test\"\n    Output: \"is\"\n\nExample 2:\n    Input: sentence = \"lets go for swimming\"\n    Output: \"go for\"\n\nConstraints:\n    * 1 <= len(sentence) <= 100\n    * sentence contains only letters\n*/\n#include<stdio.h>\n#include<string>\nusing namespace std;\nstring words_in_sentence(string sentence){\n",
    "simplified_intent": "You are given a string representing a sentence, the sentence contains some words separated by a space, and you have to return a string that contains the words from the original sentence, whose lengths are prime numbers, the order of the words in the new string should be the same as the original one. Constraints: * 1 <= len(sentence) <= 100 * sentence contains only letters",
    "snippet": [
      "    string out=\"\";\n    string current=\"\";\n    sentence=sentence+' ';\n\n    for (int i=0;i<sentence.size();i++)\n    if (sentence[i]!=' ') current=current+sentence[i];\n    else\n    {\n        bool isp=true;\n        int l=current.length();\n        if (l<2) isp=false;\n        for (int j=2;j*j<=l;j++)\n            if (l%j==0) isp=false;\n        if (isp) out=out+current+' ';\n        current=\"\";        \n    }\n    if (out.length()>0)\n        out.pop_back();\n    return out;\n}\n"
    ],
    "sample_from": {
      "0": "incoder",
      "1": "incoder",
      "2": "incoder",
      "3": "codex",
      "4": "codex",
      "5": "codex"
    },
    "0": "std::vector<std::string> words;\n  std::string word;\n  std::string newSentence;\n  std::istringstream ss(sentence);\n  while (std::getline(ss, word, ' ')) {\n    if (word.length() == 0) {\n      continue;\n    }\n    words.push_back(word);\n  }\n  for (size_t i = 0; i < words.size(); i++) {\n    std::string newWord = words[i];\n    if (newWord.length() % 2 == 0) {\n      int j = newWord.length() / 2;\n      while (j > 0) {\n        if (newWord[j] % 2 == 0) {\n          break;\n        }\n        j--;\n      }\n      newWord = words[i];\n      int k = j + 1;\n      bool flag = true;\n      while (k > 0) {\n        if (newWord[k] % 2 == 0) {\n          flag = false;\n          break;\n        }\n        k--;\n      }\n      if (flag == true) {\n        newWord = words[i];\n      }\n    }\n    newSentence += newWord + \" \";\n  }\n  return newSentence;",
    "grade-0": {
      "execution": 0
    },
    "1": "// Write your code here\n    // Your code goes here\n    \n    std::string result = \"\";\n    int n = sentence.length();\n    for (int i = 0; i < n; i++) {\n        int count = 0;\n        for (int j = i + 1; j < n; j++) {\n            if (isPrime(sentence.substr(i, j).length())) {\n                count++;\n            }\n        }\n        if (count == 1) {\n            result += sentence.substr(i, 1);\n        }\n    }\n    \n    return result;",
    "grade-1": {
      "execution": 0
    },
    "2": "std::sort(sentence.begin(), sentence.end());\n    std::vector<std::string> vec;\n    for (std::size_t i = 0; i < sentence.size(); ++i) {\n        char ch = sentence[i];\n        if (ch >= 'a' && ch <= 'z') {\n            vec.push_back(std::string(ch, 1));\n        }\n    }\n    std::sort(vec.begin(), vec.end());\n    std::string ans;\n    for (int i = 0; i < vec.size(); ++i) {\n        int n = vec[i].length();\n        if (i != 0) {\n            ans.push_back(\" \");\n        }\n        bool flag = true;\n        for (int j = 0; j < n; ++j) {\n            if (vec[i].at(j) != vec[0].at(j)) {\n                flag = false;\n                break;\n            }\n        }\n        if (flag) {\n            ans.push_back(vec[i]);\n        }\n    }\n    return ans;",
    "grade-2": {
      "execution": 0
    },
    "3": "if (sentence.size() == 0) {\n    return \"\";\n  }\n  std::string ret;\n  std::string s;\n  std::stringstream ss(sentence);\n  bool flag = false;\n  while (ss >> s) {\n    bool is_prime = true;\n    for (size_t d = 2; d * d <= s.size(); ++d) {\n      if (s.size() % d == 0) {\n        is_prime = false;\n        break;\n      }\n    }\n    if (is_prime) {\n      if (flag) {\n        ret += \" \";\n      }\n      ret += s;\n      flag = true;\n    }\n  }\n  return ret;",
    "grade-3": {
      "execution": 0
    },
    "4": "const int n = sentence.size();\n\tif (n < 1 || n > 100) {\n\t\tassert(0);\n\t}\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (!isalpha(sentence[i])) {\n\t\t\tassert(0);\n\t\t}\n\t}\n\tstd::vector<std::string> res;\n\tstd::string token;\n\tstd::istringstream iss(sentence);\n\twhile (std::getline(iss, token, ' ')) {\n\t\tif (is_prime(token.size())) {\n\t\t\tres.push_back(token);\n\t\t}\n\t}\n\tstd::string ans = \"\";\n\tfor (const auto& x : res) {\n\t\tans += x + \" \";\n\t}\n\tans.pop_back();\n\treturn ans;",
    "grade-4": {
      "execution": 0
    },
    "5": "std::vector<std::string> words;\n    for (int i = 0; i < sentence.size(); i++) {\n        std::string current_word;\n        while (sentence[i] != ' ' && i < sentence.size()) {\n            current_word += sentence[i];\n            i++;\n        }\n        words.push_back(current_word);\n    }\n    std::string result;\n    for (int i = 0; i < words.size(); i++) {\n        int word_length = words[i].size();\n        bool is_prime = true;\n        for (int divisor = 2; divisor < word_length; divisor++) {\n            if (word_length % divisor == 0) {\n                is_prime = false;\n                break;\n            }\n        }\n        if (is_prime) {\n            result += words[i] + \" \";\n        }\n    }\n    if (result.size() > 0) {\n        result.pop_back();\n    }\n    return result;",
    "grade-5": {
      "execution": 0
    }
  },
  {
    "intent": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a list of numbers.\n// You need to return the sum of squared numbers in the given list,\n// round each element in the list to the upper int(Ceiling) first.\n// Examples:\n// For lst = [1,2,3] the output should be 14\n// For lst = [1,4,9] the output should be 98\n// For lst = [1,3,5,7] the output should be 84\n// For lst = [1.4,4.2,0] the output should be 29\n// For lst = [-2.4,1,1] the output should be 6\nlong sum_squares(std::vector<float> lst) {\n",
    "task_id": "133",
    "prompt": "/*\nYou are given a vector of numbers.\nYou need to return the sum of squared numbers in the given vector,\nround each element in the vector to the upper int(Ceiling) first.\nExamples:\nFor lst = {1,2,3} the output should be 14\nFor lst = {1,4,9} the output should be 98\nFor lst = {1,3,5,7} the output should be 84\nFor lst = {1.4,4.2,0} the output should be 29\nFor lst = {-2.4,1,1} the output should be 6\n\n\n*/\n#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\nint sum_squares(vector<float> lst){\n",
    "simplified_intent": "You are given a list of numbers. You need to return the sum of squared numbers in the given list, round each element in the list to the upper int(Ceiling) first.",
    "snippet": [
      "    int sum=0;\n    for (int i=0;i<lst.size();i++)\n        sum+=ceil(lst[i])*ceil(lst[i]);\n    return sum;\n}\n"
    ],
    "sample_from": {
      "0": "incoder",
      "1": "incoder",
      "2": "incoder",
      "3": "codex",
      "4": "codex",
      "5": "codex"
    },
    "0": "// Your code goes here\n    int n = lst.size();\n    long sum = 0;\n    for(int i = 0; i < n; i++)\n    {\n        sum += (long)std::ceil(lst[i]);\n    }\n    return sum;",
    "grade-0": {
      "execution": 0
    },
    "1": "assert(lst.size() > 0);\n    long long n = lst.size();\n    long long sum = 0;\n    for (long long i = 0; i < n; ++i) {\n        sum += std::round(lst[i]*lst[i]);\n    }\n    return sum;",
    "grade-1": {
      "execution": 0
    },
    "2": "long long ans = 0;\n    assert(lst.size() != 0);\n    for (float x : lst) {\n        x = (x * x);\n        ans += x;\n    }\n    return ans;",
    "grade-2": {
      "execution": 0
    },
    "3": "// your code here\n  long result = 0;\n  for(int i = 0; i < lst.size(); i++){\n    lst[i] = ceil(lst[i]);\n    lst[i] = lst[i] * lst[i];\n    result += lst[i];\n  }\n  return result;",
    "grade-3": {
      "execution": 1
    },
    "4": "// your code here\n  long sum = 0;\n  for(std::vector<float>::iterator it = lst.begin(); it != lst.end(); ++it)\n  {\n    sum += (long) ceil(*it) * (long) ceil(*it);\n  }\n  return sum;",
    "grade-4": {
      "execution": 1
    },
    "5": "float sum=0;\n  for(int i=0;i<lst.size();i++)\n  {\n      sum+=(ceil(lst[i])*ceil(lst[i]));\n  }\n  return sum;",
    "grade-5": {
      "execution": 1
    }
  },
  {
    "intent": "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a non-empty list of integers lst. add the even elements that are at odd indices..\n// Examples:\n// add([4, 2, 6, 7]) ==> 2\nlong add(std::vector<long> lst) {\n",
    "task_id": "85",
    "prompt": "/*\nGiven a non-empty vector of integers lst. add the even elements that are at odd indices..\n\n\nExamples:\n    add({4, 2, 6, 7}) ==> 2 \n*/\n#include<stdio.h>\n#include<vector>\nusing namespace std;\nint add(vector<int> lst){\n",
    "simplified_intent": "Given a non-empty list of integers lst. add the even elements that are at odd indices..",
    "snippet": [
      "    int sum=0;\n    for (int i=0;i*2+1<lst.size();i++)\n        if (lst[i*2+1]%2==0) sum+=lst[i*2+1];\n    return sum;\n}\n"
    ],
    "sample_from": {
      "0": "incoder",
      "1": "incoder",
      "2": "incoder",
      "3": "codex",
      "4": "codex",
      "5": "codex"
    },
    "0": "assert(lst.size() > 0);\n    long sum = 0;\n    for (long i = 0; i < lst.size(); i++) {\n        sum += lst[i];\n        if (i%2 == 1) {\n            sum += lst[i];\n        }\n    }\n    return sum;",
    "grade-0": {
      "execution": 0
    },
    "1": "long sum = 0;\n    for (std::size_t i = 0; i < lst.size(); i++) {\n        if (i % 2 == 0) {\n            sum += lst[i];\n        }\n    }\n    return sum;",
    "grade-1": {
      "execution": 0
    },
    "2": "// code here\n    long sum = 0;\n    for (int i = 0; i < lst.size(); i++) {\n        if (i % 2 == 0) {\n            sum += lst[i];\n        }\n    }\n    return sum;",
    "grade-2": {
      "execution": 0
    },
    "3": "int len = lst.size();\n  long sum = 0;\n  for(int i = 1; i < len; i+=2) {\n    if(lst[i] % 2 == 0) {\n      sum += lst[i];\n    }\n  }\n  return sum;",
    "grade-3": {
      "execution": 1
    },
    "4": "int length = lst.size();\n  int count = 0;\n  int ans = 0;\n  for(int i = 0; i < length; i++) {\n    if(i % 2 == 0 && lst[i] % 2 == 0) {\n      ans += lst[i];\n    }\n  }\n  return ans;",
    "grade-4": {
      "execution": 0
    },
    "5": "long ans = 0;\n    for(int i = 0; i < lst.size(); i += 2) ans += lst[i];\n    return ans;",
    "grade-5": {
      "execution": 0
    }
  },
  {
    "intent": "#include<assert.h>\n#include<bits/stdc++.h>\n// sum_to_n is a function that sums numbers from 1 to n.\n// >>> sum_to_n(30)\n// 465\n// >>> sum_to_n(100)\n// 5050\n// >>> sum_to_n(5)\n// 15\n// >>> sum_to_n(10)\n// 55\n// >>> sum_to_n(1)\n// 1\nlong sum_to_n(long n) {\n",
    "task_id": "60",
    "prompt": "/*\nsum_to_n is a function that sums numbers from 1 to n.\n>>> sum_to_n(30)\n465\n>>> sum_to_n(100)\n5050\n>>> sum_to_n(5)\n15\n>>> sum_to_n(10)\n55\n>>> sum_to_n(1)\n1\n*/\n#include<stdio.h>\nusing namespace std;\nint sum_to_n(int n){\n",
    "simplified_intent": "sum_to_n is a function that sums numbers from 1 to n.",
    "snippet": [
      "    return n*(n+1)/2;\n}\n"
    ],
    "sample_from": {
      "0": "incoder",
      "1": "incoder",
      "2": "incoder",
      "3": "codex",
      "4": "codex",
      "5": "codex"
    },
    "0": "long long sum = 0; \n    for (int i = 0; i < n; i++) \n        sum += i;\n    return sum;",
    "grade-0": {
      "execution": 0
    },
    "1": "long sum = 0;\n    for (int i = 1; i <= n; i++) {\n        sum += i;\n    }\n    return sum;",
    "grade-1": {
      "execution": 1
    },
    "2": "assert(n >= 1);\n  long ans = 0;\n  for (int i = 1; i <= n; i++) {\n    ans += i;\n  }\n  return ans;",
    "grade-2": {
      "execution": 1
    },
    "3": "return n*(n+1)/2;",
    "grade-3": {
      "execution": 1
    },
    "4": "// TODO: complete this function.\n    // Be sure to use a loop, not recursion.\n  long sum = 0;\n  for(int i = 1; i <= n; i++){\n    sum += i;\n  }\n  return sum;",
    "grade-4": {
      "execution": 1
    },
    "5": "return (n*(n+1))/2;",
    "grade-5": {
      "execution": 1
    }
  },
  {
    "intent": "#include<assert.h>\n#include<bits/stdc++.h>\n// For a given number n, find the largest number that divides n evenly, smaller than n\n// >>> largest_divisor(15)\n// 5\nlong largest_divisor(long n) {\n",
    "task_id": "24",
    "prompt": "/*\nFor a given number n, find the largest number that divides n evenly, smaller than n\n>>> largest_divisor(15)\n5\n*/\n#include<stdio.h>\nusing namespace std;\nint largest_divisor(int n){\n",
    "simplified_intent": "For a given number n, find the largest number that divides n evenly, smaller than n",
    "snippet": [
      "    for (int i=2;i*i<=n;i++)\n        if (n%i==0) return  n/i;\n    return 1;\n\n}\n"
    ],
    "sample_from": {
      "0": "incoder",
      "1": "incoder",
      "2": "incoder",
      "3": "codex",
      "4": "codex",
      "5": "codex"
    },
    "0": "long max_divisor = 0;\n\tlong current_divisor = 1;\n\twhile (current_divisor <= n) current_divisor *= 2;\n\twhile (current_divisor > max_divisor) max_divisor = current_divisor;\n\tassert(current_divisor <= n);\n\treturn max_divisor;",
    "grade-0": {
      "execution": 0
    },
    "1": "if (n<2) return n;\n  long result=n;\n  for (long i=3; i<=n/2; i++) if (n%i==0) result=i;\n  return result;",
    "grade-1": {
      "execution": 0
    },
    "2": "long x = 1;\n    long y = 1;\n    long z = 1;\n    long largest = 1;\n    while (y != 0) {\n        if (n / y == 0) {\n            if (y % 2 == 0) {\n                largest = z;\n            }\n            z = y;\n            y /= 2;\n        } else {\n            y *= 2;\n        }\n    }\n    return largest;",
    "grade-2": {
      "execution": 0
    },
    "3": "assert(n > 0);\n  // hint: try all numbers i from 1 to n\n  int max_divisor = 1;\n  for (int i = 1; i < n; i++) {\n    if (n % i == 0) {\n      max_divisor = i;\n    }\n  }\n  return max_divisor;",
    "grade-3": {
      "execution": 1
    },
    "4": "for (long i = n/2; i > 0; i--) {\n        if (n % i == 0) return i;\n    }\n    return 1;",
    "grade-4": {
      "execution": 1
    },
    "5": "long largest_divisor=1;\n    int i;\n    for(i=2;i<n;i++)\n    {\n        if(n%i==0)\n        {\n            largest_divisor=i;\n        }\n    }\n    return largest_divisor;",
    "grade-5": {
      "execution": 1
    }
  },
  {
    "intent": "#include<assert.h>\n#include<bits/stdc++.h>\n// Given length of a side and high return area for a triangle.\n// >>> triangle_area(5, 3)\n// 7.5\nfloat triangle_area(long a, long h) {\n",
    "task_id": "45",
    "prompt": "/*\nGiven length of a side and high return area for a triangle.\n>>> triangle_area(5, 3)\n7.5\n*/\n#include<stdio.h>\n#include<math.h>\nusing namespace std;\nfloat triangle_area(float a,float h){\n",
    "simplified_intent": "Given length of a side and high return area for a triangle.",
    "snippet": [
      "return (a*h)*0.5;\n\n}\n"
    ],
    "sample_from": {
      "0": "incoder",
      "1": "incoder",
      "2": "incoder",
      "3": "codex",
      "4": "codex",
      "5": "codex"
    },
    "0": "assert(a >= 0 && a <= h);\n  float a = a / h, b = a / sqrt(3), c = sqrt(3) / a;\n  float s = (a + b + c) / 2;\n  return s * s;",
    "grade-0": {
      "execution": 0
    },
    "1": "float area = ((float)(a * a * h) / 18);\n    return area;",
    "grade-1": {
      "execution": 0
    },
    "2": "return (a+h)/2*sqrt(pow(2,3/2)*pow((double)a,2)*pow((double)h,2));",
    "grade-2": {
      "execution": 0
    },
    "3": "return 0.5*a*h;",
    "grade-3": {
      "execution": 1
    },
    "4": "return .5 * a * h;",
    "grade-4": {
      "execution": 1
    },
    "5": "//a=h/2*b\n\t//a*a=h*h/4*b*b\n\t//b=sqrt(a*a/(h*h/4))\n\tassert(a >= 0);\n\tassert(h >= 0);\n\treturn h*h*a/(4*h);",
    "grade-5": {
      "execution": 0
    }
  },
  {
    "intent": "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n// as follows: start with any positive integer n. Then each term is obtained from the \n// previous term as follows: if the previous term is even, the next term is one half of \n// the previous term. If the previous term is odd, the next term is 3 times the previous\n// term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\nstd::vector<long> get_odd_collatz(long n) {\n",
    "task_id": "123",
    "prompt": "/*\nGiven a positive integer n, return a sorted vector that has the odd numbers in collatz sequence.\n\nThe Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\nas follows: start with any positive integer n. Then each term is obtained from the \nprevious term as follows: if the previous term is even, the next term is one half of \nthe previous term. If the previous term is odd, the next term is 3 times the previous\nterm plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n\nNote: \n    1. Collatz(1) is {1}.\n    2. returned vector sorted in increasing order.\n\nFor example:\nget_odd_collatz(5) returns {1, 5} // The collatz sequence for 5 is {5, 16, 8, 4, 2, 1}, so the odd numbers are only 1, and 5.\n*/\n#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nvector<int> get_odd_collatz(int n){\n",
    "simplified_intent": "Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence. The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined as follows: start with any positive integer n. Then each term is obtained from the previous term as follows: if the previous term is even, the next term is one half of the previous term. If the previous term is odd, the next term is 3 times the previous term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1. Note: 1. Collatz(1) is [1]. 2. returned list sorted in increasing order.",
    "snippet": [
      "    vector<int> out={1};\n    while (n!=1)\n    {\n        if (n%2==1) {out.push_back(n); n=n*3+1;}\n        else n=n/2;\n    }\n    sort(out.begin(),out.end());\n    return out;\n}\n"
    ],
    "sample_from": {
      "0": "incoder",
      "1": "incoder",
      "2": "incoder",
      "3": "codex",
      "4": "codex",
      "5": "codex"
    },
    "0": "// Step 1: Find all the odd numbers less than n. \n  std::vector<long> oddNumbers((n+1)/2);\n  long evenNumbers = (n+1)/2;\n  if (oddNumbers.size() == 0) {\n    return oddNumbers;\n  }\n  else {\n    for (long i = n; i > 1; i--) {\n      if (i%2 == 0) {\n        evenNumbers--;\n      }\n      else {\n        oddNumbers[oddNumbers.size() - 1] = oddNumbers[oddNumbers.size() - 1] * 3 + 1;\n      }\n    }\n  }\n  // Step 2: Sort the odd numbers in ascending order. \n  std::sort(oddNumbers.begin(), oddNumbers.end());\n  return oddNumbers;",
    "grade-0": {
      "execution": 0
    },
    "1": "std::vector<long> odd_list(0);\n    if(n==1)\n        return odd_list;\n    std::vector<long> sorted_list(0);\n    // Sort the odd numbers in increasing order in the sorted list\n    if(n%2==0) {\n        odd_list.push_back(n);\n        sorted_list.push_back(n);\n    }\n    else {\n        for(long i=3; i<n; i+=2) {\n            if(n%i==0) {\n                if(i%2==1)\n                    odd_list.push_back(n);\n                else\n                    odd_list.push_back(n/i);\n                sorted_list.push_back(n);\n            }\n        }\n        odd_list.push_back(n);\n    }\n    for(long i=3; i<n; i+=2) {\n        if(n%i==0) {\n            if(i%2==1) {\n                if(i%3==0)\n                    odd_list.push_back(n);\n                else\n                    odd_list.push_back(n/i);\n                sorted_list.push_back(n);\n            }\n            else\n                odd_list.push_back(n/i);\n        }\n    }\n    odd_list.push_back(n);\n    return sorted_list;",
    "grade-1": {
      "execution": 0
    },
    "2": "std::vector< std::pair<long long int ,long long int> > seq;\n\t// base case\n\tif (n <= 1) {\n\t\tseq.push_back(std::make_pair(n, 1));\n\t\treturn seq;\n\t}\n\t// recursive case\n\tlong long int last_val = n;\n\tlong long int next_val = 1;\n\twhile (next_val * 2 <= last_val) {\n\t\tnext_val += last_val;\n\t\tlast_val = next_val;\n\t\tseq.push_back(std::make_pair(last_val, next_val));\n\t}\n\tseq.push_back(std::make_pair(last_val, 1));\n\treturn seq;",
    "grade-2": {
      "execution": 0
    },
    "3": "// TODO: Write - Your - Code\n\tstd::vector<long> res;\n\tres.push_back(n);\n\twhile (n > 1) {\n\t\tif (n % 2 == 0) {\n\t\t\tn = n / 2;\n\t\t}\n\t\telse {\n\t\t\tn = 3 * n + 1;\n\t\t}\n\t\tif (n % 2 != 0) {\n\t\t\tres.push_back(n);\n\t\t}\n\t}\n\tstd::sort(res.begin(), res.end());\n\treturn res;",
    "grade-3": {
      "execution": 0
    },
    "4": "std::vector<long> result;\n    if (n == 1) {\n        result.push_back(1);\n        return result;\n    }\n    std::unordered_set<long> odd_numbers;\n    odd_numbers.insert(n);\n    while (n != 1) {\n        if (n % 2 == 0) {\n            n = n / 2;\n        } else {\n            n = (3 * n) + 1;\n            odd_numbers.insert(n);\n        }\n    }\n    std::unordered_set<long>::iterator itr;\n    for (itr = odd_numbers.begin(); itr != odd_numbers.end(); itr++) {\n        result.push_back(*itr);\n    }\n    std::sort(result.begin(), result.end());\n    return result;",
    "grade-4": {
      "execution": 0
    },
    "5": "std::vector<long> collatz_sequence;\n    collatz_sequence.push_back(n);\n    while(n!=1) {\n        if(n%2==0) {\n            n = n/2;\n        } else {\n            n = (3*n) + 1;\n        }\n        collatz_sequence.push_back(n);\n    }\n    std::vector<long> odd_collatz_sequence;\n    for(int i=0; i<collatz_sequence.size(); i++) {\n        if(collatz_sequence[i]%2!=0) {\n            odd_collatz_sequence.push_back(collatz_sequence[i]);\n        }\n    }\n    return odd_collatz_sequence;",
    "grade-5": {
      "execution": 0
    }
  },
  {
    "intent": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a list of two strings, both strings consist of open\n// parentheses '(' or close parentheses ')' only.\n// Your job is to check if it is possible to concatenate the two strings in\n// some order, that the resulting string will be good.\n// A string S is considered to be good if and only if all parentheses in S\n// are balanced. For example: the string '(())()' is good, while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n// Examples:\n// match_parens(['()(', ')']) == 'Yes'\n// match_parens([')', ')']) == 'No'\nstd::string match_parens(std::vector<std::string> lst) {\n",
    "task_id": "119",
    "prompt": "/*\nYou are given a vector of two strings, both strings consist of open\nparentheses '(' or close parentheses ')' only.\nYour job is to check if it is possible to concatenate the two strings in\nsome order, that the resulting string will be good.\nA string S is considered to be good if and only if all parentheses in S\nare balanced. For example: the string \"(())()\" is good, while the string\n\"())\" is not.\nReturn \"Yes\" if there's a way to make a good string, and return \"No\" otherwise.\n\nExamples:\nmatch_parens({\"()(\", \")\"}) == \"Yes\"\nmatch_parens({\")\", \")\"}) == \"No\"\n*/\n#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\nstring match_parens(vector<string> lst){\n",
    "simplified_intent": "You are given a list of two strings, both strings consist of open parentheses '(' or close parentheses ')' only. Your job is to check if it is possible to concatenate the two strings in some order, that the resulting string will be good. A string S is considered to be good if and only if all parentheses in S are balanced. For example: the string '(())()' is good, while the string '())' is not. Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.",
    "snippet": [
      "    string l1=lst[0]+lst[1];\n    int i,count=0;\n    bool can=true;\n    for (i=0;i<l1.length();i++)\n        {\n            if (l1[i]=='(') count+=1;\n            if (l1[i]==')') count-=1;\n            if (count<0) can=false;\n        }\n    if (count!=0) return \"No\";\n    if (can==true) return \"Yes\";\n    l1=lst[1]+lst[0];\n    can=true;\n    for (i=0;i<l1.length();i++)\n        {\n            if (l1[i]=='(') count+=1;\n            if (l1[i]==')') count-=1;\n            if (count<0) can=false;\n        }\n    if (can==true) return \"Yes\";\n    return \"No\";\n}\n"
    ],
    "sample_from": {
      "0": "incoder",
      "1": "incoder",
      "2": "incoder",
      "3": "codex",
      "4": "codex",
      "5": "codex"
    },
    "0": "int len = lst.size();\n    char flag = 'N';\n    for (int i = 0; i < len; i++) {\n        if (lst[i].at(0) == ')') {\n            flag = 'Y';\n            break;\n        }\n    }\n    return flag;",
    "grade-0": {
      "execution": 0
    },
    "1": "std::string s = \"()\";\n    std::stack<char> st;\n    for (size_t i = 0; i < lst.size(); i++) {\n        if (lst[i] == '(') st.push(')');\n        else if (lst[i] == ')') st.pop();\n        else if (st.empty() && lst[i] == ')') return \"No\";\n        else if (st.top() == '(' && lst[i] == st.top()) st.pop();\n        else s = lst[i] + s;\n    }\n    return st.empty() ? \"Yes\" : \"No\";",
    "grade-1": {
      "execution": 0
    },
    "2": "// Your code here\n  std::stack<int> st;\n  st.push(0);\n  st.push(0);\n  for (auto itr : lst) {\n    if (itr == \"(\") {\n      st.push(0);\n    } else {\n      while (st.top() > 1) {\n        if (itr == \")\") {\n          st.push(0);\n        } else {\n          st.pop();\n        }\n      }\n      st.push(itr);\n    }\n  }\n  if (st.top() == 1) {\n    return \"Yes\";\n  } else {\n    return \"No\";\n  }",
    "grade-2": {
      "execution": 0
    },
    "3": "int count = 0;\n\tfor (int i = 0; i < lst.size(); i++) {\n\t\tfor (int j = 0; j < lst[i].size(); j++) {\n\t\t\tif (lst[i][j] == '(') {\n\t\t\t\tcount++;\n\t\t\t} else {\n\t\t\t\tcount--;\n\t\t\t}\n\t\t\tif (count < 0) {\n\t\t\t\treturn \"No\";\n\t\t\t}\n\t\t}\n\t}\n\tif (count == 0) {\n\t\treturn \"Yes\";\n\t} else {\n\t\treturn \"No\";\n\t}",
    "grade-3": {
      "execution": 0
    },
    "4": "std::string first=lst[0];\n    std::string second=lst[1];\n    first.append(second);\n    std::stack<char> s;\n    for(auto c:first){\n        if(c=='('){\n            s.push(c);\n        }\n        else{\n            if(s.empty()){\n                return \"No\";\n            }\n            s.pop();\n        }\n    }\n    if(s.empty()){\n        return \"Yes\";\n    }\n    return \"No\";",
    "grade-4": {
      "execution": 0
    },
    "5": "std::vector<char> t;\n  for (auto &i : lst) {\n    for (auto &j : i) {\n      if (j == '(') {\n        t.push_back(j);\n      } else {\n        if (t.size() == 0) {\n          return \"No\";\n        }\n        t.pop_back();\n      }\n    }\n  }\n  if (t.size() == 0) {\n    return \"Yes\";\n  }\n  return \"No\";",
    "grade-5": {
      "execution": 0
    }
  },
  {
    "intent": "#include<assert.h>\n#include<bits/stdc++.h>\n// pairs_sum_to_zero takes a list of integers as an input.\n// it returns True if there are two distinct elements in the list that\n// sum to zero, and False otherwise.\n// >>> pairs_sum_to_zero([1, 3, 5, 0])\n// False\n// >>> pairs_sum_to_zero([1, 3, -2, 1])\n// False\n// >>> pairs_sum_to_zero([1, 2, 3, 7])\n// False\n// >>> pairs_sum_to_zero([2, 4, -5, 3, 5, 7])\n// True\n// >>> pairs_sum_to_zero([1])\n// False\nbool pairs_sum_to_zero(std::vector<long> l) {\n",
    "task_id": "43",
    "prompt": "/*\npairs_sum_to_zero takes a vector of integers as an input.\nit returns true if there are two distinct elements in the vector that\nsum to zero, and false otherwise.\n>>> pairs_sum_to_zero({1, 3, 5, 0})\nfalse\n>>> pairs_sum_to_zero({1, 3, -2, 1})\nfalse\n>>> pairs_sum_to_zero({1, 2, 3, 7})\nfalse\n>>> pairs_sum_to_zero({2, 4, -5, 3, 5, 7})\ntrue\n>>> pairs_sum_to_zero({1})\nfalse\n*/\n#include<stdio.h>\n#include<vector>\nusing namespace std;\nbool pairs_sum_to_zero(vector<int> l){\n",
    "simplified_intent": "pairs_sum_to_zero takes a list of integers as an input. it returns True if there are two distinct elements in the list that sum to zero, and False otherwise.",
    "snippet": [
      "    for (int i=0;i<l.size();i++)\n    for (int j=i+1;j<l.size();j++)\n    if (l[i]+l[j]==0) return true;\n    return false;\n}\n"
    ],
    "sample_from": {
      "0": "incoder",
      "1": "incoder",
      "2": "incoder",
      "3": "codex",
      "4": "codex",
      "5": "codex"
    },
    "0": "int n = l.size();\n    if (n <= 2) {\n        return false;\n    }\n    long k = l.back();\n    for (int i = 1; i < n; i++) {\n        k = k + l[i];\n        if (k == 0) {\n            return true;\n        }\n    }\n    return false;",
    "grade-0": {
      "execution": 0
    },
    "1": "// TODO: Check if there exist two distinct elements that sum zero.\n    return false;",
    "grade-1": {
      "execution": 0
    },
    "2": "int n = l.size();\n    // use unordered_set to keep track of\n    // unique elements, keep track of indexes\n    std::unordered_set<long> s;\n    std::vector<int> p;\n    int i = 0;\n    long cur = l[0];\n    bool res = false;\n    // check for duplicates\n    if (s.size() >= n) {\n        for (size_t j = 0; j < i; j++) {\n            if (s.find(l[j]) != s.end()) {\n                res = true;\n                break;\n            }\n        }\n    }\n    else res = true;\n    // if there are no duplicates, check for pairs\n    if (res == true) {\n        long sum = 0;\n        for (size_t j = 0; j < i; j++) {\n            sum += l[j];\n        }\n        if (sum == 0) {\n            for (size_t j = 0; j < i; j++) {\n                if (l[j] < 0) {\n                    p.push_back(j);\n                }\n            }\n            if (p.size() >= 2) {\n                s = std::unordered_set<long>();\n                p.clear();\n                i = 0;\n                cur = l[i];\n                // check for duplicates\n                if (s.size() >= n) {\n                    for (size_t j = 0; j < i; j++) {\n                        if (s.find(l[j]) != s.end()) {\n                            res = true;\n                            break;\n                        }\n                    }\n                }\n                else res = true;\n                // if there are no duplicates, check for pairs\n                if (res == true) {\n                    for (size_t j = 0; j < i; j++) {\n                        sum += l[j];\n                    }\n                    if (sum == 0) {\n                        for (size_t j = 0; j < i; j++) {\n                            if (l[j] < 0) {\n                                p.push_back(j);\n                            }\n                        }\n                        if (p.size() >= 2) {\n                            s = std::unordered_set<long>();\n                            p.clear();\n                            i = 0;\n                            cur = l[i];\n                            // check for duplicates\n                            if (s.size() >= n) {\n                                for (size_t j = 0; j < i; j++) {\n                                    if (s.find(l[j]) != s.end()) {\n                                        res = true;\n                                        break;\n                                    }\n                                }\n                            }\n                            else res = true;\n                            // if there are no duplicates, check for pairs\n                            if (res == true) {\n                                for (size_t j = 0; j < i; j++) {\n                                    sum += l[j];\n                                }\n                                if (sum == 0) {\n                                    for (size_t j = 0; j < i; j++) {\n                                        if (l[j] < 0) {\n                                            p.push_back(j);\n                                        }\n                                    }\n                                    if (p.size() >= 2) {\n                                        s = std::unordered_set<long>();\n                                        p.clear();\n                                        i = 0;\n                                        cur = l[i];\n                                        // check for duplicates\n                                        if (s.size() >= n) {\n                                            for (size_t j = 0; j < i; j++) {\n                                                if (s.find(l[j]) != s.end()) {\n                                                    res = true;\n                                                    break;\n                                                }\n                                            }\n                                        }\n                                        else res = true;\n                                        // if there are no",
    "grade-2": {
      "execution": 0
    },
    "3": "std::unordered_set<long> set1;\n    for(long i = 0; i < l.size(); i++){\n        long current = l[i];\n        if(set1.find(-current) != set1.end()){\n            return true;\n        }\n        set1.insert(current);\n    }\n    return false;",
    "grade-3": {
      "execution": 1
    },
    "4": "std::set<long> s;\n    for (auto it = l.begin(); it != l.end(); it++) {\n        if (s.find(-(*it)) != s.end()) {\n            return true;\n        }\n        s.insert(*it);\n    }\n    return false;",
    "grade-4": {
      "execution": 1
    },
    "5": "// return false if there is only one element in the vector\n    if (l.size() == 1) {\n        return false;\n    }\n\n    // return true if there are two elements that equal to zero\n    for (int i = 0; i < l.size(); i++) {\n        for (int j = i + 1; j < l.size(); j++) {\n            if (l[i] + l[j] == 0) {\n                return true;\n            }\n        }\n    }\n\n    // if the program does not return true, it must return false\n    return false;",
    "grade-5": {
      "execution": 1
    }
  },
  {
    "intent": "#include<assert.h>\n#include<bits/stdc++.h>\n// In this task, you will be given a string that represents a number of apples and oranges \n// that are distributed in a basket of fruit this basket contains \n// apples, oranges, and mango fruits. Given the string that represents the total number of \n// the oranges and apples and an integer that represent the total number of the fruits \n// in the basket return the number of the mango fruits in the basket.\n// for examble:\n// fruit_distribution(\"5 apples and 6 oranges\", 19) ->19 - 5 - 6 = 8\n// fruit_distribution(\"0 apples and 1 oranges\",3) -> 3 - 0 - 1 = 2\n// fruit_distribution(\"2 apples and 3 oranges\", 100) -> 100 - 2 - 3 = 95\n// fruit_distribution(\"100 apples and 1 oranges\",120) -> 120 - 100 - 1 = 19\nlong fruit_distribution(std::string s, long n) {\n",
    "task_id": "67",
    "prompt": "/*\nIn this task, you will be given a string that represents a number of apples and oranges \nthat are distributed in a basket of fruit this basket contains \napples, oranges, and mango fruits. Given the string that represents the total number of \nthe oranges and apples and an integer that represent the total number of the fruits \nin the basket return the number of the mango fruits in the basket.\nfor example:\nfruit_distribution(\"5 apples and 6 oranges\", 19) ->19 - 5 - 6 = 8\nfruit_distribution(\"0 apples and 1 oranges\",3) -> 3 - 0 - 1 = 2\nfruit_distribution(\"2 apples and 3 oranges\", 100) -> 100 - 2 - 3 = 95\nfruit_distribution(\"100 apples and 1 oranges\",120) -> 120 - 100 - 1 = 19\n*/\n#include<stdio.h>\n#include<string>\nusing namespace std;\nint fruit_distribution(string s,int n){\n",
    "simplified_intent": "In this task, you will be given a string that represents a number of apples and oranges that are distributed in a basket of fruit this basket contains apples, oranges, and mango fruits. Given the string that represents the total number of the oranges and apples and an integer that represent the total number of the fruits in the basket return the number of the mango fruits in the basket.",
    "snippet": [
      "    string num1=\"\",num2=\"\";\n    int is12;\n    is12=0;\n    for (int i=0;i<s.size();i++)\n        \n        if (s[i]>=48 and s[i]<=57)\n        {\n            if (is12==0) num1=num1+s[i];\n            if (is12==1) num2=num2+s[i];\n        }\n        else\n          if (is12==0 and num1.length()>0) is12=1;\n    return n-atoi(num1.c_str())-atoi(num2.c_str());\n\n}\n"
    ],
    "sample_from": {
      "0": "incoder",
      "1": "incoder",
      "2": "incoder",
      "3": "codex",
      "4": "codex",
      "5": "codex"
    },
    "0": "long m=0;\n    for (long i=0;i<s.size();i++)\n    {\n        if (s[i]==\" \" and (i+1)<s.size())\n        {\n            long num=0;\n            long j=i+1;\n            while(s[j]==\" \")\n            {\n                num+=1;\n                j++;\n            }\n            long e=s-i+num;\n            if (e>0) {\n                long x=0;\n                while (num>0)\n                {\n                    x+=e%10;\n                    num/=10;\n                    e=e/10;\n                }\n                m+=x;\n            }\n        }\n    }\n    return m;",
    "grade-0": {
      "execution": 0
    },
    "1": "// Your code goes here\n    long ans = 0, i = 0, pos = 0;\n    while (i != s.size()) {\n        if (s.at(i) == 'o') pos++;\n        else if (s.at(i) == 'a') pos--;\n        i++;\n    }\n    int n1 = 0;\n    for (int j = 0; j < pos; j++) {\n        if (s.at(i) == 'o') n1++;\n        else if (s.at(i) == 'a') n1--;\n        i++;\n    }\n    long n2 = n - n1 - pos;\n    if (n2 > n) n2 = n;\n    else if (n2 < 0) n2 = -n;\n    for (int k = 0; k < n2; k++) {\n        ans += 1;\n    }\n    return ans;",
    "grade-1": {
      "execution": 0
    },
    "2": "int i, j, count = 0;\n  long sum = 0;\n  \n  // get total number of orange and apple in the basket\n  i = 0; j = n-1;\n  while (i <= j){\n    if(s[i] == ' ' && s[j] == ' '){\n      i++;\n      j--;\n    }else if(s[i] == 'a' || s[i] == 'A' || s[j] == 'o' || s[j] == 'O'){\n      i++;\n      j--;\n    }else{\n      i++;\n      j--;\n    }\n  }\n  \n  // get total number of fruit in the basket\n  i = n - 1;\n  while(i >= 0){\n    if(s[i] == ' '){\n      i--;\n    }\n    else{\n      i++;\n    }\n  }\n  \n  // calculate mango fruit number\n  while(i>=0){\n    if(s[i] == 'm'){\n      sum+=i;\n      count++;\n      i-=2;\n    }\n    else{\n      sum+=i;\n      count++;\n      i-=2;\n    }\n  }\n  \n  return count;",
    "grade-2": {
      "execution": 0
    },
    "3": "// Get the number of apples and oranges from s\n    int apples = atoi(s.substr(0, s.find(\" apples and \")).c_str());\n    int oranges = atoi(s.substr(s.find(\" apples and \") + 12, s.length()).c_str());\n    // Get the number of mango fruits in the basket\n    return n - apples - oranges;",
    "grade-3": {
      "execution": 1
    },
    "4": "if(s.empty())\n    return 0;\n  int orange = 0, apple = 0;\n  std::string tmp;\n  std::stringstream ss(s);\n  while(ss >> tmp){\n    if(tmp == \"apples\"){\n      ss >> tmp;\n      assert(tmp == \"and\");\n      ss >> tmp;\n      apple = std::stoi(tmp);\n    }\n    else if(tmp == \"oranges\"){\n      ss >> tmp;\n      assert(tmp == \"and\");\n      ss >> tmp;\n      orange = std::stoi(tmp);\n    }\n  }\n  return n - apple - orange;",
    "grade-4": {
      "execution": 0
    },
    "5": "std::string tmp = \"\", word = \"\";\n    int c = 0;\n    while(s.size() > 0) {\n        int i = 0;\n        while(s[i] != ' ' && i < s.size()) {\n            tmp += s[i];\n            i++;\n        }\n        for(int j = 0; j < tmp.size(); j++) {\n            if(isdigit(tmp[j])) {\n                word += tmp[j];\n            }\n        }\n        c += std::stoi(word);\n        word = \"\";\n        tmp = \"\";\n        s.erase(0, i+1);\n    }\n    return n - c;",
    "grade-5": {
      "execution": 0
    }
  },
  {
    "intent": "#include<assert.h>\n#include<bits/stdc++.h>\n// Return a string containing space-delimited numbers starting from 0 upto n inclusive.\n// >>> string_sequence(0)\n// '0'\n// >>> string_sequence(5)\n// '0 1 2 3 4 5'\nstd::string string_sequence(long n) {\n",
    "task_id": "15",
    "prompt": "/*\nReturn a string containing space-delimited numbers starting from 0 upto n inclusive.\n>>> string_sequence(0)\n\"0\"\n>>> string_sequence(5)\n\"0 1 2 3 4 5\"\n*/\n#include<stdio.h>\n#include<string>\nusing namespace std;\nstring string_sequence(int n){\n",
    "simplified_intent": "Return a string containing space-delimited numbers starting from 0 upto n inclusive.",
    "snippet": [
      "    string out=\"0\";\n    for (int i=1;i<=n;i++)\n    out=out+\" \"+to_string(i);\n    return out;\n}\n"
    ],
    "sample_from": {
      "0": "incoder",
      "1": "incoder",
      "2": "incoder",
      "3": "codex",
      "4": "codex",
      "5": "codex"
    },
    "0": "if (n < 0)\n        n = 0;\n    std::string s = \"\";\n    for (long i = 0; i < n; i++)\n        s += std::to_string(i) + ' ';\n    return s;",
    "grade-0": {
      "execution": 0
    },
    "1": "// your code goes here\n    std::string res=\"\";\n    for(long i=0;i<n;i++){\n        res+=std::to_string(i);\n    }\n    return res;",
    "grade-1": {
      "execution": 0
    },
    "2": "// Initialize our result\n  std::string result;\n  if (n <= 0) {\n    return \"0\";\n  }\n  // Recursively append the numbers from 1 to n-1\n  result += string_sequence(n - 1) + \" \";\n  // Add the final number\n  result += std::to_string(n - 1);\n  return result;",
    "grade-2": {
      "execution": 0
    },
    "3": "std::string output = \"\";\n  for (long i = 0; i <= n; i++) {\n    output += std::to_string(i);\n    if (i != n) {\n      output += \" \";\n    }\n  }\n  return output;",
    "grade-3": {
      "execution": 1
    },
    "4": "std::string str = \"\";\n    long i;\n    for(i=0;i<=n;i++)\n    {\n        str+=std::to_string(i)+\" \";\n    }\n    return str;",
    "grade-4": {
      "execution": 0
    },
    "5": "std::stringstream result;\n\tfor (long i = 0; i <= n; i++) {\n\t\tresult << i << \" \";\n\t}\n\tstd::string r = result.str();\n\treturn r.substr(0, r.size() - 1);",
    "grade-5": {
      "execution": 1
    }
  },
  {
    "intent": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that returns true if the given number is the multiplication of 3 prime numbers\n// and false otherwise.\n// Knowing that (a) is less then 100. \n// Example:\n// is_multiply_prime(30) == True\n// 30 = 2 * 3 * 5\nbool is_multiply_prime(long a) {\n",
    "task_id": "75",
    "prompt": "/*\nWrite a function that returns true if the given number is the multiplication of 3 prime numbers\nand false otherwise.\nKnowing that (a) is less then 100. \nExample:\nis_multiply_prime(30) == true\n30 = 2 * 3 * 5\n*/\n#include<stdio.h>\nusing namespace std;\nbool is_multiply_prime(int a){\n",
    "simplified_intent": "Write a function that returns true if the given number is the multiplication of 3 prime numbers and false otherwise. Knowing that (a) is less then 100.",
    "snippet": [
      "    int num=0;\n    for (int i=2;i*i<=a;i++)\n    while (a%i==0 and a>i)\n    {\n        a=a/i;\n        num+=1;\n    }\n    if (num==2) return true;\n    return false; \n}\n"
    ],
    "sample_from": {
      "0": "incoder",
      "1": "incoder",
      "2": "incoder",
      "3": "codex",
      "4": "codex",
      "5": "codex"
    },
    "0": "bool flag = false;\n    // We assume that all numbers are less then 100\n    assert(a < 100);\n    long l1, l2, l3, n1, n2, n3;\n    n1 = l2 = l3 = a; \n    // Loop until we reach to zero\n    while (n1 < 100) {\n        // Loop until we reach to zero\n        while (n2 < 100) {\n            // Loop until we reach to zero\n            while (n3 < 100) {\n                // Loop until we reach to zero\n                while (n3 != 0) {\n                    // We check whether all number are less than 100\n                    if (n1 < n2) { \n                        if (n1 < n3) { \n                            if (n2 < n3) {\n                                // If numbers are less than 100\n                                // Then we assume that all numbers are less, then multiply them and store in n3\n                                n3 = n1 * n2 * n3;\n                                // If numbers are less than 100\n                                // Then we assume that all numbers are less, then multiply them and store in n3\n                                flag = true;\n                            } else {\n                                // If numbers are less than 100\n                                // Then we assume that all numbers are less, then multiply them and store in n3\n                                n3 = n1 * n3;\n                                // If numbers are less than 100\n                                // Then we assume that all numbers are less, then multiply them and store in n3\n                                flag = true;\n                            }\n                        } else {\n                            // If numbers are less than 100\n                            // Then we assume that all numbers are less, then multiply them and store in n3\n                            n3 = n2;\n                            // If numbers are less than 100\n                            // Then we assume that all numbers are less, then multiply them and store in n3\n                            flag = true;\n                        }\n                    } else {\n                        // If numbers are less than 100\n                        // Then we assume that all numbers are less, then multiply them and store in n3\n                        n3 = n2;\n                        // If numbers are less than 100\n                        // Then we assume that all numbers are less, then multiply them and store in n3\n                        flag = true;\n                    }\n                    // We increment all numbers\n                    n1++;\n                    n2++;\n                    n3++;\n                }\n                // We increment all numbers\n                n2++;\n                l3 = n3;\n                // If numbers are less than 100\n                // Then we assume that all numbers are less, then multiply them and store in n3\n                flag = true;\n            }\n            // We increment all numbers\n            n1++;\n            l2 = n2;\n            // If numbers are less than 100\n            // Then we assume that all numbers are les",
    "grade-0": {
      "execution": 0
    },
    "1": "if(a==0) return false;\n    \n    long b = 2 ;\n    while (b*b <= a && b < 100) {\n        if (a % b == 0) {\n            return false;\n        }\n        b += 1;\n    }\n    return true;",
    "grade-1": {
      "execution": 0
    },
    "2": "// Write your implementation\n    if(a%2==0){\n        return false;\n    }\n    if(a%10==0){\n        return false;\n    }\n    if(a%5==0){\n        return false;\n    }\n    if(a%7==0){\n        return false;\n    }\n    if(a%3==0){\n        return false;\n    }\n    if(a%11==0){\n        return false;\n    }\n    if(a%13==0){\n        return false;\n    }\n    if(a%17==0){\n        return false;\n    }\n    if(a%19==0){\n        return false;\n    }\n    return true;",
    "grade-2": {
      "execution": 0
    },
    "3": "// TODO: Write your code here.\n\tstd::vector<long> v;\n\tfor (long i = 2; i <= a; i++) {\n\t\twhile (a % i == 0) {\n\t\t\tv.push_back(i);\n\t\t\ta /= i;\n\t\t}\n\t}\n\tif (v.size() != 3)\n\t\treturn false;\n\telse\n\t\treturn true;",
    "grade-3": {
      "execution": 1
    },
    "4": "// your code here\n   for(int i=2;i<=a;i++){\n   \tif(a%i==0){\n   \t\tint count=0;\n   \t\tint j=1;\n   \t\twhile(j<=i){\n   \t\t\tif(i%j==0){\n   \t\t\t\tcount++;\n\t\t\t   }\n\t\t\t   j++;\n\t\t   }\n\t\t   if(count==2){\n\t\t   \ta=a/i;\n\t\t   \tbreak;\n\t\t   }\n\t   }\n   }\n   \tfor(int i=2;i<=a;i++){\n   \tif(a%i==0){\n   \t\tint count=0;\n   \t\tint j=1;\n   \t\twhile(j<=i){\n   \t\t\tif(i%j==0){\n   \t\t\t\tcount++;\n\t\t\t   }\n\t\t\t   j++;\n\t\t   }\n\t\t   if(count==2){\n\t\t   \ta=a/i;\n\t\t   \tbreak;\n\t\t   }\n\t   }\n   }\n   \tfor(int i=2;i<=a;i++){\n   \tif(a%i==0){\n   \t\tint count=0;\n   \t\tint j=1;\n   \t\twhile(j<=i){\n   \t\t\tif(i%j==0){\n   \t\t\t\tcount++;\n\t\t\t   }\n\t\t\t   j++;\n\t\t   }\n\t\t   if(count==2){\n\t\t   \ta=a/i;\n\t\t   \tbreak;\n\t\t   }\n\t   }\n   }\n   if(a==1){\n   \treturn true;\n   }\n   \n   return false;",
    "grade-4": {
      "execution": 0
    },
    "5": "",
    "grade-5": {
      "execution": 0
    }
  },
  {
    "intent": "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive floating point number, it can be decomposed into\n// and integer part (largest integer smaller than given number) and decimals\n// (leftover part always smaller than 1).\n// Return the decimal part of the number.\n// >>> truncate_number(3.5)\n// 0.5\nfloat truncate_number(float number) {\n",
    "task_id": "2",
    "prompt": "/*\nGiven a positive floating point number, it can be decomposed into\nand integer part (largest integer smaller than given number) and decimals\n(leftover part always smaller than 1).\n\nReturn the decimal part of the number.\n>>> truncate_number(3.5)\n0.5\n*/\n#include<stdio.h>\n#include<math.h>\nusing namespace std;\nfloat truncate_number(float number){\n",
    "simplified_intent": "Given a positive floating point number, it can be decomposed into and integer part (largest integer smaller than given number) and decimals (leftover part always smaller than 1). Return the decimal part of the number.",
    "snippet": [
      "    return number-int(number);\n}\n"
    ],
    "sample_from": {
      "0": "incoder",
      "1": "incoder",
      "2": "incoder",
      "3": "codex",
      "4": "codex",
      "5": "codex"
    },
    "0": "int integer = abs((int)(number));\n  if (number == (float)integer) {\n    return 0.0;\n  }\n  if (integer == (integer)0) {\n    return number;\n  }\n  return number - integer;",
    "grade-0": {
      "execution": 0
    },
    "1": "int integerPart = (int)(number);\n    float decimalPart = number - integerPart;\n    return (decimalPart);",
    "grade-1": {
      "execution": 1
    },
    "2": "assert(number > 0.0);\n  assert(number < 1.0);\n  float integerPart = static_cast<float>(static_cast<double>(number) % 1);\n  float decimalPart = static_cast<float>(number) - integerPart;\n  return integerPart + decimalPart;",
    "grade-2": {
      "execution": 0
    },
    "3": "// typecast to int in order to truncate\n  return number - (int)number;",
    "grade-3": {
      "execution": 1
    },
    "4": "// Add any missing code\n\tfloat f_intpart;\n\n\treturn modff(number, &f_intpart);",
    "grade-4": {
      "execution": 1
    },
    "5": "// write your code here\n    if(number < 0){\n        number = number * -1;\n    }\n    return number - (int)number;",
    "grade-5": {
      "execution": 1
    }
  },
  {
    "intent": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nstd::string get_closest_vowel(std::string word) {\n",
    "task_id": "118",
    "prompt": "/*\nYou are given a word. Your task is to find the closest vowel that stands between \ntwo consonants from the right side of the word (case sensitive).\n\nVowels in the beginning and ending doesn't count. Return empty string if you didn't\nfind any vowel met the above condition. \n\nYou may assume that the given string contains English letter only.\n\nExample:\nget_closest_vowel(\"yogurt\") ==> \"u\"\nget_closest_vowel(\"FULL\") ==> \"U\"\nget_closest_vowel(\"quick\") ==> \"\"\nget_closest_vowel(\"ab\") ==> \"\"\n*/\n#include<stdio.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\nstring get_closest_vowel(string word){\n",
    "simplified_intent": "You are given a word. Your task is to find the closest vowel that stands between two consonants from the right side of the word (case sensitive). Vowels in the beginning and ending doesn't count. Return empty string if you didn't find any vowel met the above condition. You may assume that the given string contains English letter only.",
    "snippet": [
      "    string out=\"\";\n    string vowels=\"AEIOUaeiou\";\n    for (int i=word.length()-2;i>=1;i-=1)\n        if (find(vowels.begin(),vowels.end(),word[i])!=vowels.end())\n            if (find(vowels.begin(),vowels.end(),word[i+1])==vowels.end())\n                if (find(vowels.begin(),vowels.end(),word[i-1])==vowels.end())\n                    return out+word[i];\n    return out;\n}\n"
    ],
    "sample_from": {
      "0": "incoder",
      "1": "incoder",
      "2": "incoder",
      "3": "codex",
      "4": "codex",
      "5": "codex"
    },
    "0": "int n = word.size();\n    \n    for(int i = 0; i < n; i++) {\n        if(word[i] == word[n-1]) {\n            return word[i];\n        }\n    }\n    \n    for(int i = n-2; i >= 0; i--) {\n        if(word[i] == word[i+1]) {\n            return word[i];\n        }\n    }\n    \n    return \"\";",
    "grade-0": {
      "execution": 0
    },
    "1": "assert(word.size() >= 2 && word.size() <= word.length());\n    int n = word.length();\n    bool flag = false;\n    int mid = (n - 1) >> 1;\n    for (int i = 1; i < mid; i *= 2) {\n        if (word.at(i) != word.at(i - 1) &&\n            word.at(i) != word.at(i - 2) &&\n            word.at(i) != word.at(i - 3)) {\n            flag = true;\n        }\n    }\n    if (flag) {\n        return word;\n    }\n    int left = 0, right = n - 1;\n    while (left <= right) {\n        int mid = (left + right) / 2;\n        if (word.at(mid) == word.at(mid)) {\n            left = mid;\n            right = mid;\n        }\n        else if (word.at(mid) == word.at(mid) + word.at(mid)) {\n            right = mid;\n        }\n        else {\n            left = mid + 1;\n        }\n    }\n    int left = n - 1;\n    while (left > 0) {\n        int mid = (left + n - 1) / 2;\n        if (word.at(mid) == word.at(mid)) {\n            left = mid;\n        }\n        else if (word.at(mid) == word.at(mid) - word.at(mid)) {\n            right = mid;\n        }\n        else {\n            left = mid;\n        }\n    }\n    return \"\";",
    "grade-1": {
      "execution": 0
    },
    "2": "int size = word.length();\n\tint vowel_count = 0;\n\tint last_vowel = 0;\n\tstd::string vowel;\n\tstd::string consonant;\n\tint index = 0;\n\tint consonant_index = 0;\n\tfor (; index < size; ++index) {\n\t\tif (word[index] == 'a' || word[index] == 'e' || word[index] == 'i' || word[index] == 'o' || word[index] == 'u') {\n\t\t\tvowel_count += 1;\n\t\t\tvowel = word[index];\n\t\t}\n\t\tif (word[index] == 'a' || word[index] == 'e' || word[index] == 'i' || word[index] == 'o' || word[index] == 'u') {\n\t\t\tlast_vowel = index;\n\t\t}\n\t\tif (word[index] == 'a') {\n\t\t\tconsonant_index = 1;\n\t\t}\n\t\tif (word[index] == 'e') {\n\t\t\tconsonant_index = 2;\n\t\t}\n\t\tif (word[index] == 'i') {\n\t\t\tconsonant_index = 3;\n\t\t}\n\t\tif (word[index] == 'o') {\n\t\t\tconsonant_index = 4;\n\t\t}\n\t\tif (word[index] == 'u') {\n\t\t\tconsonant_index = 5;\n\t\t}\n\t}\n\tfor (int i = 0; i <= (vowel_count - 1); i++) {\n\t\tif (vowel == word[last_vowel + consonant_index]) {\n\t\t\treturn vowel;\n\t\t}\n\t}\n\treturn \"\";",
    "grade-2": {
      "execution": 0
    },
    "3": "// Very good check here\n    if (word.size()<=2)\n        return \"\";\n    std::vector<char> vowels = {'a','e','i','o','u','A','E','I','O','U'};\n    int index = word.size()-1;\n    // since if the last character is a vowel, we need to check backward\n    if (std::find(vowels.begin(), vowels.end(), word[index]) != vowels.end())\n        index--;\n    for (int i=index; i>=0; i--) {\n        // Find the first vowel that's between two consonants\n        if (std::find(vowels.begin(), vowels.end(), word[i]) != vowels.end()) {\n            // if the first char is a vowel, we need to check forward\n            if (i==0) {\n                if (std::find(vowels.begin(), vowels.end(), word[i+1]) == vowels.end())\n                    return std::string(1, word[i]);\n            }\n            // if there is a vowel before it and a vowel after it, we need to check the next\n            else if (std::find(vowels.begin(), vowels.end(), word[i-1]) != vowels.end() ||\n                std::find(vowels.begin(), vowels.end(), word[i+1]) != vowels.end())\n                continue;\n            // else if there is a vowel before it, we need to check forward\n            else if (std::find(vowels.begin(), vowels.end(), word[i-1]) != vowels.end()) {\n                if (std::find(vowels.begin(), vowels.end(), word[i+1]) == vowels.end())\n                    return std::string(1, word[i]);\n            }\n            // else it must be a vowel after it\n            else\n                return std::string(1, word[i]);\n        }\n    }\n    return \"\";",
    "grade-3": {
      "execution": 0
    },
    "4": "bool firstVowel = false;\n  std::string vowels(\"aeiouAEIOU\");\n  std::string found(\"\");\n  for (int i = 0; i < word.length(); i++) {\n    if (vowels.find(word[i]) == std::string::npos) {\n      if (firstVowel) {\n        found = \"\";\n        firstVowel = false;\n      }\n    } else {\n      if (found == \"\") {\n        found = word[i];\n        firstVowel = true;\n      }\n    }\n  }\n  return found;",
    "grade-4": {
      "execution": 0
    },
    "5": "int previous = -1;\n    int next = -1;\n    int current = -1;\n    char vowels[] = {'a', 'e', 'i', 'o', 'u'};\n    for (int i = word.length() - 1; i >= 0; i--) {\n        current = i;\n        for (int j = 0; j < 5; j++) {\n            if (word[i] == vowels[j]) {\n                if (previous != -1 && next != -1) {\n                    if (current - previous > next - current) {\n                        return word.substr(next, 1);\n                    } else {\n                        return word.substr(previous, 1);\n                    }\n                } else if (previous != -1) {\n                    return word.substr(previous, 1);\n                } else if (next != -1) {\n                    return word.substr(next, 1);\n                }\n            }\n        }\n        if (previous == -1) {\n            previous = current;\n        } else if (next == -1) {\n            next = current;\n        }\n    }\n    return \"\";",
    "grade-5": {
      "execution": 0
    }
  },
  {
    "intent": "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number in decimal form and your task is to convert it to\n// binary format. The function should return a string, with each character representing a binary\n// number. Each character in the string will be '0' or '1'.\n// There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n// The extra characters are there to help with the format.\n// Examples:\n// decimal_to_binary(15)   # returns \"db1111db\"\n// decimal_to_binary(32)   # returns \"db100000db\"\nstd::string decimal_to_binary(long decimal) {\n",
    "task_id": "79",
    "prompt": "/*\nYou will be given a number in decimal form and your task is to convert it to\nbinary format. The function should return a string, with each character representing a binary\nnumber. Each character in the string will be '0' or '1'.\n\nThere will be an extra couple of characters \"db\" at the beginning and at the end of the string.\nThe extra characters are there to help with the format.\n\nExamples:\ndecimal_to_binary(15)   // returns \"db1111db\"\ndecimal_to_binary(32)   // returns \"db100000db\"\n*/\n#include<stdio.h>\n#include<string>\nusing namespace std;\nstring decimal_to_binary(int decimal){\n",
    "simplified_intent": "You will be given a number in decimal form and your task is to convert it to binary format. The function should return a string, with each character representing a binary number. Each character in the string will be '0' or '1'. There will be an extra couple of characters 'db' at the beginning and at the end of the string. The extra characters are there to help with the format.",
    "snippet": [
      "    string out=\"\";\n    if (decimal==0) return \"db0db\";\n    while (decimal>0)\n    {\n        out=to_string(decimal%2)+out;\n        decimal=decimal/2;\n    }\n    out=\"db\"+out+\"db\";\n    return out;\n}\n"
    ],
    "sample_from": {
      "0": "incoder",
      "1": "incoder",
      "2": "incoder",
      "3": "codex",
      "4": "codex",
      "5": "codex"
    },
    "0": "long remainder = decimal % 2;\n    std::string binary = \"db\";\n    std::string binary_temp;\n    while(decimal > 0){\n        if(decimal % 2 == 0){\n            binary_temp += remainder ? '0' : '1';\n        }\n        remainder = decimal % 2;\n        decimal /= 2;\n    }\n    binary = binary + binary_temp + remainder;\n    return binary + \"db\";",
    "grade-0": {
      "execution": 0
    },
    "1": "int remainder, num;\n    std::string binary;\n    num = decimal;\n\n    while (num > 0) {\n        remainder = num % 2;\n        num = num / 2;\n        binary.push_back(remainder);\n    }\n    return binary;",
    "grade-1": {
      "execution": 0
    },
    "2": "// Your code goes here\n    char output[10];\n    char* charArray = new char[10];\n    if (decimal < 0) {\n        charArray[0] = '-';\n        decimal ^= decimal;\n        decimal ^= decimal;\n        decimal ^= decimal;\n    }\n    decimal &= 1;\n    charArray[1] = 'd';\n    int i = 0;\n    while (decimal != 0) {\n        decimal /= 2;\n        charArray[i] = '0';\n        i++;\n    }\n    charArray[i] = 'b';\n    return std::string(charArray);",
    "grade-2": {
      "execution": 0
    },
    "3": "std::string binary;\n  while (decimal) {\n    binary.push_back(decimal % 2 ? '1' : '0');\n    decimal /= 2;\n  }\n  return \"db\" + std::string(32 - binary.size(), '0') + binary + \"db\";",
    "grade-3": {
      "execution": 0
    },
    "4": "// add your code here\n  std::string result = \"db\";\n  if (decimal == 0) {\n    result += \"0\";\n  } else {\n    int divisor = 2;\n    int remainder = decimal;\n    while (divisor <= decimal) {\n      divisor *= 2;\n    }\n    divisor /= 2;\n    while (divisor >= 1) {\n      if (remainder >= divisor) {\n        result += \"1\";\n        remainder -= divisor;\n      } else {\n        result += \"0\";\n      }\n      divisor /= 2;\n    }\n  }\n  result += \"db\";\n  return result;",
    "grade-4": {
      "execution": 1
    },
    "5": "std::string binary = \"db\";\n  long num = decimal;\n  // long num = 0;\n  // std::cin >> num;\n  // std::cout << num << std::endl;\n  std::vector<int> binary_vector;\n  // std::cout << num << std::endl;\n  // std::cout << \"decimal_to_binary(num): \" << decimal_to_binary(num) << std::endl;\n  while (num > 0) {\n    if (num % 2 == 0) {\n      binary_vector.push_back(0);\n    } else {\n      binary_vector.push_back(1);\n    }\n    num /= 2;\n  }\n  // std::cout << binary_vector.size() << std::endl;\n  for (long i = binary_vector.size() - 1; i >= 0; i--) {\n    // std::cout << binary_vector[i] << std::endl;\n    binary += std::to_string(binary_vector[i]);\n  }\n  // std::cout << binary << std::endl;\n  binary += \"db\";\n  return binary;",
    "grade-5": {
      "execution": 0
    }
  },
  {
    "intent": "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a list of numbers, return whether or not they are sorted\n// in ascending order. If list has more than 1 duplicate of the same\n// number, return False. Assume no negative numbers and only integers.\n// Examples\n// is_sorted([5]) \u279e True\n// is_sorted([1, 2, 3, 4, 5]) \u279e True\n// is_sorted([1, 3, 2, 4, 5]) \u279e False\n// is_sorted([1, 2, 3, 4, 5, 6]) \u279e True\n// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279e True\n// is_sorted([1, 3, 2, 4, 5, 6, 7]) \u279e False\n// is_sorted([1, 2, 2, 3, 3, 4]) \u279e True\n// is_sorted([1, 2, 2, 2, 3, 4]) \u279e False\nbool is_sorted(std::vector<long> lst) {\n",
    "task_id": "126",
    "prompt": "/*\nGiven a vector of numbers, return whether or not they are sorted\nin ascending order. If vector has more than 1 duplicate of the same\nnumber, return false. Assume no negative numbers and only integers.\n\nExamples\nis_sorted({5}) \u279e true\nis_sorted({1, 2, 3, 4, 5}) \u279e true\nis_sorted({1, 3, 2, 4, 5}) \u279e false\nis_sorted({1, 2, 3, 4, 5, 6}) \u279e true\nis_sorted({1, 2, 3, 4, 5, 6, 7}) \u279e true\nis_sorted({1, 3, 2, 4, 5, 6, 7}) \u279e false\nis_sorted({1, 2, 2, 3, 3, 4}) \u279e true\nis_sorted({1, 2, 2, 2, 3, 4}) \u279e false\n*/\n#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nbool is_sorted(vector<int> lst){\n",
    "simplified_intent": "Given a list of numbers, return whether or not they are sorted in ascending order. If list has more than 1 duplicate of the same number, return False. Assume no negative numbers and only integers.",
    "snippet": [
      "    for (int i=1;i<lst.size();i++)\n    {\n        if (lst[i]<lst[i-1]) return false;\n        if (i>=2 and lst[i]==lst[i-1] and lst[i]==lst[i-2]) return false;\n    }\n    return true;\n}\n"
    ],
    "sample_from": {
      "0": "incoder",
      "1": "incoder",
      "2": "incoder",
      "3": "codex",
      "4": "codex",
      "5": "codex"
    },
    "0": "// sort first and check for equality with original array\n    // std::sort(lst.begin(), lst.end());\n    std::sort(lst.begin(), lst.end(), std::less<long>());\n\n    // iterate until lst is unsorted\n    // return false\n    for (long i = 0, j = lst.size() - 1; i < j; i++, j--) {\n        if (lst[i] != lst[j])\n            return false;\n    }\n    return true;",
    "grade-0": {
      "execution": 0
    },
    "1": "if (lst.size() == 0) {\n        return true;\n    }\n    if (lst.size() == 1) {\n        return true;\n    }\n\n    // Use a map to keep track of how many of each number we have.\n    std::map<long, long> mp;\n    for (long x: lst) {\n        mp[x]++;\n    }\n\n    for (long x: lst ) {\n        if (mp[x] != 1) {\n            return false;\n        }\n    }\n    return true;",
    "grade-1": {
      "execution": 0
    },
    "2": "int n = lst.size();\n    int count = 0;\n    for (int i = 1; i < n; ++i) {\n        if (lst[i - 1] >= lst[i]) {\n            ++count;\n        } else {\n            if (count == 1) {\n                return false;\n            }\n            count = 0;\n        }\n    }\n    return count == 1;",
    "grade-2": {
      "execution": 0
    },
    "3": "for(int i=0;i<lst.size()-1;i++){\n\t\t\t\tif(lst[i]>lst[i+1]){\n\t\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t}\n\t\treturn true;",
    "grade-3": {
      "execution": 0
    },
    "4": "for (long i = 0; i < lst.size() - 1; i++) {\n\t\tif (lst[i] >= lst[i + 1])\n\t\t\treturn false;\n\t}\n\treturn true;",
    "grade-4": {
      "execution": 0
    },
    "5": "if (lst.size() == 1) {\n\t\treturn true;\n\t}\n\tstd::sort(lst.begin(), lst.end());\n\tfor (int i = 0; i < lst.size() - 1; i++) {\n\t\tif (lst[i] == lst[i + 1]) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;",
    "grade-5": {
      "execution": 0
    }
  },
  {
    "intent": "#include<assert.h>\n#include<bits/stdc++.h>\n// Given an array of integers, sort the integers that are between 1 and 9 inclusive,\n// reverse the resulting array, and then replace each digit by its corresponding name from\n// \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n// For example:\n// arr = [2, 1, 1, 4, 5, 8, 2, 3]   \n// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n// -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n// return [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n// If the array is empty, return an empty array:\n// arr = []\n// return []\n// If the array has any strange number ignore it:\n// arr = [1, -1 , 55] \n// -> sort arr -> [-1, 1, 55]\n// -> reverse arr -> [55, 1, -1]\n// return = ['One']\nstd::vector<std::string> by_length(std::vector<long> arr) {\n",
    "task_id": "105",
    "prompt": "/*\nGiven a vector of integers, sort the integers that are between 1 and 9 inclusive,\nreverse the resulting vector, and then replace each digit by its corresponding name from\n\"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\nFor example:\n  arr = {2, 1, 1, 4, 5, 8, 2, 3}   \n        -> sort arr -> {1, 1, 2, 2, 3, 4, 5, 8} \n        -> reverse arr -> {8, 5, 4, 3, 2, 2, 1, 1}\n  return {\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"}\n\n  If the vector is empty, return an empty vector:\n  arr = {}\n  return {}\n\n  If the vector has any strange number ignore it:\n  arr = {1, -1 , 55} \n        -> sort arr -> {-1, 1, 55}\n        -> reverse arr -> {55, 1, -1}\n  return = {\"One\"}\n*/\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<map>\n#include<algorithm>\nusing namespace std;\nvector<string> by_length(vector<int> arr){\n",
    "simplified_intent": "Given an array of integers, sort the integers that are between 1 and 9 inclusive, reverse the resulting array, and then replace each digit by its corresponding name from \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".",
    "snippet": [
      "    map<int,string> numto={{0,\"Zero\"},{1,\"One\"},{2,\"Two\"},{3,\"Three\"},{4,\"Four\"},{5,\"Five\"},{6,\"Six\"},{7,\"Seven\"},{8,\"Eight\"},{9,\"Nine\"}};\n    sort(arr.begin(),arr.end());\n    vector<string> out={};\n    for (int i=arr.size()-1;i>=0;i-=1)\n        if (arr[i]>=1 and arr[i]<=9)\n        out.push_back(numto[arr[i]]);\n    return out;\n}\n"
    ],
    "sample_from": {
      "0": "incoder",
      "1": "incoder",
      "2": "incoder",
      "3": "codex",
      "4": "codex",
      "5": "codex"
    },
    "0": "if(arr.empty()) {\n        return {};\n    }\n    \n    std::vector<std::string> res;\n    res.reserve(arr.size() * 10);\n    for(long i : arr) {\n        if(i > 1 && i < 9) {\n            std::reverse(std::begin(res), std::end(res));\n            std::string s;\n            for(int i = 0; i < 10; ++i) {\n                s += \"One\";\n            }\n            s[10] = '\\0';\n            std::transform(std::begin(res), std::end(res), std::back_inserter(s),\n                [&](auto& x) { return x == i ? std::string(\"Two\") : std::string(\"One\"); });\n            std::reverse(std::begin(res), std::end(res));\n        }\n    }\n    return res;",
    "grade-0": {
      "execution": 0
    },
    "1": "auto start = std::min_element(std::begin(arr), std::end(arr));\n    auto finish = std::max_element(std::begin(arr), std::end(arr));\n    std::vector<long> temp(std::distance(start, finish));\n\n    std::transform(start, finish, temp.begin(), [&arr](long val) -> long {\n        auto pos = std::upper_bound(arr, arr + 10, val) - arr;\n        return pos == arr.size() ? 0 : arr[pos];\n    });\n    \n    // reverse the vector and map the values\n    std::vector<std::string> ret(std::distance(temp, arr));\n    std::transform(temp.begin(), temp.end(), ret.begin(), [](long val) -> std::string {\n        if (val < 10) return \"Ten\";\n        if (val < 20) return \"Twenty\";\n        if (val < 30) return \"Thirty\";\n        if (val < 40) return \"Fourty\";\n        if (val < 50) return \"Fifty\";\n        if (val < 60) return \"Sixty\";\n        if (val < 70) return \"Seventy\";\n        if (val < 80) return \"Eighty\";\n        if (val < 90) return \"Ninety\";\n        return \"One\";\n    });\n    return ret;",
    "grade-1": {
      "execution": 0
    },
    "2": "std::vector<std::string> strs;\n    long len = 0;\n    for (int i : arr) {\n        len = len;\n        if (i == 1)\n            len += 1;\n        else if (i == 2)\n            len += 2;\n        else if (i == 3)\n            len += 3;\n        else if (i == 4)\n            len += 4;\n        else if (i == 5)\n            len += 5;\n        else if (i == 6)\n            len += 6;\n        else if (i == 7)\n            len += 7;\n        else if (i == 8)\n            len += 8;\n        else if (i == 9)\n            len += 9;\n        else\n            continue;\n    }\n    for (int i = 0; i < len; ++i) {\n        strs.push_back(\"One\");\n    }\n    for (int i = len - 1; i >= 0; --i) {\n        strs.push_back(\"Two\");\n    }\n    for (int i = len - 1; i >= 1; --i) {\n        strs.push_back(\"Three\");\n    }\n    for (int i = len - 1; i >= 2; --i) {\n        strs.push_back(\"Four\");\n    }\n    for (int i = len - 1; i >= 3; --i) {\n        strs.push_back(\"Five\");\n    }\n    for (int i = len - 1; i >= 4; --i) {\n        strs.push_back(\"Six\");\n    }\n    for (int i = len - 1; i >= 5; --i) {\n        strs.push_back(\"Seven\");\n    }\n    for (int i = len - 1; i >= 6; --i) {\n        strs.push_back(\"Eight\");\n    }\n    for (int i = len - 1; i >= 7; --i) {\n        strs.push_back(\"Nine\");\n    }\n    for (int i = len - 1; i >= 8; --i) {\n        strs.push_back(\"Ten\");\n    }\n    for (int i = len - 1; i >= 9; --i) {\n        strs.push_back(\"Eleven\");\n    }\n    for (int i = len - 1; i >= 10; --i) {\n        strs.push_back(\"Twelve\");\n    }\n    return strs;",
    "grade-2": {
      "execution": 0
    },
    "3": "std::vector<std::string> names(arr.size());\n    std::map<long, std::string> digits = {{1, \"One\"}, {2, \"Two\"}, {3, \"Three\"}, {4, \"Four\"}, {5, \"Five\"},\n        {6, \"Six\"}, {7, \"Seven\"}, {8, \"Eight\"}, {9, \"Nine\"}};\n    std::sort(arr.begin(), arr.end());\n    std::reverse(arr.begin(), arr.end());\n    for (int i = 0; i < arr.size(); i++) {\n        if (arr[i] >= 1 && arr[i] <= 9) {\n            names[i] = digits[arr[i]];\n        }\n    }\n    return names;",
    "grade-3": {
      "execution": 0
    },
    "4": "int i =0;\n  std::vector<std::string> res ={};\n  for(i =0; i<arr.size();i++){\n    if(arr[i] == 1) res.push_back(\"One\");\n    else if(arr[i] == 2) res.push_back(\"Two\");\n    else if(arr[i] == 3) res.push_back(\"Three\");\n    else if(arr[i] == 4) res.push_back(\"Four\");\n    else if(arr[i] == 5) res.push_back(\"Five\");\n    else if(arr[i] == 6) res.push_back(\"Six\");\n    else if(arr[i] == 7) res.push_back(\"Seven\");\n    else if(arr[i] == 8) res.push_back(\"Eight\");\n    else if(arr[i] == 9) res.push_back(\"Nine\");\n  }\n  std::sort(res.begin(), res.end(), [](std::string &s1, std::string &s2) { return s1.size() < s2.size(); });\n  return res;",
    "grade-4": {
      "execution": 0
    },
    "5": "std::vector<std::string> numbers = { \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\" };\n\tstd::vector<std::string> result;\n\tstd::vector<long> sort_arr;\n\tstd::vector<long> reverse_arr;\n\tlong i = 0;\n\tif (arr.size() == 0)\n\t\treturn {};\n\tfor (i = 0; i < arr.size(); i++) {\n\t\tif (arr[i] > 0 && arr[i] < 10)\n\t\t\tsort_arr.push_back(arr[i]);\n\t}\n\tstd::sort(sort_arr.begin(), sort_arr.end());\n\tstd::reverse(sort_arr.begin(), sort_arr.end());\n\tfor (i = 0; i < sort_arr.size(); i++) {\n\t\treverse_arr.push_back(sort_arr[i]);\n\t}\n\tstd::reverse(reverse_arr.begin(), reverse_arr.end());\n\tfor (i = 0; i < reverse_arr.size(); i++) {\n\t\tresult.push_back(numbers[reverse_arr[i] - 1]);\n\t}\n\treturn result;",
    "grade-5": {
      "execution": 0
    }
  },
  {
    "intent": "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing a branch of a tree that has non-negative integer nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked node should be the node with the smallest even value.\n// If multiple nodes with the same smallest even value are found return the node that has smallest index.\n// The plucked node should be returned in a list, [ smalest_value, its index ],\n// If there are no even values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so we will choose the first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long> arr) {\n",
    "task_id": "68",
    "prompt": "/*\nGiven a vector representing a branch of a tree that has non-negative integer nodes\nyour task is to pluck one of the nodes and return it.\nThe plucked node should be the node with the smallest even value.\nIf multiple nodes with the same smallest even value are found return the node that has smallest index.\n\nThe plucked node should be returned in a vector, { smalest_value, its index },\nIf there are no even values or the given vector is empty, return {}.\n\nExample 1:\n    Input: {4,2,3}\n    Output: {2, 1}\n    Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\nExample 2:\n    Input: {1,2,3}\n    Output: {2, 1}\n    Explanation: 2 has the smallest even value, and 2 has the smallest index. \n\nExample 3:\n    Input: {}\n    Output: {}\n\nExample 4:\n    Input: {5, 0, 3, 0, 4, 2}\n    Output: {0, 1}\n    Explanation: 0 is the smallest value, but  there are two zeros,\n                 so we will choose the first zero, which has the smallest index.\n\nConstraints:\n    * 1 <= nodes.length <= 10000\n    * 0 <= node.value\n*/\n#include<stdio.h>\n#include<vector>\nusing namespace std;\nvector<int> pluck(vector<int> arr){\n",
    "simplified_intent": "\"Given an array representing a branch of a tree that has non-negative integer nodes your task is to pluck one of the nodes and return it. The plucked node should be the node with the smallest even value. If multiple nodes with the same smallest even value are found return the node that has smallest index. The plucked node should be returned in a list, [ smalest_value, its index ], If there are no even values or the given array is empty, return []. Constraints: * 1 <= nodes.length <= 10000 * 0 <= node.value",
    "snippet": [
      "    vector<int> out={};\n    for (int i=0;i<arr.size();i++)\n    if (arr[i]%2==0 and (out.size()==0 or arr[i]<out[0]))\n        out={arr[i],i};\n    return out;\n}\n"
    ],
    "sample_from": {
      "0": "incoder",
      "1": "incoder",
      "2": "incoder",
      "3": "codex",
      "4": "codex",
      "5": "codex"
    },
    "0": "// code here\n    if(arr.size() == 0)\n    {\n        return {};\n    }\n    long smallest = arr[0];\n    int index = 0;\n    for(int i = 1; i < arr.size(); i++)\n    {\n        if(arr[i] < smallest)\n        {\n            smallest = arr[i];\n            index = i;\n        }\n    }\n    std::vector<long> vec;\n    vec.push_back(smallest);\n    vec.push_back(index);\n    return vec;",
    "grade-0": {
      "execution": 0
    },
    "1": "// Your code here\n        std::set<long> s;\n        int ans=0;\n        for(std::size_t i=0 ;i < arr.size(); ++i){\n            long val= arr[i];\n            if(s.find(val)!=s.end()){\n                ans=std::min(ans,std::distance(s.begin(),s.find(val)));\n                s.erase(val);\n            }\n            else{\n                s.insert(val);\n            }\n        }\n        std::vector<long> out;\n        while(!s.empty()){\n            out.push_back(s.begin()->second);\n            s.erase(s.begin()->first);\n        }\n        return out;\n    }\n</code>\n<|/ a tags=arrays,algorithm,data-structures |>\n<| a dscore=2 |>\nIn C++:\n<code>\n#include<bits/stdc++.h>\nusing namespace std;\n\nvector<int> arr;\nint main()\n{\n    scanf(\"%d\",&n);\n    for(int i=0;i<n;i++)\n    {\n        cin>>arr[i];\n    }\n    sort(arr.begin(),arr.end());\n    for(int i=0;i<n;i++)\n    {\n        if(arr[i] % 2 == 0)\n        {\n            cout<<arr[i]<<\" \";\n        }\n    }",
    "grade-1": {
      "execution": 0
    },
    "2": "long smalest_value = INT_MIN;\n    int smalest_index = 0;\n    \n    long smalest_index1 = 0;\n    long smalest_index2 = 0;\n    \n    for (int i = 0; i < arr.size(); i++) {\n        if (arr[i] % 2 == 0) {\n            if (arr[i] < smalest_value) {\n                smalest_value = arr[i];\n                smalest_index = i;\n            }\n            else if (arr[i] == smalest_value) {\n                smalest_index++;\n            }\n        }\n        else if (arr[i] == smalest_value) {\n            if (i < (arr.size()-1)) {\n                long temp = (arr[i+1] + arr[i]);\n                if (temp % 2 == 0) {\n                    if (temp < smalest_value) {\n                        smalest_value = temp;\n                        smalest_index1 = i;\n                    }\n                    else if (temp == smalest_value) {\n                        smalest_index1++;\n                    }\n                }\n            }\n            else if (arr.size() == 1) {\n                smalest_index1++;\n            }\n        }\n    }\n    \n    if (smalest_index1 == arr.size()) {\n        if (smalest_index2 == arr.size()) {\n            return std::vector<long>{smalest_value, smalest_index};\n        }\n        else {\n            return std::vector<long>{smalest_value, smalest_index};\n        }\n    }\n    else {\n        return std::vector<long>{smalest_value, smalest_index1};\n    }",
    "grade-2": {
      "execution": 0
    },
    "3": "if(arr.size() == 0)\n        return {};\n    long min = -1;\n    long index = -1;\n    for(int i = 0; i < arr.size(); i++) {\n        if(arr[i] % 2 == 0 && (min == -1 || arr[i] < min)) {\n            min = arr[i];\n            index = i;\n        }\n    }\n    if(min == -1)\n        return {};\n    return {min, index};",
    "grade-3": {
      "execution": 1
    },
    "4": "std::vector<long> a;\n  if(arr.size()==0)\n  {\n    return a;\n  }\n  else\n  {\n    int small =arr[0];\n    int index = 0;\n    for(int i=0;i<arr.size();i++)\n    {\n      if(arr[i]%2==0 && arr[i]<small)\n      {\n        small = arr[i];\n        index = i;\n      }\n    }\n    if(small%2==0)\n    {\n      a.push_back(small);\n      a.push_back(index);\n      return a;\n    }\n    else\n    {\n      return a;\n    }\n  }",
    "grade-4": {
      "execution": 0
    },
    "5": "if (arr.size() == 0)\n\t\treturn {};\n\tint min = -1;\n\tint min_index = -1;\n\tfor (int i = 0; i < arr.size(); i++) {\n\t\tif (arr[i] % 2 == 0) {\n\t\t\tif (min == -1) {\n\t\t\t\tmin = arr[i];\n\t\t\t\tmin_index = i;\n\t\t\t}\n\t\t\telse if (arr[i] < min) {\n\t\t\t\tmin = arr[i];\n\t\t\t\tmin_index = i;\n\t\t\t}\n\t\t}\n\t}\n\tif (min == -1)\n\t\treturn {};\n\telse\n\t\treturn {min, min_index};",
    "grade-5": {
      "execution": 1
    }
  },
  {
    "intent": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which returns the largest index of an element which\n// is not greater than or equal to the element immediately preceding it. If\n// no such element exists then return -1. The given array will not contain\n// duplicate values.\n// Examples:\n// can_arrange([1,2,4,3,5]) = 3\n// can_arrange([1,2,3]) = -1\nlong can_arrange(std::vector<long> arr) {\n",
    "task_id": "135",
    "prompt": "/*\nCreate a function which returns the largest index of an element which\nis not greater than or equal to the element immediately preceding it. If\nno such element exists then return -1. The given vector will not contain\nduplicate values.\n\nExamples:\ncan_arrange({1,2,4,3,5}) = 3\ncan_arrange({1,2,3}) = -1\n*/\n#include<stdio.h>\n#include<vector>\nusing namespace std;\nint can_arrange(vector<int> arr){\n",
    "simplified_intent": "Create a function which returns the largest index of an element which is not greater than or equal to the element immediately preceding it. If no such element exists then return -1. The given array will not contain duplicate values.",
    "snippet": [
      "    int max=-1;\n    for (int i=0;i<arr.size();i++)\n    if (arr[i]<=i) max=i;\n    return max;\n}\n"
    ],
    "sample_from": {
      "0": "incoder",
      "1": "incoder",
      "2": "incoder",
      "3": "codex",
      "4": "codex",
      "5": "codex"
    },
    "0": "if (arr.empty()) {\n        return -1;\n    }\n    auto it = arr.begin();\n    auto last = it;\n    auto prev = it;\n    for (auto iter = arr.end() - 1; iter >= arr.begin(); iter--)\n        if (*iter <= *prev) last = iter;\n        else prev = iter;\n    if (it == arr.begin()) return -1;\n    if (prev == it) return -1;\n    return last;",
    "grade-0": {
      "execution": 0
    },
    "1": "long n = arr.size();\n    long result = 0;\n    int left = n-1;\n    while(left > 0) {\n        if(arr[left] <= arr[left-1]) {\n            result = arr[left-1];\n        } else {\n            result = -1;\n            break;\n        }\n        left = left - 1;\n    }\n    return result;",
    "grade-1": {
      "execution": 0
    },
    "2": "// Write your code here\n\tassert(arr.size() > 0);\n\tlong maxI = -1;\n\tlong currI = 0;\n\tfor (long i = 1; i < arr.size() && maxI < 0; i++) {\n\t\tif (arr[i] < arr[0]) {\n\t\t\tmaxI = currI;\n\t\t}\n\t\tcurrI = i;\n\t}\n\tif (maxI < 0)\n\t\treturn -1;\n\treturn maxI + 1;",
    "grade-2": {
      "execution": 0
    },
    "3": "int max = 0;\n  for (int i = 1; i < arr.size(); i++) {\n    if (arr[i] <= arr[i - 1]) {\n      continue;\n    }\n    else {\n      if (max < i) {\n        max = i;\n      }\n    }\n  }\n  if (max == 0) {\n    return -1;\n  }\n  return max;",
    "grade-3": {
      "execution": 0
    },
    "4": "// your code here\n  long index = 0;\n  for(long i = 0; i < arr.size()-1; i++){\n    if(arr[i] < arr[i+1]){\n      index = i+1;\n    }\n  }\n  return index;",
    "grade-4": {
      "execution": 0
    },
    "5": "long n = arr.size();\n    long max_index = n - 1;\n    for (long i = n - 2; i >= 0; i--) {\n        if (arr[i] > arr[i + 1]) {\n            max_index = i;\n        }\n    }\n    return max_index;",
    "grade-5": {
      "execution": 0
    }
  },
  {
    "intent": "#include<assert.h>\n#include<bits/stdc++.h>\n// Implement the function f that takes n as a parameter,\n// and returns a list of size n, such that the value of the element at index i is the factorial of i if i is even\n// or the sum of numbers from 1 to i otherwise.\n// i starts from 1.\n// the factorial of i is the multiplication of the numbers from 1 to i (1 * 2 * ... * i).\n// Example:\n// f(5) == [1, 2, 6, 24, 15]\nstd::vector<long> f(long n) {\n",
    "task_id": "106",
    "prompt": "/*\nImplement the function f that takes n as a parameter,\nand returns a vector of size n, such that the value of the element at index i is the factorial of i if i is even\nor the sum of numbers from 1 to i otherwise.\ni starts from 1.\nthe factorial of i is the multiplication of the numbers from 1 to i (1 * 2 * ... * i).\nExample:\nf(5) == {1, 2, 6, 24, 15}\n*/\n#include<stdio.h>\n#include<vector>\nusing namespace std;\nvector<int> f(int n){\n",
    "simplified_intent": "Implement the function f that takes n as a parameter, and returns a list of size n, such that the value of the element at index i is the factorial of i if i is even or the sum of numbers from 1 to i otherwise. i starts from 1. the factorial of i is the multiplication of the numbers from 1 to i (1 * 2 * ... * i).",
    "snippet": [
      "    int sum=0,prod=1;\n    vector<int> out={};\n    for (int i=1;i<=n;i++)\n    {\n        sum+=i;\n        prod*=i;\n        if (i%2==0) out.push_back(prod);\n        else out.push_back(sum);\n    } \n    return out;\n}\n"
    ],
    "sample_from": {
      "0": "incoder",
      "1": "incoder",
      "2": "incoder",
      "3": "codex",
      "4": "codex",
      "5": "codex"
    },
    "0": "std::vector<long> result;\n    long fact = 1;\n    for(int i=0;i<n;i++) {\n        if(i%2 == 0) {\n            fact = fact * i;\n            result.push_back(fact);\n        } else {\n            result.push_back(fact);\n        }\n    }\n    return result;",
    "grade-0": {
      "execution": 0
    },
    "1": "std::vector<long> result;\n    long f = 1; // factorial of 1\n    long f2 = 1; // factorial of 2\n    long f3 = 1; // factorial of 3\n    for (long i = 1; i <= n; i++) {\n        if (i % 2 == 0) {\n            f *= i;\n        } else {\n            f2 += i;\n            f3 *= i;\n        }\n        result.push_back(f);\n        result.push_back(f2);\n        result.push_back(f3);\n    }\n    return result;",
    "grade-1": {
      "execution": 0
    },
    "2": "// your code here\n    std::vector<long> factorials(n+1);\n    factorials[0] = 1;\n    for (int i = 1; i <= n; i++){\n        if (i%2 == 0) {\n            factorials[i] = factorials[i - 1] * i;\n        }\n        else {\n            factorials[i] = factorials[i - 1] + 1;\n        }\n    }\n    return factorials;",
    "grade-2": {
      "execution": 0
    },
    "3": "std::vector<long> v(n);\n  for (int i = 0; i < n; i++) {\n    if ((i + 1) % 2 == 0) {\n      long f = 1;\n      for (int j = 1; j <= i + 1; j++)\n        f *= j;\n      v[i] = f;\n    } else {\n      long f = 0;\n      for (int j = 1; j <= i + 1; j++)\n        f += j;\n      v[i] = f;\n    }\n  }\n  return v;",
    "grade-3": {
      "execution": 1
    },
    "4": "// Add your code here\n  long i;\n  std::vector<long> v;\n  for(i=1;i<=n;i++)\n  {\n    if(i%2==0)\n    {\n      long fact = 1;\n      while(i>0)\n      {\n        fact = fact*i;\n        i--;\n      }\n      v.push_back(fact);\n    }\n    else\n    {\n      long sum = 0;\n      for(long j=1;j<=i;j++)\n      {\n        sum = sum+j;\n      }\n      v.push_back(sum);\n    }\n  }\n  return v;",
    "grade-4": {
      "execution": 0
    },
    "5": "std::vector<long> ret;\n  long product = 1;\n  for (long i = 1; i <= n; i++) {\n    if (i % 2 == 0) {\n      ret.push_back(product);\n      product *= i;\n    } else {\n      ret.push_back(i * (i + 1) / 2);\n    }\n  }\n  return ret;",
    "grade-5": {
      "execution": 0
    }
  },
  {
    "intent": "#include<assert.h>\n#include<bits/stdc++.h>\n// Return sorted unique elements in a list\n// >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n// [0, 2, 3, 5, 9, 123]\nstd::vector<long> unique(std::vector<long> l) {\n",
    "task_id": "34",
    "prompt": "/*\nReturn sorted unique elements in a vector\n>>> unique({5, 3, 5, 2, 3, 3, 9, 0, 123})\n{0, 2, 3, 5, 9, 123}\n*/\n#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nvector<int> unique(vector<int> l){\n",
    "simplified_intent": "Return sorted unique elements in a list",
    "snippet": [
      "    vector<int> out={};\n    for (int i=0;i<l.size();i++)\n        if (find(out.begin(),out.end(),l[i])==out.end())\n            out.push_back(l[i]);\n    sort(out.begin(),out.end());\n    return out;\n}\n"
    ],
    "sample_from": {
      "0": "incoder",
      "1": "incoder",
      "2": "incoder",
      "3": "codex",
      "4": "codex",
      "5": "codex"
    },
    "0": "auto it = std::unique(l.begin(), l.end());\n    l.erase(it, l.end());\n    return l;",
    "grade-0": {
      "execution": 0
    },
    "1": "std::vector<long> tmp;\n    tmp.assign( std::begin(l), std::end(l) );\n    std::sort(std::begin(tmp), std::end(tmp));\n    tmp.erase( std::unique( std::begin(tmp), std::end(tmp)), std::end(tmp) );\n    return tmp;",
    "grade-1": {
      "execution": 1
    },
    "2": "std::vector<long> res;\n    std::set<long> set(l.begin(), l.end());\n    std::copy(set.begin(), set.end(), std::back_inserter(res));\n    return res;",
    "grade-2": {
      "execution": 1
    },
    "3": "std::vector<long> res = l;\n    sort(res.begin(), res.end());\n    auto last = std::unique(res.begin(), res.end());\n    res.erase(last, res.end());\n    return res;",
    "grade-3": {
      "execution": 1
    },
    "4": "std::vector<long> ans;\n    int n = l.size();\n    if (n == 0) return ans;\n    ans.push_back(l[0]);\n    std::sort(l.begin(), l.end());\n    for (int i = 1; i < n; i++) {\n        if (l[i] != l[i-1]) {\n            ans.push_back(l[i]);\n        }\n    }\n    return ans;",
    "grade-4": {
      "execution": 0
    },
    "5": "std::vector<long> out;\n    for (auto i : l) {\n        if (std::find(out.begin(), out.end(), i) == out.end()) {\n            out.push_back(i);\n        }\n    }\n    std::sort(out.begin(), out.end());\n    return out;",
    "grade-5": {
      "execution": 1
    }
  },
  {
    "intent": "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n// 1\nlong modp(long n, long p) {\n",
    "task_id": "49",
    "prompt": "/*\nReturn 2^n modulo p (be aware of numerics).\n>>> modp(3, 5)\n3\n>>> modp(1101, 101)\n2\n>>> modp(0, 101)\n1\n>>> modp(3, 11)\n8\n>>> modp(100, 101)\n1\n*/\n#include<stdio.h>\nusing namespace std;\nint modp(int n,int p){\n",
    "simplified_intent": "Return 2^n modulo p (be aware of numerics).",
    "snippet": [
      "    int out=1;\n    for (int i=0;i<n;i++)\n        out=(out*2)%p;\n    return out;\n}\n"
    ],
    "sample_from": {
      "0": "incoder",
      "1": "incoder",
      "2": "incoder",
      "3": "codex",
      "4": "codex",
      "5": "codex"
    },
    "0": "assert(p > 0);\n  long q = n / p;\n  long r = n % p;\n  long result = 1;\n  while (result <= q) {\n    result *= p;\n  }\n  if (r == 0) {\n    return 1;\n  }\n  return result;",
    "grade-0": {
      "execution": 0
    },
    "1": "assert(n >= 0);\n  assert(p >= 0);\n  long c = 1;\n  long r = n;\n  while (r != 0) {\n    long t = r / p;\n    long u = r - t * p;\n    r = t;\n    if (r > 0) {\n      c = c + u;\n    }\n  }\n  return c;",
    "grade-1": {
      "execution": 0
    },
    "2": "return (n + p-1) & -p;",
    "grade-2": {
      "execution": 0
    },
    "3": "assert(n>=0);\n    assert(p>=2);\n    long d = 1;\n    while (n) {\n        if (n & 1) d = (d * 2) % p;\n        n >>= 1;\n    }\n    return d;",
    "grade-3": {
      "execution": 0
    },
    "4": "if (n == 0) return 1;\n    if (n % 2 == 0) {\n        long r = modp(n / 2, p);\n        return r * r % p;\n    }\n    return modp(n - 1, p) * n % p;",
    "grade-4": {
      "execution": 0
    },
    "5": "long r = 1;\n  while (n > 0) {\n    if (n % 2 == 1)\n      r = (r * 2) % p;\n    n = n / 2;\n  }\n  return r;",
    "grade-5": {
      "execution": 0
    }
  },
  {
    "intent": "#include<assert.h>\n#include<bits/stdc++.h>\n// Given an array of integers nums, find the minimum sum of any non-empty sub-array\n// of nums.\n// Example\n// minSubArraySum([2, 3, 4, 1, 2, 4]) == 1\n// minSubArraySum([-1, -2, -3]) == -6\nlong minSubArraySum(std::vector<long> nums) {\n",
    "task_id": "114",
    "prompt": "/*\nGiven a vector of integers nums, find the minimum sum of any non-empty sub-vector\nof nums.\nExample\nminSubArraySum({2, 3, 4, 1, 2, 4}) == 1\nminSubArraySum({-1, -2, -3}) == -6\n*/\n#include<stdio.h>\n#include<vector>\nusing namespace std;\nlong long minSubArraySum(vector<long long> nums){\n",
    "simplified_intent": "Given an array of integers nums, find the minimum sum of any non-empty sub-array of nums.",
    "snippet": [
      "    long long current,min;\n    current=nums[0];\n    min=nums[0];\n    for (int i=1;i<nums.size();i++)\n    {\n       if (current<0) current=current+nums[i];\n       else current=nums[i];\n       if (current<min) min=current;\n    }\n    return min;\n}\n"
    ],
    "sample_from": {
      "0": "incoder",
      "1": "incoder",
      "2": "incoder",
      "3": "codex",
      "4": "codex",
      "5": "codex"
    },
    "0": "// Write your code here.\n    return INT_MIN;",
    "grade-0": {
      "execution": 0
    },
    "1": "long res = 0;\n    if (nums.size() <= 1) return res;\n    // Traverse the array from end to beginning and compute the sum\n    // of current sub array\n    for (long i = nums.size() - 1; i >= 0; --i) {\n        long ls = nums[i];\n        long cur_sum = 0;\n        for (long j = i; j < nums.size(); ++j) {\n            cur_sum += nums[j];\n            if (cur_sum < ls)\n                ls = cur_sum;\n        }\n        res = std::min(res, ls);\n    }\n    return res;",
    "grade-1": {
      "execution": 0
    },
    "2": "long long n = nums.size();\n    long long max_so_far = 0, min_so_far = INT_MAX;\n\n    for (long i = 0; i < n; i++) {\n        min_so_far = min(min_so_far, max_so_far + nums[i]);\n        max_so_far = max(max_so_far, nums[i]);\n    }\n\n    return min_so_far;",
    "grade-2": {
      "execution": 0
    },
    "3": "long m = nums[0];\n  for (auto i = 1; i < nums.size(); i++) {\n    nums[i] = std::min(nums[i], nums[i] + nums[i - 1]);\n    m = std::min(m, nums[i]);\n  }\n  return m;",
    "grade-3": {
      "execution": 1
    },
    "4": "long minSum = nums[0];\n  long currSum = nums[0];\n  for (size_t i = 1; i < nums.size(); i++) {\n    currSum = std::min(nums[i], currSum + nums[i]);\n    minSum = std::min(minSum, currSum);\n  }\n  return minSum;",
    "grade-4": {
      "execution": 1
    },
    "5": "std::vector<long> vec;\n    vec.push_back(nums[0]);\n    long min = nums[0];\n    for(int i = 1; i < nums.size(); i++) {\n        vec.push_back(vec[i-1] + nums[i]);\n        if(vec[i] < min) {\n            min = vec[i];\n        }\n    }\n    long max = 0;\n    for(int i = 0; i < vec.size(); i++) {\n        if(vec[i] > max) {\n            max = vec[i];\n        }\n    }\n    return min < max - min ? min : max - min;",
    "grade-5": {
      "execution": 0
    }
  },
  {
    "intent": "#include<assert.h>\n#include<bits/stdc++.h>\n// Given list of integers, return list in strange order.\n// Strange sorting, is when you start with the minimum value,\n// then maximum of the remaining integers, then minimum and so on.\n// Examples:\n// strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n// strange_sort_list([]) == []\nstd::vector<long> strange_sort_list(std::vector<long> lst) {\n",
    "task_id": "70",
    "prompt": "/*\nGiven vector of integers, return vector in strange order.\nStrange sorting, is when you start with the minimum value,\nthen maximum of the remaining integers, then minimum and so on.\n\nExamples:\nstrange_sort_vector({1, 2, 3, 4}) == {1, 4, 2, 3}\nstrange_sort_vector({5, 5, 5, 5}) == {5, 5, 5, 5}\nstrange_sort_vector({}) == {}\n*/\n#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nvector<int> strange_sort_list(vector<int> lst){\n",
    "simplified_intent": "Given list of integers, return list in strange order. Strange sorting, is when you start with the minimum value, then maximum of the remaining integers, then minimum and so on.",
    "snippet": [
      "    vector<int> out={};\n    sort(lst.begin(),lst.end());\n    int l=0,r=lst.size()-1;\n    while (l<r)\n    {\n        out.push_back(lst[l]);\n        l+=1;\n        out.push_back(lst[r]);\n        r-=1;\n    }\n    if (l==r) out.push_back(lst[l]);\n    return out;\n\n}\n"
    ],
    "sample_from": {
      "0": "incoder",
      "1": "incoder",
      "2": "incoder",
      "3": "codex",
      "4": "codex",
      "5": "codex"
    },
    "0": "std::sort(lst.begin(), lst.end(), [&](long a, long b){return a<b;});\n    lst.erase(lst.begin(), lst.begin()+(lst.size()+1)/2); //half of size will remain\n    lst.insert(lst.begin(), lst.begin()+lst.size()/2); //half of size will reappear\n    return lst;",
    "grade-0": {
      "execution": 0
    },
    "1": "std::vector<long> res;\n    for (long i : lst)\n        res.push_back(i);\n\n    res.sort();\n    return res;",
    "grade-1": {
      "execution": 0
    },
    "2": "// Base case\n    if (lst.size() == 0) {\n        return lst;\n    }\n    // Recursive case\n    std::vector<long> res;\n    for (long &val : lst) {\n        std::swap(val, std::min_element(lst.begin(), lst.end()) - 1);\n        res.push_back(val);\n    }\n    return res;",
    "grade-2": {
      "execution": 0
    },
    "3": "if (lst.size() <= 1) {\n        return lst;\n    }\n    std::vector<long> left;\n    std::vector<long> right;\n    std::vector<long> res;\n    int mx = std::numeric_limits<int>::min();\n    int mn = std::numeric_limits<int>::max();\n    for (int i = 0; i < lst.size(); i++) {\n        if (lst[i] > mx) {\n            mx = lst[i];\n        }\n        if (lst[i] < mn) {\n            mn = lst[i];\n        }\n    }\n    for (int i = 0; i < lst.size(); i++) {\n        if (lst[i] == mx) {\n            continue;\n        }\n        if (lst[i] == mn) {\n            continue;\n        }\n        if (lst[i] > mn) {\n            right.push_back(lst[i]);\n        }\n        if (lst[i] < mx) {\n            left.push_back(lst[i]);\n        }\n    }\n    std::vector<long> lres = strange_sort_list(left);\n    std::vector<long> rres = strange_sort_list(right);\n    res.insert(res.end(), lres.begin(), lres.end());\n    res.push_back(mn);\n    res.push_back(mx);\n    res.insert(res.end(), rres.begin(), rres.end());\n    return res;",
    "grade-3": {
      "execution": 0
    },
    "4": "if (lst.size() <= 1) {\n        return lst;\n    }\n\n    std::vector<long> sorted;\n    sorted.push_back(lst[0]);\n    lst.erase(lst.begin());\n\n    while (!lst.empty()) {\n        long min = lst[0];\n        long min_index = 0;\n        long max = lst[0];\n        long max_index = 0;\n\n        for (int i = 0; i < lst.size(); i++) {\n            if (lst[i] < min) {\n                min = lst[i];\n                min_index = i;\n            }\n\n            if (lst[i] > max) {\n                max = lst[i];\n                max_index = i;\n            }\n        }\n\n        sorted.push_back(max);\n        lst.erase(lst.begin() + max_index);\n\n        if (!lst.empty()) {\n            sorted.push_back(min);\n            lst.erase(lst.begin() + min_index);\n        }\n    }\n\n    return sorted;",
    "grade-4": {
      "execution": 0
    },
    "5": "std::vector<long> result;\n    int n = lst.size();\n    sort(lst.begin(), lst.end());\n    for (int i = 0; i < n / 2; i++) {\n        result.push_back(lst[i]);\n        result.push_back(lst[n - i - 1]);\n    }\n    if (n % 2 != 0)\n        result.push_back(lst[n / 2]);\n    return result;",
    "grade-5": {
      "execution": 1
    }
  },
  {
    "intent": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a positive integer n. You have to create an integer array a of length n.\n// For each i (1 \u2264 i \u2264 n), the value of a[i] = i * i - i + 1.\n// Return the number of triples (a[i], a[j], a[k]) of a where i < j < k, \n// and a[i] + a[j] + a[k] is a multiple of 3.\n// Example :\n// Input: n = 5\n// Output: 1\n// Explanation: \n// a = [1, 3, 7, 13, 21]\n// The only valid triple is (1, 7, 13).\nlong get_max_triples(long n) {\n",
    "task_id": "147",
    "prompt": "/*\nYou are given a positive integer n. You have to create an integer vector a of length n.\n    For each i (1 \u2264 i \u2264 n), the value of a{i} = i * i - i + 1.\n    Return the number of triples (a{i}, a{j}, a{k}) of a where i < j < k, \nand a[i] + a[j] + a[k] is a multiple of 3.\n\nExample :\n    Input: n = 5\n    Output: 1\n    Explanation: \n    a = {1, 3, 7, 13, 21}\n    The only valid triple is (1, 7, 13).\n*/\n#include<stdio.h>\n#include<vector>\nusing namespace std;\nint get_matrix_triples(int n){\n",
    "simplified_intent": "You are given a positive integer n. You have to create an integer array a of length n. For each i (1 \u2264 i \u2264 n), the value of a[i] = i * i - i + 1. Return the number of triples (a[i], a[j], a[k]) of a where i < j < k, and a[i] + a[j] + a[k] is a multiple of 3.",
    "snippet": [
      "    vector<int> a;\n    vector<vector<int>> sum={{0,0,0}};\n    vector<vector<int>> sum2={{0,0,0}};\n    for (int i=1;i<=n;i++)\n    {\n        a.push_back((i*i-i+1)%3);\n        sum.push_back(sum[sum.size()-1]);\n        sum[i][a[i-1]]+=1;\n    }\n    for (int times=1;times<3;times++)\n    {\n    for (int i=1;i<=n;i++)\n    {\n        sum2.push_back(sum2[sum2.size()-1]);\n        if (i>=1)\n        for (int j=0;j<=2;j++)\n            sum2[i][(a[i-1]+j)%3]+=sum[i-1][j];\n    }\n    sum=sum2;\n    sum2={{0,0,0}};\n    }\n\n    return sum[n][0];\n}\n"
    ],
    "sample_from": {
      "0": "incoder",
      "1": "incoder",
      "2": "incoder",
      "3": "codex",
      "4": "codex",
      "5": "codex"
    },
    "0": "vector<long> a(n);\n    for(long i = 0; i < n; i++) {\n        a[i] = i * i - i + 1;\n    }\n    sort(a.begin(), a.end());\n    long s = 0;\n    for(long i = 0; i < n; i++) {\n        long k = i;\n        long j = i - 1;\n        long m = a[j];\n        while(k >= 0 && m < 3 && a[k] > m) {\n            k = k - 1;\n            m = a[k];\n        }\n        s += m * a[i] * a[j];\n    }\n    return s;",
    "grade-0": {
      "execution": 0
    },
    "1": "vector<long long> a(n + 1);\n    iota(a.begin(), a.end(), 1);\n    long ans = 0;\n    for (long i = 1; i <= n; i++) {\n        for (long j = 1; j <= n; j++) {\n            for (long k = 1; k <= n; k++) {\n                if (j > k) {\n                    if (a[j] + a[k] + a[i] % 3 == 0) {\n                        ans++;\n                    }\n                }\n            }\n        }\n    }\n    return ans;",
    "grade-1": {
      "execution": 0
    },
    "2": "long a[n];\n    long long sum = 0;\n    // create an array of length n\n    for (int i = 0; i < n; i++) {\n        a[i] = i * i - i + 1;\n        sum += a[i];\n    }\n    \n    for (int i = 0; i < n; i++) {\n        for (int j = i + 1; j < n; j++) {\n            long long diff = sum - a[i] + a[j];\n            if (diff > 0)\n                return 1;\n        }\n    }\n    return 0;",
    "grade-2": {
      "execution": 0
    },
    "3": "long no_of_triples = 0;\n    for(long i = 1; i < n; i++) {\n        for(long j = i + 1; j < n; j++) {\n            for(long k = j + 1; k < n; k++) {\n                if((i*i - i + 1 + j*j - j + 1 + k*k - k + 1) % 3 == 0) {\n                    no_of_triples++;\n                }\n            }\n        }\n    }\n    return no_of_triples;",
    "grade-3": {
      "execution": 0
    },
    "4": "if(n < 3) {\n        return 0;\n    }\n    if(n == 3) {\n        return 1;\n    }\n    long *arr = new long[n];\n    for(long i = 0; i < n; i++) {\n        arr[i] = i * i - i + 1;\n    }\n    long i = 0, j = 0, k = 0;\n    long count = 0;\n    for(i = 0; i < n - 2; i++) {\n        for(j = i + 1; j < n - 1; j++) {\n            for(k = j + 1; k < n; k++) {\n                if((arr[i] + arr[j] + arr[k]) % 3 == 0) {\n                    count++;\n                }\n            }\n        }\n    }\n    return count;",
    "grade-4": {
      "execution": 0
    },
    "5": "if(n <= 3)\n        return 0;\n    long count = 0;\n    for(long i = 0; i < n; i++) {\n        for(long j = i + 1; j < n; j++) {\n            for(long k = j + 1; k < n; k++) {\n                if((i * i - i + 1 + j * j - j + 1 + k * k - k + 1) % 3 == 0)\n                    count++;\n            }\n        }\n    }\n    return count;",
    "grade-5": {
      "execution": 0
    }
  },
  {
    "intent": "#include<assert.h>\n#include<bits/stdc++.h>\n// Complete the function that takes two integers and returns \n// the product of their unit digits.\n// Assume the input is always valid.\n// Examples:\n// multiply(148, 412) should return 16.\n// multiply(19, 28) should return 72.\n// multiply(2020, 1851) should return 0.\n// multiply(14,-15) should return 20.\nlong multiply(long a, long b) {\n",
    "task_id": "97",
    "prompt": "/*\nComplete the function that takes two integers and returns \nthe product of their unit digits.\nAssume the input is always valid.\nExamples:\nmultiply(148, 412) should return 16.\nmultiply(19, 28) should return 72.\nmultiply(2020, 1851) should return 0.\nmultiply(14,-15) should return 20.\n*/\n#include<stdio.h>\n#include<math.h>\nusing namespace std;\nint multiply(int a,int b){\n",
    "simplified_intent": "Complete the function that takes two integers and returns the product of their unit digits. Assume the input is always valid.",
    "snippet": [
      "    return (abs(a)%10)*(abs(b)%10);\n}\n"
    ],
    "sample_from": {
      "0": "incoder",
      "1": "incoder",
      "2": "incoder",
      "3": "codex",
      "4": "codex",
      "5": "codex"
    },
    "0": "// Write your code here\n    long result = 1;\n    for (long i = 1; i <= 9; i++) {\n        result = (result * a) + (b - ((a * 9) % 10));\n    }\n    return result;",
    "grade-0": {
      "execution": 0
    },
    "1": "long ans = a;\n    long temp = b;\n    while (temp != 0) {\n        ans *= 10;\n        temp /= 10;\n    }\n    return ans;",
    "grade-1": {
      "execution": 0
    },
    "2": "int rem;\n\tlong res = 0;\n\twhile(a > 0) {\n\t\trem = a % 10;\n\t\tres = (res * 10) + rem;\n\t\ta = a / 10;\n\t}\n\twhile(b > 0) {\n\t\trem = b % 10;\n\t\tres = (res * 10) + rem;\n\t\tb = b / 10;\n\t}\n\treturn res;",
    "grade-2": {
      "execution": 0
    },
    "3": "return (a % 10) * (b % 10);",
    "grade-3": {
      "execution": 0
    },
    "4": "return a * b < 0 ? (a%10) * (b%10) : (a%10) * (b%10);",
    "grade-4": {
      "execution": 0
    },
    "5": "// Do something\n    string num1 = to_string(a);\n    string num2 = to_string(b);\n    return abs(num1[num1.length()-1] - '0') * abs(num2[num2.length()-1] - '0');",
    "grade-5": {
      "execution": 0
    }
  },
  {
    "intent": "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a non-empty array of integers arr and an integer k, return\n// the sum of the elements with at most two digits from the first k elements of arr.\n// Example:\n// Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n// Output: 24 # sum of 21 + 3\n// Constraints:\n// 1. 1 <= len(arr) <= 100\n// 2. 1 <= k <= len(arr)\nlong add_elements(std::vector<long> arr, long k) {\n",
    "task_id": "122",
    "prompt": "/*\nGiven a non-empty vector of integers arr and an integer k, return\nthe sum of the elements with at most two digits from the first k elements of arr.\n\nExample:\n\n    Input: arr = {111,21,3,4000,5,6,7,8,9}, k = 4\n    Output: 24 # sum of 21 + 3\n\nConstraints:\n    1. 1 <= len(arr) <= 100\n    2. 1 <= k <= len(arr)\n*/\n#include<stdio.h>\n#include<vector>\nusing namespace std;\nint add_elements(vector<int> arr,int k){\n",
    "simplified_intent": "Given a non-empty array of integers arr and an integer k, return the sum of the elements with at most two digits from the first k elements of arr.",
    "snippet": [
      "    int sum=0;\n    for (int i=0;i<k;i++)\n        if( arr[i]>=-99 and arr[i]<=99)\n            sum+=arr[i];\n    return sum;\n}\n"
    ],
    "sample_from": {
      "0": "incoder",
      "1": "incoder",
      "2": "incoder",
      "3": "codex",
      "4": "codex",
      "5": "codex"
    },
    "0": "// code here\n    long sum = 0;\n    long pos = 0;\n    while (pos < k) {\n        sum += arr[pos];\n        pos += 1;\n    }\n    return sum;",
    "grade-0": {
      "execution": 0
    },
    "1": "long ans = arr[0] + arr[1];\n    for(size_t i = 2; i < k; i++) {\n        ans += arr[i];\n    }\n    return ans;",
    "grade-1": {
      "execution": 0
    },
    "2": "std::stack<long> sum;\n  sum.push(arr[0]);\n  long sum = arr[0];\n  for (long i = 1; i < k; i++) {\n    long elem = arr[i];\n    sum += elem;\n    while (sum >= 10) {\n      sum -= 10;\n      sum.push(sum % 10);\n    }\n    sum.push(elem);\n  }\n  while (!sum.empty()) {\n    sum += sum.top();\n    sum.pop();\n  }\n  return sum;",
    "grade-2": {
      "execution": 0
    },
    "3": "long i = 0, sum = 0;\n    while(k > 0) {\n        if(arr[i] < 10) {\n            sum += arr[i];\n            i++;\n            k--;\n        }\n        else if(arr[i] >= 10 && arr[i] < 100) {\n            sum += arr[i];\n            i++;\n            k--;\n        }\n        else\n            i++;\n    }\n    return sum;",
    "grade-3": {
      "execution": 0
    },
    "4": "int i,sum=0;\n  for(i=0;i<k;i++)\n  {\n    if(arr[i]<100)\n    {\n      sum += arr[i];\n    }\n  }\n  return sum;",
    "grade-4": {
      "execution": 1
    },
    "5": "long sum = 0;\n    for(long i = 0; i < k; i++) {\n        if(arr[i] / 10 < 1) {\n            sum += arr[i];\n        }\n        else if(arr[i] / 100 < 1) {\n            sum += arr[i];\n        }\n    }\n    return sum;",
    "grade-5": {
      "execution": 1
    }
  },
  {
    "intent": "#include<assert.h>\n#include<bits/stdc++.h>\n// Your task is to implement a function that will simplify the expression\n// x * n. The function returns True if x * n evaluates to a whole number and False\n// otherwise. Both x and n, are string representation of a fraction, and have the following format,\n// <numerator>/<denominator> where both numerator and denominator are positive whole numbers.\n// You can assume that x, and n are valid fractions, and do not have zero as denominator.\n// simplify(\"1/5\", \"5/1\") = True\n// simplify(\"1/6\", \"2/1\") = False\n// simplify(\"7/10\", \"10/2\") = False\nbool simplify(std::string x, std::string n) {\n",
    "task_id": "144",
    "prompt": "/*\nYour task is to implement a function that will simplify the expression\nx * n. The function returns true if x * n evaluates to a whole number and false\notherwise. Both x and n, are string representation of a fraction, and have the following format,\n<numerator>/<denominator> where both numerator and denominator are positive whole numbers.\n\nYou can assume that x, and n are valid fractions, and do not have zero as denominator.\n\nsimplify(\"1/5\", \"5/1\") = true\nsimplify(\"1/6\", \"2/1\") = false\nsimplify(\"7/10\", \"10/2\") = false\n*/\n#include<stdio.h>\n#include<string>\nusing namespace std;\nbool simplify(string x,string n){\n",
    "simplified_intent": "Your task is to implement a function that will simplify the expression x * n. The function returns True if x * n evaluates to a whole number and False otherwise. Both x and n, are string representation of a fraction, and have the following format, <numerator>/<denominator> where both numerator and denominator are positive whole numbers. You can assume that x, and n are valid fractions, and do not have zero as denominator.",
    "snippet": [
      "    int a,b,c,d,i;\n    for (i=0;i<x.size();i++)\n        if (x[i]=='/') \n        {\n            a=atoi(x.substr(0,i).c_str());\n            b=atoi(x.substr(i+1).c_str());\n        }\n    for (i=0;i<n.size();i++)\n        if (n[i]=='/') \n        {\n            c=atoi(n.substr(0,i).c_str());\n            d=atoi(n.substr(i+1).c_str());\n        }\n    if ((a*c)%(b*d)==0) return true;\n    return false;\n}\n"
    ],
    "sample_from": {
      "0": "incoder",
      "1": "incoder",
      "2": "incoder",
      "3": "codex",
      "4": "codex",
      "5": "codex"
    },
    "0": "// Write code here.\n  // Print the expression simplification result.\n  if(x == \"0\" || x == \"/\" || x == \"*\" || x == \"-\" || x == \"+\")\n  return false;\n  if(!x.empty() && !n.empty())\n  int i=0;\n  int j=0;\n  int k=0;\n  while(x[i]!='/')\n  i++;\n  while(n[j]!='/')\n  j++;\n  while(x[i]==n[j])\n  {\n  i=0;\n  j=0;\n  k=0;\n  }\n  if(j==0)\n  return false;\n  int m=j;\n  while(x[i]=='/')\n  {\n  i=i+1;\n  k=0;\n  }\n  while(n[k]!='/')\n  {\n  k++;\n  m=m+1;\n  }\n  if(m>1)\n  return false;\n  return true;",
    "grade-0": {
      "execution": 0
    },
    "1": "int num_arr = stoi(x);\n    int denom_arr = stoi(n);\n    if (denom_arr == 0)\n        return false;\n    int res = num_arr / denom_arr;\n    if (res == 0)\n        return true;\n    if (res == 1)\n        return false;\n    \n    bool ans = false;\n    \n    while(denom_arr > 0) {\n        if (denom_arr % 2 == 0 && denom_arr > 1) {\n            int temp = denom_arr / 2;\n            \n            if (temp == 0)\n                return false;\n            int res_temp = temp / denom_arr;\n            if (res_temp == 1)\n                return true;\n            if (res_temp != 0)\n                ans = true;\n        } else if (denom_arr % 2 == 1 && denom_arr > 1) {\n            int temp = denom_arr * 2;\n            \n            if (temp == 0)\n                return false;\n            int res_temp = temp / denom_arr;\n            if (res_temp == 1)\n                return true;\n            if (res_temp != 0)\n                ans = true;\n        }\n        \n        denom_arr--;\n    }\n    return ans;",
    "grade-1": {
      "execution": 0
    },
    "2": "// Your code here\n    // Your code here\n    return true;",
    "grade-2": {
      "execution": 0
    },
    "3": "// your code here\n  \n  std::vector<int> num;\n  std::vector<int> den;\n  for(int i = 0; i < x.size(); i++)\n  {\n    if(x[i] == '/')\n    {\n      int j = i+1;\n      std::string temp = \"\";\n      while(j < x.size())\n      {\n        temp += x[j];\n        j++;\n      }\n      den.push_back(stoi(temp));\n      break;\n    }\n    else\n    {\n      num.push_back(x[i] - '0');\n    }\n  }\n  for(int i = 0; i < n.size(); i++)\n  {\n    if(n[i] == '/')\n    {\n      int j = i+1;\n      std::string temp = \"\";\n      while(j < n.size())\n      {\n        temp += n[j];\n        j++;\n      }\n      den.push_back(stoi(temp));\n      break;\n    }\n    else\n    {\n      num.push_back(n[i] - '0');\n    }\n  }\n  int numerator = num[0] * den[1] + num[1] * den[0];\n  int denominator = den[0] * den[1];\n  if(numerator % denominator == 0)\n  {\n    return true;\n  }\n  else\n  {\n    return false;\n  }",
    "grade-3": {
      "execution": 0
    },
    "4": "using std::stoi;\n    using std::string;\n    using std::stol;\n    using std::stoll;\n    string::size_type index = x.find(\"/\");\n    string num = x.substr(0, index);\n    string den = x.substr(index + 1);\n    string::size_type index2 = n.find(\"/\");\n    string num2 = n.substr(0, index2);\n    string den2 = n.substr(index2 + 1);\n    long numerator = stol(num);\n    long denominator = stol(den);\n    long numerator2 = stol(num2);\n    long denominator2 = stol(den2);\n    numerator *= denominator2;\n    denominator *= numerator2;\n    if (numerator % denominator == 0) {\n        return true;\n    }\n    return false;",
    "grade-4": {
      "execution": 0
    },
    "5": "int gc = gcd(atoi(x.substr(2).c_str()), atoi(n.substr(2).c_str()));\n    return atoi(x.substr(0, 1).c_str()) * atoi(n.substr(2).c_str()) % gc == 0;",
    "grade-5": {
      "execution": 0
    }
  },
  {
    "intent": "#include<assert.h>\n#include<bits/stdc++.h>\n// xs represent coefficients of a polynomial.\n// xs[0] + xs[1] * x + xs[2] * x^2 + ....\n// Return derivative of this polynomial in the same form.\n// >>> derivative([3, 1, 2, 4, 5])\n// [1, 4, 12, 20]\n// >>> derivative([1, 2, 3])\n// [2, 6]\nstd::vector<long> derivative(std::vector<long> xs) {\n",
    "task_id": "62",
    "prompt": "/*\nxs represent coefficients of a polynomial.\nxs{0} + xs{1} * x + xs{2} * x^2 + ....\n Return derivative of this polynomial in the same form.\n>>> derivative({3, 1, 2, 4, 5})\n{1, 4, 12, 20}\n>>> derivative({1, 2, 3})\n{2, 6}\n*/\n#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\nvector<float> derivative(vector<float> xs){\n",
    "simplified_intent": "xs represent coefficients of a polynomial. xs[0] + xs[1] * x + xs[2] * x^2 + .... Return derivative of this polynomial in the same form.",
    "snippet": [
      "    vector<float> out={};\n    for (int i=1;i<xs.size();i++)\n        out.push_back(i*xs[i]);\n    return out;\n}\n"
    ],
    "sample_from": {
      "0": "incoder",
      "1": "incoder",
      "2": "incoder",
      "3": "codex",
      "4": "codex",
      "5": "codex"
    },
    "0": "assert(xs.size() != 0);\n  std::vector<long> ds;\n  ds.push_back(xs[0]);\n  for (int i = 1; i < xs.size(); ++i) {\n    ds.push_back(ds[i - 1] * xs[i]);\n  }\n  return ds;",
    "grade-0": {
      "execution": 0
    },
    "1": "assert(xs.size() > 0);\n  std::vector<long> ret(xs.size() - 1);\n  for (size_t i = 1; i < xs.size(); ++i) {\n    ret[i] = xs[i] - xs[i - 1];\n  }\n  return ret;",
    "grade-1": {
      "execution": 0
    },
    "2": "// If xs[0] == 0 then derivative will be the constant 0.\n    if (xs[0] == 0) return std::vector<long>(0);\n\n    // The derivative will be the product of derivatives calculated from \n    // the left and right part of the array xs. In other words \n    // derivative(i) = d(i-1) * d(i-2) * .... * d(1)\n    std::vector<long> derivatives;\n    derivatives.push_back(xs[0]);\n    derivatives.push_back(xs[1]);\n    for (int i = 2; i <= xs.size(); i++) {\n        derivatives.push_back(xs[i] * derivatives[i-1]);\n    }\n\n    return derivatives;",
    "grade-2": {
      "execution": 0
    },
    "3": "std::vector<long> result(xs.size() - 1);\n    for (int i = 1; i < xs.size(); i++) {\n        result[i - 1] = xs[i] * i;\n    }\n    return result;",
    "grade-3": {
      "execution": 1
    },
    "4": "std::vector<long> ys;\n\tif (xs.size() == 0) {\n\t\treturn ys;\n\t}\n\tfor (int i = 1; i < xs.size(); i++) {\n\t\tys.push_back(xs[i] * i);\n\t}\n\treturn ys;",
    "grade-4": {
      "execution": 1
    },
    "5": "int size = xs.size();\n\tstd::vector<long> der(size - 1);\n\tint i;\n\tfor (i = 0; i < size - 1; i++) {\n\t\tder[i] = xs[i + 1] * (i + 1);\n\t}\n\treturn der;",
    "grade-5": {
      "execution": 1
    }
  },
  {
    "intent": "#include<assert.h>\n#include<bits/stdc++.h>\n// remove_vowels is a function that takes string and returns string without vowels.\n// >>> remove_vowels('')\n// ''\n// >>> remove_vowels('abcdef')\n// 'bcdf'\n// >>> remove_vowels('aaaaa')\n// ''\n// >>> remove_vowels('aaBAA')\n// 'B'\n// >>> remove_vowels('zbcd')\n// 'zbcd'\nstd::string remove_vowels(std::string text) {\n",
    "task_id": "51",
    "prompt": "/*\nremove_vowels is a function that takes string and returns string without vowels.\n>>> remove_vowels(\"\")\n\"\"\n>>> remove_vowels(\"abcdef\\nghijklm\")\n\"bcdf\\nghjklm\"\n>>> remove_vowels(\"abcdef\")\n\"bcdf\"\n>>> remove_vowels(\"aaaaa\")\n\"\"\n>>> remove_vowels(\"aaBAA\")\n\"B\"\n>>> remove_vowels(\"zbcd\")\n\"zbcd\"\n*/\n#include<stdio.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\nstring remove_vowels(string text){\n",
    "simplified_intent": "remove_vowels is a function that takes string and returns string without vowels.",
    "snippet": [
      "    string out=\"\";\n    string vowels=\"AEIOUaeiou\";\n    for (int i=0;i<text.length();i++)\n        if (find(vowels.begin(),vowels.end(),text[i])==vowels.end())\n            out=out+text[i];\n    return out;\n\n}\n"
    ],
    "sample_from": {
      "0": "incoder",
      "1": "incoder",
      "2": "incoder",
      "3": "codex",
      "4": "codex",
      "5": "codex"
    },
    "0": "std::string vowels = \"aeiou\";\n    std::string new_text;\n    for (size_t i = 0; i < text.size(); i++) {\n        new_text += text[i];\n        if (std::find(vowels.begin(), vowels.end(), text[i]) != vowels.end())\n            new_text += 'A';\n    }\n    return new_text;",
    "grade-0": {
      "execution": 0
    },
    "1": "std::string vowels = \"aeiou\";\n  std::string consonants = \"bcdfghjklmnpqrstvwxz\";\n  int i = 0;\n  int j = -1;\n  std::string answer = \"\";\n  while (i != text.length()) {\n    // i points to the first character of the string\n    // j points to the last character of the string\n    if (text[i] == consonants) {\n      j = i;\n    } else {\n      if (text[i] == vowels) {\n        j += 2;\n      } else {\n        j++;\n      }\n    }\n    answer += text.substr(i, j);\n    i = j;\n  }\n  return answer;",
    "grade-1": {
      "execution": 0
    },
    "2": "// Write your code here\n    int i=0;\n    for(;i < text.length();i++)\n    {\n        for(int j=0;j<strlen(text[i]);j++)\n        {\n            if(text[i][j]=='a' || text[i][j]=='e' || text[i][j]=='i' || text[i][j]=='o' || text[i][j]=='u')\n                text[i] = text[i+1];\n        }\n    }\n    return text;",
    "grade-2": {
      "execution": 0
    },
    "3": "std::string result = \"\";\n    for (size_t i = 0; i < text.size(); i++) {\n        if (text[i] != 'a' && text[i] != 'e' && text[i] != 'i' && text[i] != 'o' && text[i] != 'u' && text[i] != 'A' && text[i] != 'E' && text[i] != 'I' && text[i] != 'O' && text[i] != 'U') {\n            result += text[i];\n        }\n    }\n    return result;",
    "grade-3": {
      "execution": 1
    },
    "4": "// put your code here\n    int len = text.length();\n    std::string out = \"\";\n    for(int i = 0; i < len; i++){\n        char ch = text[i];\n        if(!(ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u' || ch == 'A' || ch == 'E' || ch == 'I' || ch == 'O' || ch == 'U')){\n            out += ch;\n        }\n    }\n    return out;",
    "grade-4": {
      "execution": 1
    },
    "5": "int i=0;\n    while(i<text.length())\n    {\n        switch(text[i])\n        {\n            case 'a':\n            case 'e':\n            case 'i':\n            case 'o':\n            case 'u':\n            case 'A':\n            case 'E':\n            case 'I':\n            case 'O':\n            case 'U':\n                text.erase(i,1);\n                break;\n            default:\n                i++;\n        }\n    }\n    return text;",
    "grade-5": {
      "execution": 1
    }
  },
  {
    "intent": "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a string of words separated by commas or spaces. Your task is\n// to split the string into words and return an array of the words.\n// For example:\n// words_string(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n// words_string(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\nstd::vector<std::string> words_string(std::string s) {\n",
    "task_id": "101",
    "prompt": "/*\nYou will be given a string of words separated by commas or spaces. Your task is\nto split the string into words and return a vector of the words.\n\nFor example:\nwords_string(\"Hi, my name is John\") == {\"Hi\", \"my\", \"name\", \"is\", \"John\"}\nwords_string(\"One, two, three, four, five, six\") == {\"One\", 'two\", 'three\", \"four\", \"five\", 'six\"}\n*/\n#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\nvector<string> words_string(string s){\n",
    "simplified_intent": "You will be given a string of words separated by commas or spaces. Your task is to split the string into words and return an array of the words.",
    "snippet": [
      "    string current=\"\";\n    vector<string> out={};\n    s=s+' ';\n    for (int i=0;i<s.length();i++)\n     if (s[i]==' ' or s[i]==',')\n     {\n        if (current.length()>0)\n        {\n            out.push_back(current);\n            current=\"\";\n        }\n     }\n     else current=current+s[i];\n     return out;\n}\n"
    ],
    "sample_from": {
      "0": "incoder",
      "1": "incoder",
      "2": "incoder",
      "3": "codex",
      "4": "codex",
      "5": "codex"
    },
    "0": "std::vector<std::string> v;\n  std::istringstream iss(s);\n  std::string word;\n  while (std::getline(iss, word, ',')) {\n    v.push_back(word);\n  }\n  return v;",
    "grade-0": {
      "execution": 0
    },
    "1": "std::string s_trim(s.c_str());\n    s_trim.erase(std::find_if(s_trim.begin(), s_trim.end(), ::isspace), s_trim.end());\n    std::istringstream ss(s_trim);\n    std::vector<std::string> words;\n    std::string word;\n    while (std::getline(ss, word, ',')) {\n        words.push_back(word);\n    }\n    return words;",
    "grade-1": {
      "execution": 0
    },
    "2": "std::vector<std::string> res;\n\tstd::istringstream iss(s);\n\tstd::string word;\n\twhile (iss >> word) {\n\t\tres.push_back(word);\n\t}\n\treturn res;",
    "grade-2": {
      "execution": 0
    },
    "3": "std::vector<std::string> ret;\n    int prev_idx = 0;\n    for (int i = 0; i < s.size(); i++) {\n        if (s[i] == ' ' || s[i] == ',') {\n            ret.push_back(s.substr(prev_idx, i - prev_idx));\n            prev_idx = i + 1;\n        }\n    }\n    ret.push_back(s.substr(prev_idx, s.size() - prev_idx));\n    return ret;",
    "grade-3": {
      "execution": 0
    },
    "4": "std::istringstream iss(s);\n  std::vector<std::string> v{ std::istream_iterator<std::string>{iss},\n                              std::istream_iterator<std::string>{} };\n  return v;",
    "grade-4": {
      "execution": 0
    },
    "5": "std::vector<std::string>v;\n  std::string str;\n  std::stringstream ss(s);\n  while(ss >> str)\n  {\n    v.push_back(str);\n  }\n  return v;",
    "grade-5": {
      "execution": 0
    }
  },
  {
    "intent": "#include<assert.h>\n#include<bits/stdc++.h>\n// This function takes two positive numbers x and y and returns the\n// biggest even integer number that is in the range [x, y] inclusive. If \n// there's no such number, then the function should return -1.\n// For example:\n// choose_num(12, 15) = 14\n// choose_num(13, 12) = -1\nlong choose_num(long x, long y) {\n",
    "task_id": "102",
    "prompt": "/*\nThis function takes two positive numbers x and y and returns the\nbiggest even integer number that is in the range [x, y] inclusive. If \nthere's no such number, then the function should return -1.\n\nFor example:\nchoose_num(12, 15) = 14\nchoose_num(13, 12) = -1\n*/\n#include<stdio.h>\nusing namespace std;\nint choose_num(int x,int y){\n",
    "simplified_intent": "This function takes two positive numbers x and y and returns the biggest even integer number that is in the range [x, y] inclusive. If there's no such number, then the function should return -1.",
    "snippet": [
      "    if (y<x) return -1;\n    if (y==x and y%2==1) return -1;\n    if (y%2==1) return y-1;\n    return y;\n}\n"
    ],
    "sample_from": {
      "0": "incoder",
      "1": "incoder",
      "2": "incoder",
      "3": "codex",
      "4": "codex",
      "5": "codex"
    },
    "0": "if (x > y || x == 0)\n        return -1;\n\n    long mid = (x + y) / 2;\n    if (mid % 2 == 0)\n        return mid;\n    if (mid < x)\n        return choose_num(y, mid);\n    return choose_num(mid, y);",
    "grade-0": {
      "execution": 0
    },
    "1": "if(x>y) {\n        x = y-1;\n    }\n    if(x>=0 && y>=0) {\n        for(long i = x; i<=y; i++) {\n            if(i%2==0) {\n                return i;\n            }\n        }\n    }\n    return -1;",
    "grade-1": {
      "execution": 0
    },
    "2": "if (x >= y)\n    return -1;\n  else\n    return x;",
    "grade-2": {
      "execution": 0
    },
    "3": "for (long i = y; i >= x; i--) {\n        if ((i % 2) == 0) {\n            return i;\n        }\n    }\n    return -1;",
    "grade-3": {
      "execution": 1
    },
    "4": "// TODO: write your code here\n  long bigEven = -1;\n  for(long i = x; i <= y; i++){\n    if(i % 2 == 0){\n      bigEven = i;\n    }\n  }\n  return bigEven;",
    "grade-4": {
      "execution": 1
    },
    "5": "long number;\n\tnumber = x % 2;\n\tif (number == 0) {\n\t\treturn x;\n\t}\n\telse {\n\t\tif (x + 1 <= y) {\n\t\t\treturn x + 1;\n\t\t}\n\t\telse {\n\t\t\treturn -1;\n\t\t}\n\t}",
    "grade-5": {
      "execution": 0
    }
  },
  {
    "intent": "#include<assert.h>\n#include<bits/stdc++.h>\n// prime_fib returns n-th number that is a Fibonacci number and it's also prime.\n// >>> prime_fib(1)\n// 2\n// >>> prime_fib(2)\n// 3\n// >>> prime_fib(3)\n// 5\n// >>> prime_fib(4)\n// 13\n// >>> prime_fib(5)\n// 89\nlong prime_fib(long n) {\n",
    "task_id": "39",
    "prompt": "/*\nprime_fib returns n-th number that is a Fibonacci number and it's also prime.\n>>> prime_fib(1)\n2\n>>> prime_fib(2)\n3\n>>> prime_fib(3)\n5\n>>> prime_fib(4)\n13\n>>> prime_fib(5)\n89\n*/\n#include<stdio.h>\nusing namespace std;\nint prime_fib(int n){\n",
    "simplified_intent": "prime_fib returns n-th number that is a Fibonacci number and it's also prime.",
    "snippet": [
      "    int f1,f2,m;\n    f1=1;f2=2;\n    int count=0;\n    while (count<n)\n    {\n        f1=f1+f2;\n        m=f1;f1=f2;f2=m;\n        bool isprime=true;\n        for (int w=2;w*w<=f1;w++)\n            if (f1%w==0)\n            {\n             isprime=false; break;\n            }\n        if (isprime) count+=1;\n        if (count==n) return f1;\n    }\n\n}\n"
    ],
    "sample_from": {
      "0": "incoder",
      "1": "incoder",
      "2": "incoder",
      "3": "codex",
      "4": "codex",
      "5": "codex"
    },
    "0": "if (n <= 2) return 2;\n  if (n <= 3) return 3;\n  if (n % 2 == 0) return prime_fib(n * 3) + 2;\n  if (n % 3 == 0) return prime_fib((n - 1) * 5 + 4) + 3;\n  long f = prime_fib((n - 1) * 5 + 4) + 3;\n  return f + 2;",
    "grade-0": {
      "execution": 0
    },
    "1": "long long fib1 = 1, fib2 = 1, fibSum = 0;\n    for (long long i = 2; i <= n; i++) {\n        fib2 = fib1;\n        fib1 = fibSum;\n        fibSum += fib2;\n    }\n    return fibSum;",
    "grade-1": {
      "execution": 0
    },
    "2": "long count = 0;\n    int isprime = 1;\n    long result = 0;\n    while (isprime == 1) {\n        result = result + (n & 1) + ((n >> 1) & 1);\n        isprime = (!(n & 3) && ((n >> 2) & 1));\n        n = n >> 1;\n        count++;\n    }\n    return result;",
    "grade-2": {
      "execution": 0
    },
    "3": "long a = 1, b = 1, index = 0;\n\twhile (true) {\n\t\tif (index == n)\n\t\t\treturn b;\n\t\tlong c = a + b;\n\t\tif (is_prime(c))\n\t\t\tindex++;\n\t\ta = b;\n\t\tb = c;\n\t}",
    "grade-3": {
      "execution": 0
    },
    "4": "long a = 2, b = 3, i = 2, c;\n    while (i < n) {\n        c = a + b;\n        a = b;\n        b = c;\n        if (b % 2 != 0) {\n            for (long j = 3; j * j <= b; j = j + 2) {\n                if (b % j == 0) {\n                    break;\n                }\n                else if (j * j > b) {\n                    i = i + 1;\n                }\n            }\n        }\n    }\n    return c;",
    "grade-4": {
      "execution": 0
    },
    "5": "std::vector<int> primes(n);\n    primes[0] = 2;\n    int idx = 1;\n    int i = 3;\n    while (idx < n) {\n        bool is_prime = true;\n        for (int j = 0; j < idx; j++) {\n            if (i % primes[j] == 0) {\n                is_prime = false;\n                break;\n            }\n        }\n        if (is_prime) {\n            primes[idx] = i;\n            idx++;\n        }\n        i += 2;\n    }\n    std::vector<long> fib(n);\n    fib[0] = 0;\n    fib[1] = 1;\n    for (int i = 2; i < n; i++) {\n        fib[i] = fib[i - 1] + fib[i - 2];\n    }\n    long fib_idx = 1;\n    long ans = 2;\n    while (fib_idx < n) {\n        ans = primes[fib_idx];\n        fib_idx++;\n    }\n    return ans;",
    "grade-5": {
      "execution": 0
    }
  },
  {
    "intent": "#include<assert.h>\n#include<bits/stdc++.h>\n// Evaluate whether the given number n can be written as the sum of exactly 4 positive even numbers\n// Example\n// is_equal_to_sum_even(4) == False\n// is_equal_to_sum_even(6) == False\n// is_equal_to_sum_even(8) == True\nbool is_equal_to_sum_even(long n) {\n",
    "task_id": "138",
    "prompt": "/*\nEvaluate whether the given number n can be written as the sum of exactly 4 positive even numbers\nExample\nis_equal_to_sum_even(4) == false\nis_equal_to_sum_even(6) == false\nis_equal_to_sum_even(8) == true\n*/\n#include<stdio.h>\nusing namespace std;\nbool is_equal_to_sum_even(int n){\n",
    "simplified_intent": "Evaluate whether the given number n can be written as the sum of exactly 4 positive even numbers",
    "snippet": [
      "    if (n%2==0 and n>=8) return true;\n    return false;\n}\n"
    ],
    "sample_from": {
      "0": "incoder",
      "1": "incoder",
      "2": "incoder",
      "3": "codex",
      "4": "codex",
      "5": "codex"
    },
    "0": "long ans = 1;\n    int digit = 0;\n    for(; n > 0; n /= 10)\n    {\n        digit *= 10;\n        digit += n%10;\n    }\n\n    for(int i = 1; i <= 4; i++)\n    {\n        if(digit%i == 0)\n        {\n            return false;\n        }\n    }\n    return true;",
    "grade-0": {
      "execution": 0
    },
    "1": "long long sum = 0;\n\tfor (int i = 0; i < n; i++)\n\t\tsum+=i;\n\treturn sum%4==0;",
    "grade-1": {
      "execution": 0
    },
    "2": "if (n == 0)\n        return true;\n    // Base case\n    if (n == 1)\n        return false;\n    // If n is even, we need to check if n is equal to the sum of 3 odd numbers\n    if (n % 2 == 0)\n        return is_equal_to_sum_even(3 * n + 1) == false;\n    // If n is odd, we check if n is equal to the sum of 2 odd numbers\n    return is_equal_to_sum_even(2 * n + 1) == false;",
    "grade-2": {
      "execution": 0
    },
    "3": "// Write your code here",
    "grade-3": {
      "execution": 0
    },
    "4": "// Write your code here\n    long m,i,count=0;\n    for(i=2;i<=n;i+=2)\n    {\n        m=n-i;\n        if(m%2==0)\n        {\n            count++;\n        }\n    }\n    if(count==1)\n    {\n        return true;\n    }\n    else{\n        return false;\n    }",
    "grade-4": {
      "execution": 0
    },
    "5": "// Write your code here\n    if(n%2!=0){\n        return false;\n    }\n    long a,b,c,d;\n    for(a=0;a<=n;a+=2){\n        for(b=0;b<=n;b+=2){\n            for(c=0;c<=n;c+=2){\n                for(d=0;d<=n;d+=2){\n                    if(a+b+c+d==n){\n                        return true;\n                    }\n                }\n            }\n        }\n    }\n    return false;",
    "grade-5": {
      "execution": 0
    }
  },
  {
    "intent": "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\nstd::vector<long> parse_music(std::string music_string) {\n",
    "task_id": "17",
    "prompt": "/*\nInput to this function is a string representing musical notes in a special ASCII format.\nYour task is to parse this string and return vector of integers corresponding to how many beats does each\nnot last.\n\nHere is a legend:\n\"o\" - whole note, lasts four beats\n\"o|\" - half note, lasts two beats\n\".|\" - quater note, lasts one beat\n\n>>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\n*/\n#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\nvector<int> parse_music(string music_string){ \n",
    "simplified_intent": "Input to this function is a string representing musical notes in a special ASCII format. Your task is to parse this string and return list of integers corresponding to how many beats does each not last. Here is a legend: 'o' - whole note, lasts four beats 'o|' - half note, lasts two beats '.|' - quater note, lasts one beat",
    "snippet": [
      "    string current=\"\";\n    vector<int> out={};\n    if (music_string.length()>0)\n        music_string=music_string+' ';\n    for (int i=0;i<music_string.length();i++)\n    {\n        if (music_string[i]==' ')\n        {\n            if (current==\"o\") out.push_back(4);\n            if (current==\"o|\") out.push_back(2);\n            if (current==\".|\") out.push_back(1);\n            current=\"\";\n        }\n        else current+=music_string[i];\n    }\n    return out;\n}\n"
    ],
    "sample_from": {
      "0": "incoder",
      "1": "incoder",
      "2": "incoder",
      "3": "codex",
      "4": "codex",
      "5": "codex"
    },
    "0": "std::vector<long> music_notes;\n    for (auto &note : music_string) {\n        if (note == 'o') {\n            music_notes.push_back(4);\n        } else if (note == 'o|') {\n            music_notes.push_back(2, 2);\n        } else if (note == '.|') {\n            music_notes.push_back(1, 1);\n        } else {\n            std::cerr << \"Parsing error: Unknown note \" << note << std::endl;\n            std::exit(-1);\n        }\n    }\n\n    return music_notes;",
    "grade-0": {
      "execution": 0
    },
    "1": "// Write your code here\n    \n    std::vector<long> beats;\n    int cur_beat_counter = 0;\n    int cur_beat_counter2 = 0;\n    bool note_flag = false;\n    char note_char = '\\0';\n    for(int i = 0; i < music_string.length(); i++) {\n        if(music_string[i] == 'o'){\n            if(cur_beat_counter != 0)\n                beats.push_back(cur_beat_counter);\n                cur_beat_counter = 0;\n            note_flag = true;\n            note_char = 'o';\n        } else if(music_string[i] == '|'){\n            if(cur_beat_counter2 != 0)\n                beats.push_back(cur_beat_counter);\n                beats.push_back(cur_beat_counter2);\n                cur_beat_counter = 0;\n                cur_beat_counter2 = 0;\n            note_flag = true;\n            note_char = '|';\n        } else if(music_string[i] == note_char){\n            if(!note_flag){\n                cur_beat_counter++;\n            }\n            note_flag = false;\n            note_char = '\\0';\n        } else {\n            if(note_flag){\n                cur_beat_counter2++;\n            }\n        }\n    }\n    if(cur_beat_counter2 != 0)\n        beats.push_back(cur_beat_counter);\n    return beats;",
    "grade-1": {
      "execution": 0
    },
    "2": "std::vector<long> beats(music_string.size());\n  // Here comes the main idea. We need to find out how many beats does each note last.\n  // Let's take an example.\n  // Notes:\n  //   o - whole note, lasts four beats\n  //   o| - half note, lasts two beats\n  //   .| - quater note, lasts one beat\n  // Given a string like `o o| .| o| o| .| .| .| .| o o`, we will have 2 notes left and last one for\n  // two beats. So the answer for this example will be [2, 1, 1, 1, 1, 4, 4].\n  // In general, there can be an arbitrary number of notes and any number of beats for each note.\n  // We will try to figure out how many beats does each note last.\n  // To do this, we will count how many times each note appears in the string.\n  // After counting how many times each note appears in the string, we can easily figure out how many beats\n  // each note lasts. But there is a catch.\n  // We need to handle three cases:\n  //   1. when there is only one note (no \"|\") in the string\n  //   2. when there is no \"|\" in the string\n  //   3. when there is \"|\" in the string\n  // We will deal with the third case first.\n  // Case 3 is easy because we can always count how many times a note appears in the string.\n  // Case 2 is easy to handle by simply subtracting number of beats after the last \"|\" from the number\n  // of beats before the penultimate \"|\". We will also have a special case when \"|\" appears at the beginning.\n  // This means we need to subtract 2 from the number of beats and when \"|\" appears at the beginning,\n  // we need to subtract 1 from the number of beats.\n  // If there are more \"|\" in the string, we will simply add them to the number before \"|\".\n  // For case 1, we will deal with this case first and then add it to the case 2. For example,\n  // given `o o| .| o| o| .| .| .| .| .| o o`, we will deal with case 3 first and then\n  // add case 2 if needed.\n  for (int i = music_string.size() - 1; i >= 0; i--) {\n    if (music_string[i] == '|') {\n      // When we have \"|\" in the string\n      // We need to subtract 2 from number of beats\n      // and when \"|\" appears at the beginning,\n      // we need to subtract 1 from the number of beats\n      // so we need 2 subtractions for case 1, and",
    "grade-2": {
      "execution": 0
    },
    "3": "// your code here\n    std::vector<long> v;\n    if(music_string.size() == 0)\n    {\n        return v;\n    }\n    if(music_string.at(0) == 'o')\n    {\n        v.push_back(4);\n    }\n    else if(music_string.at(0) == 'o' && music_string.at(1) == '|')\n    {\n        v.push_back(2);\n    }\n    else if(music_string.at(0) == '.' && music_string.at(1) == '|')\n    {\n        v.push_back(1);\n    }\n    else\n    {\n        std::cout << \"Invalid Input\" << std::endl;\n    }\n    for(int i = 1; i < music_string.size(); i++)\n    {\n        if(music_string.at(i) == ' ')\n        {\n            if(music_string.at(i+1) == 'o')\n            {\n                v.push_back(4);\n            }\n            else if(music_string.at(i+1) == 'o' && music_string.at(i+2) == '|')\n            {\n                v.push_back(2);\n            }\n            else if(music_string.at(i+1) == '.' && music_string.at(i+2) == '|')\n            {\n                v.push_back(1);\n            }\n            else\n            {\n                std::cout << \"Invalid Input\" << std::endl;\n            }\n        }\n    }\n    return v;",
    "grade-3": {
      "execution": 0
    },
    "4": "// let the fun begin\n    std::vector<long> beats;\n    long beat = 0;\n    for (auto s : music_string) {\n        switch (s) {\n            case 'o':\n                beats.push_back(beat);\n                beat = 4;\n                break;\n            case '|':\n                beats.push_back(beat);\n                beat = 0;\n                break;\n            case '.':\n                beat++;\n                break;\n            case ' ':\n                break;\n            default:\n                assert(false);\n        }\n    }\n    beats.push_back(beat);\n    return beats;",
    "grade-4": {
      "execution": 0
    },
    "5": "std::vector<long> beats;\n\tfor (int i = 0; i < music_string.length(); i++) {\n\t\tif (music_string[i] == 'o')\n\t\t\tbeats.push_back(4);\n\t\telse if (music_string[i] == '|')\n\t\t\tbeats.push_back(2);\n\t\telse if (music_string[i] == '.')\n\t\t\tbeats.push_back(1);\n\t}\n\treturn beats;",
    "grade-5": {
      "execution": 0
    }
  },
  {
    "intent": "#include<assert.h>\n#include<bits/stdc++.h>\n// Check if two words have the same characters.\n// >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n// True\n// >>> same_chars('abcd', 'dddddddabc')\n// True\n// >>> same_chars('dddddddabc', 'abcd')\n// True\n// >>> same_chars('eabcd', 'dddddddabc')\n// False\n// >>> same_chars('abcd', 'dddddddabce')\n// False\n// >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n// False\nbool same_chars(std::string s0, std::string s1) {\n",
    "task_id": "54",
    "prompt": "/*\nCheck if two words have the same characters.\n>>> same_chars(\"eabcdzzzz\", \"dddzzzzzzzddeddabc\")\ntrue\n>>> same_chars(\"abcd\", \"dddddddabc\")\ntrue\n>>> same_chars(\"dddddddabc\", \"abcd\")\ntrue\n>>> same_chars(\"eabcd\", \"dddddddabc\")\nfalse\n>>> same_chars(\"abcd\", \"dddddddabce\")\nfalse\n>>> same_chars(\"eabcdzzzz\", \"dddzzzzzzzddddabc\")\nfalse\n*/\n#include<stdio.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\nbool same_chars(string s0,string s1){\n",
    "simplified_intent": "Check if two words have the same characters.",
    "snippet": [
      "    for (int i=0;i<s0.length();i++)\n    if (find(s1.begin(),s1.end(),s0[i])==s1.end())\n        return false;\n    for (int i=0;i<s1.length();i++)\n    if (find(s0.begin(),s0.end(),s1[i])==s0.end())\n        return false;\n    return true;   \n}\n"
    ],
    "sample_from": {
      "0": "incoder",
      "1": "incoder",
      "2": "incoder",
      "3": "codex",
      "4": "codex",
      "5": "codex"
    },
    "0": "size_t i = 0, j = 0;\n    bool flag = false;\n    while ((i < s0.size()) && (j < s1.size())) {\n        if (s0[i] != s1[j])\n            flag = false;\n        else\n            i++;\n        j++;\n    }\n    return flag;",
    "grade-0": {
      "execution": 0
    },
    "1": "if(s0.size() <= s1.size()) return false;\n    \n    std::vector<bool> v1(s0.begin(), s0.end());\n    std::vector<bool> v2(s1.begin(), s1.end());\n    \n    v1.erase(std::remove(v1.begin(), v1.end(), false), v1.end());\n    v2.erase(std::remove(v2.begin(), v2.end(), false), v2.end());\n    \n    return (v1 == v2);",
    "grade-1": {
      "execution": 0
    },
    "2": "std::string::const_iterator it0 = s0.begin();\n  std::string::const_iterator it1 = s1.begin();\n  while (it0 != s0.end() && it1 != s1.end()) {\n    if (*it0 == *it1) {\n      it0++;\n      it1++;\n    } else {\n      return false;\n    }\n  }\n  return true;",
    "grade-2": {
      "execution": 0
    },
    "3": "for(char ch: s0)\n        if(s1.find(ch) == std::string::npos)\n            return false;\n    for(char ch: s1)\n        if(s0.find(ch) == std::string::npos)\n            return false;\n    return true;",
    "grade-3": {
      "execution": 1
    },
    "4": "std::map<char, int> freq1;\n    std::map<char, int> freq2;\n    for (auto c : s0) {\n        freq1[c]++;\n    }\n    for (auto c : s1) {\n        freq2[c]++;\n    }\n    return freq1 == freq2;",
    "grade-4": {
      "execution": 0
    },
    "5": "std::unordered_map<char, int> d1;\n    for (auto c : s0) {\n        if (d1.find(c) == d1.end()) {\n            d1[c] = 1;\n        } else {\n            d1[c] += 1;\n        }\n    }\n    for (auto c : s1) {\n        if (d1.find(c) == d1.end()) {\n            return false;\n        } else {\n            d1[c] -= 1;\n        }\n    }\n    for (auto x : d1) {\n        if (x.second != 0) {\n            return false;\n        }\n    }\n    return true;",
    "grade-5": {
      "execution": 0
    }
  },
  {
    "intent": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that accepts a list of strings.\n// The list contains different words. Return the word with maximum number\n// of unique characters. If multiple strings have maximum number of unique\n// characters, return the one which comes first in lexicographical order.\n// find_max([\"name\", \"of\", \"string\"]) == \"string\"\n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nstd::string find_max(std::vector<std::string> words) {\n",
    "task_id": "158",
    "prompt": "/*\nWrite a function that accepts a vector of strings.\nThe vector contains different words. Return the word with maximum number\nof unique characters. If multiple strings have maximum number of unique\ncharacters, return the one which comes first in lexicographical order.\n\nfind_max({\"name\", \"of\", 'string\"}) == 'string\"\nfind_max({\"name\", \"enam\", \"game\"}) == \"enam\"\nfind_max({\"aaaaaaa\", \"bb\" ,\"cc\"}) == \"aaaaaaa\"\n*/\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\nstring find_max(vector<string> words){\n",
    "simplified_intent": "Write a function that accepts a list of strings. The list contains different words. Return the word with maximum number of unique characters. If multiple strings have maximum number of unique characters, return the one which comes first in lexicographical order.",
    "snippet": [
      "    string max=\"\";\n    int maxu=0;\n    for (int i=0;i<words.size();i++)\n    {\n        string unique=\"\";\n        for (int j=0;j<words[i].length();j++)\n            if (find(unique.begin(),unique.end(),words[i][j])==unique.end())\n                unique=unique+words[i][j];\n        if (unique.length()>maxu or (unique.length()==maxu and words[i]<max))\n        {\n            max=words[i];\n            maxu=unique.length();\n        }\n    }\n    return max;\n}\n"
    ],
    "sample_from": {
      "0": "incoder",
      "1": "incoder",
      "2": "incoder",
      "3": "codex",
      "4": "codex",
      "5": "codex"
    },
    "0": "// Write your code here.\n    // The code should contain following functions:\n    // 1. bool word_unique(std::vector<std::string> words)\n    // 2. std::string find_max(std::vector<std::string> words)\n    // The function find_max should return maximum word in the list.\n    // For example, if the list is [\"a\", \"b\", \"ab\", \"c\", \"ab\", \"a\"]\n    // The function will return \"ab\" since it has 2 unique characters\n    // The function word_unique should return true if all words have same number of unique characters and false otherwise.\n    // For example [\"aaaaaaa\", \"bb\" ,\"cc\"] is false.\n    // So the function should return true if the word is unique or false otherwise.\n    assert(words.size() > 1);\n    int max_count = words[0].length();\n    for (int i = 1; i < words.size(); i++) {\n        int count = words[i].length();\n        if (max_count < count) max_count = count;\n    }\n    if (words[0].length() == max_count) {\n        return words[0];\n    }\n    for (int i = 1; i < words.size(); i++) {\n        if (words[i].length() == max_count) {\n            return words[i];\n        }\n    }\n    return \"\";",
    "grade-0": {
      "execution": 0
    },
    "1": "std::string res = \"\";\n    int max = 0;\n    for (auto &w : words) {\n        auto count = std::count_if(w.begin(), w.end(), [](char c) {return !isalpha(c);});\n        if (count > max) {\n            max = count;\n            res = w;\n        }\n    }\n    return res;",
    "grade-1": {
      "execution": 0
    },
    "2": "int n = words.size();\n    std::string temp;\n    int ucount = 0;\n    for (int i = 0; i < n; i++)\n        for (int j = 0; j < n; j++) {\n            if (i != j) {\n                if (words[i].size() > words[j].size()) {\n                    temp = words[i];\n                    words[i] = words[j];\n                    words[j] = temp;\n                }\n                int char_count = 0;\n                for (int k = 0; k < words[i].size(); k++) {\n                    char c = words[i][k];\n                    char_count = char_count + std::count(words[j].begin() + k, words[j].end(), c);\n                }\n                if (char_count > ucount) {\n                    ucount = char_count;\n                    temp = words[i];\n                }\n            }\n        }\n    return temp;",
    "grade-2": {
      "execution": 0
    },
    "3": "std::string max_word = \"\";\n   int max_count = 0;\n   for (auto & word : words) {\n      int word_size = word.size();\n      std::unordered_set<char> char_set;\n      for (auto & ch : word) {\n         char_set.insert(ch);\n      }\n      int char_count = char_set.size();\n      if (char_count > max_count) {\n         max_count = char_count;\n         max_word = word;\n      } else if (char_count == max_count) {\n         if (word < max_word) {\n            max_word = word;\n         }\n      }\n   }\n   return max_word;",
    "grade-3": {
      "execution": 1
    },
    "4": "int max_size = 0;\n    std::string ret = \"\";\n    for (auto w : words) {\n        std::set<char> st;\n        for (auto c : w) {\n            st.insert(c);\n        }\n        if (max_size < st.size()) {\n            max_size = st.size();\n            ret = w;\n        }\n    }\n    return ret;",
    "grade-4": {
      "execution": 0
    },
    "5": "std::string max_str = \"\";\n  int max_count = 0;\n  for (auto word : words) {\n    int count = 0;\n    int chars[256] = {0};\n    for (auto ch : word) {\n      if (chars[ch] == 0) {\n        count++;\n        chars[ch] = 1;\n      }\n    }\n    if (count > max_count) {\n      max_count = count;\n      max_str = word;\n    }\n  }\n  return max_str;",
    "grade-5": {
      "execution": 0
    }
  },
  {
    "intent": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which takes a string representing a file's name, and returns\n// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n// A file's name is considered to be valid if and only if all the following conditions \n// are met:\n// - There should not be more than three digits ('0'-'9') in the file's name.\n// - The file's name contains exactly one dot '.'\n// - The substring before the dot should not be empty, and it starts with a letter from \n// the latin alphapet ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n// Examples:\n// file_name_check(\"example.txt\") # => 'Yes'\n// file_name_check(\"1example.dll\") # => 'No' (the name should start with a latin alphapet letter)\nstd::string file_name_check(std::string file_name) {\n",
    "task_id": "141",
    "prompt": "/*\nCreate a function which takes a string representing a file's name, and returns\n\"Yes\" if the the file's name is valid, and returns \"No\" otherwise.\nA file's name is considered to be valid if and only if all the following conditions \nare met:\n- There should not be more than three digits ('0'-'9') in the file's name.\n- The file's name contains exactly one dot \".\"\n- The substring before the dot should not be empty, and it starts with a letter from \nthe latin alphapet ('a'-'z' and 'A'-'Z').\n- The substring after the dot should be one of these: {'txt\", \"exe\", \"dll\"}\nExamples:\nfile_name_check(\"example.txt\") => \"Yes\"\nfile_name_check(\"1example.dll\")  => \"No\" // (the name should start with a latin alphapet letter)\n*/\n#include<stdio.h>\n#include<string>\nusing namespace std;\nstring file_name_check(string file_name){\n",
    "simplified_intent": "Create a function which takes a string representing a file's name, and returns 'Yes' if the the file's name is valid, and returns 'No' otherwise. A file's name is considered to be valid if and only if all the following conditions are met: - There should not be more than three digits ('0'-'9') in the file's name. - The file's name contains exactly one dot '.' - The substring before the dot should not be empty, and it starts with a letter from the latin alphapet ('a'-'z' and 'A'-'Z'). - The substring after the dot should be one of these: ['txt', 'exe', 'dll']",
    "snippet": [
      "    int numdigit=0,numdot=0;\n    if (file_name.length()<5) return \"No\";\n    char w=file_name[0];\n    if (w<65 or (w>90 and w<97) or w>122) return \"No\";\n    string last=file_name.substr(file_name.length()-4,4);\n    if (last!=\".txt\" and last!=\".exe\" and last!=\".dll\") return \"No\";\n    for (int i=0;i<file_name.length();i++)\n    {\n        if (file_name[i]>=48 and file_name[i]<=57) numdigit+=1;\n        if (file_name[i]=='.') numdot+=1;\n    }\n    if (numdigit>3 or numdot!=1) return \"No\";\n    return \"Yes\"; \n}\n"
    ],
    "sample_from": {
      "0": "incoder",
      "1": "incoder",
      "2": "incoder",
      "3": "codex",
      "4": "codex",
      "5": "codex"
    },
    "0": "assert(file_name.size() <= 6);\n\tassert((file_name[0] == '.') || (file_name[0] == '-'));\n\tassert((file_name[1] < 'a') || (file_name[1] > 'z'));\n\tassert((file_name[2] < 'A') || (file_name[2] > 'Z'));\n\tassert(file_name[3] == file_name[4]);\n\treturn file_name;",
    "grade-0": {
      "execution": 0
    },
    "1": "int num_digits = 0;\n    int first_dot_pos = 0;\n    int last_dot_pos = file_name.size() - 1;\n    \n    while(first_dot_pos < last_dot_pos) {\n        if(file_name[first_dot_pos] >= '0' &&  file_name[first_dot_pos] <= '9') {\n            ++num_digits;\n        }\n        else if(file_name[first_dot_pos] == '.') {\n            ++num_digits;\n            ++first_dot_pos;\n        }\n        else {\n            if((first_dot_pos == 0) && (file_name[first_dot_pos] != 'a')) {\n                return \"No\";\n            }\n            else {\n                if((first_dot_pos == 0) && (file_name[first_dot_pos] != 'A')) {\n                    return \"No\";\n                }\n                if((num_digits >= 2) && (file_name[first_dot_pos-1] != 'e') \n                    && (file_name[first_dot_pos-1] != 'E') \n                    && (file_name[first_dot_pos] != 'i') \n                    && (file_name[first_dot_pos] != 'I') \n                    && (file_name[first_dot_pos] != 'o') \n                    && (file_name[first_dot_pos] != 'O') \n                    && (file_name[first_dot_pos] != 'u') \n                    && (file_name[first_dot_pos] != 'U')) {\n                    return \"No\";\n                }\n                else {\n                    return \"Yes\";\n                }\n            }\n        }\n    }",
    "grade-1": {
      "execution": 0
    },
    "2": "if (file_name.size() < 3)\n    return \"No\";\n  if (file_name.at(0) >= '0' && file_name.at(0) <= '9')\n    return \"No\";\n  if (file_name.at(file_name.size() - 1) != '.')\n    return \"No\";\n  if (file_name.at(0) < 'a' || file_name.at(0) > 'z')\n    return \"No\";\n  if (file_name.at(file_name.size() - 2) < 'a' || file_name.at(file_name.size() - 2) > 'z')\n    return \"No\";\n  if (file_name.substr(0, 1) != \".\")\n    return \"No\";\n  if (file_name.find(\".txt\") == std::string::npos)\n    return \"No\";\n  if (file_name.find(\".exe\") == std::string::npos)\n    return \"No\";\n  if (file_name.find(\".dll\") == std::string::npos)\n    return \"No\";\n  return \"Yes\";",
    "grade-2": {
      "execution": 0
    },
    "3": "int i, len = file_name.length(), len1 = 0, len2 = 0, digit_count = 0;\n\tfor (i = 0; i < len; i++) {\n\t\tif (file_name[i] >= '0' && file_name[i] <= '9')\n\t\t\tdigit_count++;\n\t\tif (file_name[i] == '.')\n\t\t\tbreak;\n\t\tlen1++;\n\t}\n\tif (i == len)\n\t\treturn \"No\";\n\tif (digit_count > 3)\n\t\treturn \"No\";\n\tif (len1 == 0)\n\t\treturn \"No\";\n\tif (file_name[0] < 'a' || file_name[0] > 'z')\n\t\tif (file_name[0] < 'A' || file_name[0] > 'Z')\n\t\t\treturn \"No\";\n\tlen2 = len - len1 - 1;\n\tif (len2 != 3)\n\t\treturn \"No\";\n\tstd::string str = file_name.substr(len1 + 1, len2);\n\tif (str != \"txt\" && str != \"exe\" && str != \"dll\")\n\t\treturn \"No\";\n\treturn \"Yes\";",
    "grade-3": {
      "execution": 1
    },
    "4": "int count = 0;\n\tint size = file_name.size();\n\tint pos1, pos2;\n\tfor (int i = 0; i < size; i++) {\n\t\tif (isdigit(file_name[i])) {\n\t\t\tcount++;\n\t\t}\n\t\tif (file_name[i] == '.') {\n\t\t\tpos1 = i;\n\t\t}\n\t}\n\tpos2 = pos1 + 1;\n\tif (count > 3) {\n\t\treturn \"No\";\n\t}\n\tif (pos1 == 0 || pos1 == size - 1) {\n\t\treturn \"No\";\n\t}\n\tstd::string str;\n\tstr = file_name.substr(pos2, size - pos2);\n\tif (str != \"txt\" && str != \"exe\" && str != \"dll\") {\n\t\treturn \"No\";\n\t}\n\treturn \"Yes\";",
    "grade-4": {
      "execution": 0
    },
    "5": "std::cout << file_name << std::endl;\n    if(std::count(file_name.begin(), file_name.end(), '.') != 1){\n        return \"No\";\n    }\n    std::regex reg(\"[0-9]{1,3}\");\n    if(std::regex_search(file_name, reg)){\n        return \"No\";\n    }\n    reg = \"[a-zA-Z]*\\\\.\";\n    if(!std::regex_search(file_name, reg)){\n        return \"No\";\n    }\n    reg = \"\\\\.(txt|exe|dll)\";\n    if(!std::regex_search(file_name, reg)){\n        return \"No\";\n    }\n    return \"Yes\";",
    "grade-5": {
      "execution": 0
    }
  },
  {
    "intent": "#include<assert.h>\n#include<bits/stdc++.h>\n// Given the lengths of the three sides of a triangle. Return True if the three\n// sides form a right-angled triangle, False otherwise.\n// A right-angled triangle is a triangle in which one angle is right angle or \n// 90 degree.\n// Example:\n// right_angle_triangle(3, 4, 5) == True\n// right_angle_triangle(1, 2, 3) == False\nbool right_angle_triangle(long a, long b, long c) {\n",
    "task_id": "157",
    "prompt": "/*\nGiven the lengths of the three sides of a triangle. Return true if the three\nsides form a right-angled triangle, false otherwise.\nA right-angled triangle is a triangle in which one angle is right angle or \n90 degree.\nExample:\nright_angle_triangle(3, 4, 5) == true\nright_angle_triangle(1, 2, 3) == false\n*/\n#include<stdio.h>\n#include<math.h>\nusing namespace std;\nbool right_angle_triangle(float a,float b,float c){\n",
    "simplified_intent": "Given the lengths of the three sides of a triangle. Return True if the three sides form a right-angled triangle, False otherwise. A right-angled triangle is a triangle in which one angle is right angle or 90 degree.",
    "snippet": [
      "    if (abs(a*a+b*b-c*c)<1e-4 or abs(a*a+c*c-b*b)<1e-4 or abs(b*b+c*c-a*a)<1e-4) return true;\n    return false;\n}\n"
    ],
    "sample_from": {
      "0": "incoder",
      "1": "incoder",
      "2": "incoder",
      "3": "codex",
      "4": "codex",
      "5": "codex"
    },
    "0": "if (a == b) \n        return true; // base case\n    if (a == c || b == c) \n        return false; // Base Case\n    long x = (b - a + b - c) / (2 * a);\n    if (a == x)\n        return true;\n    if (b == x)\n        return true;\n    return false;",
    "grade-0": {
      "execution": 0
    },
    "1": "if(a==0 || b==0 || c==0)\n        return false;\n    int ans=1;\n    long long t=(long)sqrt(a*(long) b*(long) c);\n    long long s1=a-t;\n    long long s2=b-t;\n    long long s3=c-t;\n    if(s1*(long)s2<0){\n        if(s1==0 && s2==0)\n            ans=0;\n        else if(s1==0 && s2==c)\n            ans=0;\n        else if(s1==c && s2==0)\n            ans=0;\n        else if(s1==c && s2==c)\n            ans=0;\n        else\n            ans=false;\n    }\n    else \n        ans=false;\n    \n    if(ans==false)\n        return false;\n    else\n        return true;",
    "grade-1": {
      "execution": 0
    },
    "2": "// write your code\n    if((a>b) && (b>c))\n    {\n        if((a>b) && (a>c))\n        {\n            cout<<\"True\";\n        }\n        else\n        {\n            cout<<\"False\";\n        }\n    }\n    else\n    {\n        if((c>b) && (c>a))\n        {\n            cout<<\"True\";\n        }\n        else\n        {\n            cout<<\"False\";\n        }\n    }",
    "grade-2": {
      "execution": 0
    },
    "3": "// if a, b, c are the sides of a right angled triangle then a^2 + b^2 = c^2\n    // a^2 + b^2 = c^2\n    // a^2 + b^2 - c^2 = 0\n    // (a^2 + b^2 - c^2) == 0\n    // a^2 + b^2 - c^2 == 0\n    // return (a^2 + b^2 - c^2) == 0;\n    long max_len = std::max(a, std::max(b, c));\n    long sum_len = a + b + c;\n    // sqrt(sqr) = max_len\n    // sqr = max_len * max_len\n    // sum_len - 2 * max_len = max_len\n    // sum_len - max_len = 2 * max_len\n    // sum_len - max_len == 2 * max_len\n    return (sum_len - max_len) == 2 * max_len;",
    "grade-3": {
      "execution": 0
    },
    "4": "std::vector<long> sides;\n  sides.push_back(a);\n  sides.push_back(b);\n  sides.push_back(c);\n  std::sort(sides.begin(), sides.end());\n  return (sides[0] * sides[0] + sides[1] * sides[1] == sides[2] * sides[2]);",
    "grade-4": {
      "execution": 1
    },
    "5": "long max = std::max(a,std::max(b,c));\n    long min = std::min(a,std::min(b,c));\n    if (max*max == (min*min + (a+b+c-max-min)*(a+b+c-max-min))) {\n        return true;\n    }\n    return false;",
    "grade-5": {
      "execution": 1
    }
  },
  {
    "intent": "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter given list of any python values only for integers\n// >>> filter_integers(['a', 3.14, 5])\n// [5]\n// >>> filter_integers([1, 2, 3, 'abc', {}, []])\n// [1, 2, 3]\nstd::vector<long> filter_integers(std::vector<std::any> values) {\n",
    "task_id": "22",
    "prompt": "/*\nFilter given vector of any python values only for integers\n>>> filter_integers({\"a\", 3.14, 5})\n{5}\n>>> filter_integers({1, 2, 3, \"abc\", {}, {}})\n{1, 2, 3}\n*/\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<boost/any.hpp>\n#include<list>\ntypedef std::list<boost::any> list_any;\nusing namespace std;\nvector<int> filter_integers(list_any values){\n",
    "simplified_intent": "Filter given list of any python values only for integers",
    "snippet": [
      "    list_any::iterator it;\n    boost::any anyone;\n    vector<int> out;\n    for (it=values.begin();it!=values.end();it++)\n    {\n         anyone=*it;\n        if( anyone.type() == typeid(int) )\n           out.push_back(boost::any_cast<int>(*it));\n    }\n    return out;\n}\n"
    ],
    "sample_from": {
      "0": "incoder",
      "1": "incoder",
      "2": "incoder",
      "3": "codex",
      "4": "codex",
      "5": "codex"
    },
    "0": "std::remove_copy_if(values.begin(), values.end(), std::back_inserter(int_values), [](auto value) {\n        return std::holds_alternative<int>(value) && !std::holds_alternative<std::vector<long>>(value);\n    });\n    return int_values;",
    "grade-0": {
      "execution": 0
    },
    "1": "std::vector<long> out;\n  for (auto &value : values) {\n    if (std::holds_alternative<std::int64_t>(value)) {\n      out.push_back(value.as<std::int64_t>());\n    } else if (std::holds_alternative<std::uint64_t>(value)) {\n      out.push_back(value.as<std::uint64_t>());\n    } else {\n      out.push_back(std::holds_alternative<std::int64_t>(value));\n    }\n  }\n  return out;",
    "grade-1": {
      "execution": 0
    },
    "2": "std::vector<long> res;\n  for (auto value : values) {\n    if (std::holds_alternative<long>(value)) {\n      res.push_back(std::get<long>(value));\n    }\n  }\n  return res;",
    "grade-2": {
      "execution": 0
    },
    "3": "//your code here\n    std::vector<long> result;\n    for(auto i:values){\n        try{\n            result.push_back(std::any_cast<long>(i));\n        }\n        catch(std::bad_any_cast){\n            continue;\n        }\n    }\n    return result;",
    "grade-3": {
      "execution": 0
    },
    "4": "std::vector<long> output;\n  for (std::any value : values) {\n    try {\n      output.push_back(std::any_cast<long>(value));\n    } catch (const std::bad_any_cast&) {\n      // std::cout << \"Bad cast, \" << value.type().name() << std::endl;\n    }\n  }\n  return output;",
    "grade-4": {
      "execution": 0
    },
    "5": "std::vector<long> res;\n  for(auto &&elem : values) {\n    try {\n      res.push_back(std::any_cast<long>(elem));\n    }\n    catch(std::bad_any_cast &e) {\n      continue;\n    }\n  }\n  return res;",
    "grade-5": {
      "execution": 0
    }
  },
  {
    "intent": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given 2 words. You need to return True if the second word or any of its rotations is a substring in the first word\n// cycpattern_check(\"abcd\",\"abd\") => False\n// cycpattern_check(\"hello\",\"ell\") => True\n// cycpattern_check(\"whassup\",\"psus\") => False\n// cycpattern_check(\"abab\",\"baa\") => True\n// cycpattern_check(\"efef\",\"eeff\") => False\n// cycpattern_check(\"himenss\",\"simen\") => True\nbool cycpattern_check(std::string a, std::string b) {\n",
    "task_id": "154",
    "prompt": "/*\nYou are given 2 words. You need to return true if the second word or any of its rotations is a substring in the first word\ncycpattern_check(\"abcd\",\"abd\") => false\ncycpattern_check(\"hello\",\"ell\") => true\ncycpattern_check(\"whassup\",\"psus\") => false\ncycpattern_check(\"abab\",\"baa\") => true\ncycpattern_check(\"efef\",\"eeff\") => false\ncycpattern_check(\"himenss\",'simen\") => true\n\n*/\n#include<stdio.h>\n#include<string>\nusing namespace std;\nbool cycpattern_check(string a,string b){\n",
    "simplified_intent": "You are given 2 words. You need to return True if the second word or any of its rotations is a substring in the first word",
    "snippet": [
      "    for (int i=0;i<b.size();i++)\n    {\n        string rotate=b.substr(i)+b.substr(0,i);\n        if (a.find(rotate)!=string::npos) return true;\n    }\n    return false;\n\n}\n"
    ],
    "sample_from": {
      "0": "incoder",
      "1": "incoder",
      "2": "incoder",
      "3": "codex",
      "4": "codex",
      "5": "codex"
    },
    "0": "if(b.length() == 0) return true;\n    if(a.size() < b.length()) return false;\n    if(a.size() > b.length()) return true;\n    if(b.find(a) != std::string::npos) return true;\n    for(size_t i = 0; i < b.length(); i++) {\n        if(b.at(i) == a.at(0)) {\n            if(i < a.length()-1)\n                if(b.at(i+1) + a.at(i+1) != a.at(i)) return false;\n            else if(a.at(1) + b[i] != a.at(i)) return false;\n        }\n        else if(b.at(i) == a.at(b.length()-1)) {\n            if(i < a.length()-1)\n                if(b.at(i-1) + a.at(i-1) != a.at(i)) return false;\n            else if(a.at(b.length()-1) + b[i] != a.at(i)) return false;\n        }\n        else if(b.at(i) == a.at(i-1)) {\n            if(i < a.length()-1)\n                if(b.at(i-2) + a.at(i-2) != a.at(i)) return false;\n            else if(a.at(i-2) + b[i] != a.at(i)) return false;\n        }\n        else if(b.at(i) == a.at(i+1)) {\n            if(i < a.length()-1)\n                if(b.at(i+2) + a.at(i+2) != a.at(i)) return false;\n            else if(a.at(i+2) + b[i] != a.at(i)) return false;\n        }\n    }\n    return true;",
    "grade-0": {
      "execution": 0
    },
    "1": "long long int size = b.size();\n    std::string pattern = b.substr(0,size);\n    std::string check_pattern = a.substr(0,size);\n    for(long long int i=0; i< size; i++)\n    {\n        if(pattern[i] != check_pattern[i])\n        {\n            return false;\n        }\n    }\n    return true;",
    "grade-1": {
      "execution": 0
    },
    "2": "int l = a.length();\n    int m = b.length();\n    for(int i=0;i<l;i++){\n        if(b.find(a.at(i))!=std::string::npos){\n            if(b.find(a.at(i))!=std::string::npos){\n                for(int j=0;j<m;j++){\n                    if(a[j+1]==b.at(i)){\n                        return true;\n                    }\n                }\n            }\n        }\n    }\n    return false;",
    "grade-2": {
      "execution": 0
    },
    "3": "for (int i = 0; i < a.length(); i++) {\n\t\tstd::string c = a.substr(i, a.length() - i) + a.substr(0, i);\n\t\tint l = c.length();\n\t\tint m = b.length();\n\t\tint j = 0;\n\t\twhile (j < l) {\n\t\t\tif (c[j] == b[0]) {\n\t\t\t\tint k = 0;\n\t\t\t\twhile (j < l && k < m && c[j] == b[k]) {\n\t\t\t\t\tj++;\n\t\t\t\t\tk++;\n\t\t\t\t}\n\t\t\t\tif (k == m)\n\t\t\t\t\treturn true;\n\t\t\t}\n\t\t\telse\n\t\t\t\tj++;\n\t\t}\n\t}\n\treturn false;",
    "grade-3": {
      "execution": 0
    },
    "4": "std::cout << \"cycpattern_check('\" << a << \"','\" << b << \"') ==> \";\n\tif (a.length() < b.length()) {\n\t\tstd::cout << \"False\" << std::endl;\n\t\treturn false;\n\t}\n\tif (a.length() == b.length()) {\n\t\tif (a == b) {\n\t\t\tstd::cout << \"True\" << std::endl;\n\t\t\treturn true;\n\t\t}\n\t\tstd::cout << \"False\" << std::endl;\n\t\treturn false;\n\t}\n\t// a.length() > b.length()\n\tstd::string b_copy = b;\n\tbool found = false;\n\tfor (int i = 0; i < b.length(); i++) {\n\t\tb_copy.push_back(b_copy[0]);\n\t\tb_copy.erase(0, 1);\n\t\tif (a.find(b_copy) != std::string::npos) {\n\t\t\tfound = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\tstd::cout << (found ? \"True\" : \"False\") << std::endl;\n\treturn found;",
    "grade-4": {
      "execution": 1
    },
    "5": "// Write your code here\n    if(a.length() < b.length())\n        return false;\n    int len = a.length();\n    string temp = b;\n    while(len--){\n        if(a.find(temp) != string::npos)\n            return true;\n        temp = temp.substr(1,b.length()-1) + temp[0];\n    }\n    return false;",
    "grade-5": {
      "execution": 0
    }
  },
  {
    "intent": "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string, find out how many distinct characters (regardless of case) does it consist of\n// >>> count_distinct_characters('xyzXYZ')\n// 3\n// >>> count_distinct_characters('Jerry')\n// 4\nlong count_distinct_characters(std::string string) {\n",
    "task_id": "16",
    "prompt": "/*\nGiven a string, find out how many distinct characters (regardless of case) does it consist of\n>>> count_distinct_characters(\"xyzXYZ\")\n3\n>>> count_distinct_characters(\"Jerry\")\n4\n*/\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\nint count_distinct_characters(string str){ \n",
    "simplified_intent": "Given a string, find out how many distinct characters (regardless of case) does it consist of",
    "snippet": [
      "    vector<char> distinct={};\n    transform(str.begin(),str.end(),str.begin(),::tolower);\n    for (int i=0;i<str.size();i++)\n    {\n        bool isin=false;\n        for (int j=0;j<distinct.size();j++)\n            if (distinct[j]==str[i])\n                isin=true;\n        if (isin==false) distinct.push_back(str[i]);\n\n    }\n    return distinct.size();\n}\n"
    ],
    "sample_from": {
      "0": "incoder",
      "1": "incoder",
      "2": "incoder",
      "3": "codex",
      "4": "codex",
      "5": "codex"
    },
    "0": "long count = 0;\n    for (auto &ch: string) {\n        ++count;\n    }\n    return count;",
    "grade-0": {
      "execution": 0
    },
    "1": "if (string.size() == 0)\n        return 0;\n\n    long count = 1;\n\n    for (size_t i = 0; i < string.size(); i++) {\n        int index = string[i];\n\n        for(char ch : string){\n            count += ch != index ? 1 : 0;\n        }\n    }\n\n    return count;",
    "grade-1": {
      "execution": 0
    },
    "2": "long count=0;\n    long size = string.size();\n    for (size_t i = 0; i < size; i++) {\n        long countChar = 0;\n        for (size_t j = i; j < size; j++) {\n            if ((string[i]==string[j]) && (string[i] != ' ')) {\n                countChar++;\n            }\n        }\n        count+=countChar;\n    }\n    return count;",
    "grade-2": {
      "execution": 0
    },
    "3": "long result = 0;\n    // count_distinct_characters(string);\n    char *str = (char *)string.c_str();\n    int n = strlen(str);\n    int temp[200] = {0};\n    for(int i = 0; i < n; i++) {\n        char ch = tolower(str[i]);\n        if(temp[ch] == 0) {\n            temp[ch] = 1;\n            result++;\n        }\n    }\n    return result;",
    "grade-3": {
      "execution": 1
    },
    "4": "long total=0;\n  int n=string.length();\n  char c=string[0];\n  for(int i=0;i<n;i++){\n    if(string[i]!=c){\n      total++;\n      c=string[i];\n    }\n  }\n  return total+1;",
    "grade-4": {
      "execution": 0
    },
    "5": "std::set<char> distinct_characters;\n    for (char character : string) {\n        distinct_characters.insert(tolower(character));\n    }\n    return distinct_characters.size();",
    "grade-5": {
      "execution": 1
    }
  },
  {
    "intent": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that accepts two lists of strings and returns the list that has \n// total number of chars in the all strings of the list less than the other list.\n// if the two lists have the same number of chars, return the first list.\n// Examples\n// total_match([], []) \u279e []\n// total_match(['hi', 'admin'], ['hI', 'Hi']) \u279e ['hI', 'Hi']\n// total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n// total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279e ['hI', 'hi', 'hi']\n// total_match(['4'], ['1', '2', '3', '4', '5']) \u279e ['4']\nstd::vector<std::string> total_match(std::vector<std::string> lst1, std::vector<std::string> lst2) {\n",
    "task_id": "74",
    "prompt": "/*\nWrite a function that accepts two vectors of strings and returns the vector that has \ntotal number of chars in the all strings of the vector less than the other vector.\n\nif the two vectors have the same number of chars, return the first vector.\n\nExamples\ntotal_match({}, {}) \u279e {}\ntotal_match({\"hi\", \"admin\"}, {\"hI\", \"Hi\"}) \u279e {\"hI\", \"Hi\"}\ntotal_match({\"hi\", \"admin\"}, {\"hi\", \"hi\", \"admin\", \"project\"}) \u279e {\"hi\", \"admin\"}\ntotal_match({\"hi\", \"admin\"}, {\"hI\", \"hi\", \"hi\"}) \u279e {\"hI\", \"hi\", \"hi\"}\ntotal_match({\"4\"}, {\"1\", \"2\", \"3\", \"4\", \"5\"}) \u279e {\"4\"}\n*/\n#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\nvector<string> total_match(vector<string> lst1,vector<string> lst2){\n",
    "simplified_intent": "Write a function that accepts two lists of strings and returns the list that has total number of chars in the all strings of the list less than the other list. if the two lists have the same number of chars, return the first list.",
    "snippet": [
      "    int num1,num2,i;\n    num1=0;num2=0;\n    for (i=0;i<lst1.size();i++)\n        num1+=lst1[i].length();\n    for (i=0;i<lst2.size();i++)\n        num2+=lst2[i].length();\n    if (num1>num2) return lst2;\n    return lst1;\n}\n"
    ],
    "sample_from": {
      "0": "incoder",
      "1": "incoder",
      "2": "incoder",
      "3": "codex",
      "4": "codex",
      "5": "codex"
    },
    "0": "// Your code goes here\n    \n    return {};",
    "grade-0": {
      "execution": 0
    },
    "1": "std::vector<std::string> res(lst1.size());\n    for(size_t i = 0;i < lst1.size();++i) {\n        for(size_t j = 0;j < lst2.size();++j) {\n            if(lst1[i] < lst2[j]) res[i] = lst1[i];\n        }\n    }\n    return res;",
    "grade-1": {
      "execution": 0
    },
    "2": "std::vector<std::string> res;\n    res.reserve(lst1.size());\n    for (auto &item : lst1)\n        for (auto &s : lst2)\n            if (item.find(s) < item.size())\n                res.push_back(item);\n    return res;",
    "grade-2": {
      "execution": 0
    },
    "3": "int sum = 0;\n\tfor (std::string s : lst1) {\n\t\tsum += s.size();\n\t}\n\tint sum2 = 0;\n\tfor (std::string s : lst2) {\n\t\tsum2 += s.size();\n\t}\n\tif (sum > sum2) {\n\t\treturn lst2;\n\t}\n\telse if (sum < sum2) {\n\t\treturn lst1;\n\t}\n\telse {\n\t\treturn lst1;\n\t}",
    "grade-3": {
      "execution": 1
    },
    "4": "int count1 = 0, count2 = 0;\n\tfor (int i = 0; i < lst1.size(); i++)\n\t\tcount1 += lst1[i].size();\n\tfor (int i = 0; i < lst2.size(); i++)\n\t\tcount2 += lst2[i].size();\n\tif (count1 == count2) return lst1;\n\telse if (count1 < count2) return lst1;\n\telse return lst2;",
    "grade-4": {
      "execution": 1
    },
    "5": "std::string str1, str2;\n\tint len1 = 0, len2 = 0;\n\tfor (int i = 0; i < lst1.size(); i++)\n\t{\n\t\tstr1 += lst1[i];\n\t}\n\tfor (int i = 0; i < lst2.size(); i++)\n\t{\n\t\tstr2 += lst2[i];\n\t}\n\tlen1 = str1.length();\n\tlen2 = str2.length();\n\tif (len1 == len2)\n\t{\n\t\treturn lst1;\n\t}\n\telse if (len1 < len2)\n\t{\n\t\treturn lst1;\n\t}\n\telse\n\t{\n\t\treturn lst2;\n\t}",
    "grade-5": {
      "execution": 1
    }
  },
  {
    "intent": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given two intervals,\n// where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n// The given intervals are closed which means that the interval (start, end)\n// includes both start and end.\n// For each given interval, it is assumed that its start is less or equal its end.\n// Your task is to determine whether the length of intersection of these two \n// intervals is a prime number.\n// Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n// If the length of the intersection is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n// intersection((1, 2), (2, 3)) ==> \"NO\"\n// intersection((-1, 1), (0, 4)) ==> \"NO\"\n// intersection((-3, -1), (-5, 5)) ==> \"YES\"\nstd::string intersection(std::tuple<long, long> interval1, std::tuple<long, long> interval2) {\n",
    "task_id": "127",
    "prompt": "/*\nYou are given two intervals,\nwhere each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\nThe given intervals are closed which means that the interval (start, end)\nincludes both start and end.\nFor each given interval, it is assumed that its start is less or equal its end.\nYour task is to determine whether the length of intersection of these two \nintervals is a prime number.\nExample, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\nwhich its length is 1, which not a prime number.\nIf the length of the intersection is a prime number, return \"YES\",\notherwise, return \"NO\".\nIf the two intervals don't intersect, return \"NO\".\n\n\n{input/output} samples:\nintersection({1, 2}, {2, 3}) ==> \"NO\"\nintersection({-1, 1}, {0, 4}) ==> \"NO\"\nintersection({-3, -1}, {-5, 5}) ==> \"YES\"\n*/\n#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\nstring intersection( vector<int> interval1,vector<int> interval2){\n",
    "simplified_intent": "You are given two intervals, where each interval is a pair of integers. For example, interval = (start, end) = (1, 2). The given intervals are closed which means that the interval (start, end) includes both start and end. For each given interval, it is assumed that its start is less or equal its end. Your task is to determine whether the length of intersection of these two intervals is a prime number. Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3) which its length is 1, which not a prime number. If the length of the intersection is a prime number, return \"YES\", otherwise, return \"NO\". If the two intervals don't intersect, return \"NO\".",
    "snippet": [
      "    int inter1,inter2,l,i;\n    inter1=max(interval1[0],interval2[0]);\n    inter2=min(interval1[1],interval2[1]);\n    l=inter2-inter1;\n    if (l<2) return \"NO\";\n    for (i=2;i*i<=l;i++)\n        if (l%i==0) return \"NO\";\n    return \"YES\";\n}\n"
    ],
    "sample_from": {
      "0": "incoder",
      "1": "incoder",
      "2": "incoder",
      "3": "codex",
      "4": "codex",
      "5": "codex"
    },
    "0": "long start1=std::get<0>(interval1);\n    long end1=std::get<1>(interval1);\n    long start2=std::get<0>(interval2);\n    long end2=std::get<1>(interval2);\n    if (start1<=end2 && start2<=end1) {\n        if(end1-start2 == end2-start1) {\n            return \"\";\n        }\n        else if((end1<start2 && start2<end1) || (end1<start1 && start1<end2)) {\n            return \"NO\";\n        }\n        else if(start1<end1 && start2<end1) {\n            return \"YES\";\n        }\n    }\n    return \"NO\";",
    "grade-0": {
      "execution": 0
    },
    "1": "long long int a1 = std::get<0>(interval1);\n    long long int b1 = std::get<1>(interval1);\n    long long int a2 = std::get<0>(interval2);\n    long long int b2 = std::get<1>(interval2);\n    // std::cout <<\"(a1,b1),(a2,b2): \" << a1 << \", \" << b1 << \", \" << a2 << \", \" << b2 << std::endl;\n    if(a1 > b2 || a2 < b1) return \"NO\";\n    if(a1 == b1 && a2 == b2) return \"YES\";\n    long long int x = a1 > b2 ? a2 : b2;\n    long long int y = a1 > b2 ? b2 : a2;\n    // std::cout <<\"x,y: \" << x << \", \" << y << std::endl;\n    long long int min = a1;\n    long long int max = a2;\n    long long int d = max;\n    // std::cout <<\"min,max: \" << min << \", \" << max << std::endl;\n    while(x < max) {\n        long long int z = y + 1;\n        long long int b = a2;\n        // std::cout <<\"z,b: \" << z << \", \" << b << std::endl;\n        long long int k = b - x;\n        // std::cout <<\"k: \" << k << std::endl;\n        if(k > 0) {\n            if(z <= k) {\n                z = x + 1;\n                b = a2;\n                // std::cout <<\"z,b: \" << z << \", \" << b << std::endl;\n                k = b - x;\n                // std::cout <<\"k: \" << k << std::endl;\n            }\n            k = x - z;\n            // std::cout <<\"k: \" << k << std::endl;\n        }\n        // std::cout <<\"x,z: \" << x << \", \" << z << std::endl;\n        if(b - z > 0) {\n            // std::cout <<\"x,z,b: \" << x << \", \" << z << \", \" << b << std::endl;\n            if(x <= b) {\n                x = z;\n                z = y + 1;\n                b = a2;\n                // std::cout <<\"x,z,b: \" << x << \", \" << z << \", \" << b << std::endl;\n                k = b - x;\n                // std::cout <<\"k: \" << k << std::endl;\n            }\n            k = x - z;\n            // std::cout <<\"k: \" << k << std::endl;\n        }\n        if(x > max) {\n            min = a2;\n            max = a1;\n            d = b1;\n            // std::cout <<\"min,max: \" << min << \", \" << max << std::endl;\n        }\n        min = z;\n        max = b;\n        d = b1;\n        // std::cout <<\"min,max: \" << min << \", \" << max << std::endl;\n    }\n    //",
    "grade-1": {
      "execution": 0
    },
    "2": "auto int_1 = std::get<0>(interval1);\n    auto int_2 = std::get<0>(interval2);\n    if (int_1 < int_2) {\n        auto temp = int_2;\n        int_2 = int_1;\n        int_1 = temp;\n    }\n    if (int_1 > int_2) {\n        auto temp = int_1;\n        int_1 = int_2;\n        int_2 = temp;\n    }\n    auto inter = std::get<1>(interval1) - std::get<1>(interval2);\n    if (inter > 0) {\n        return \"NO\";\n    }\n    auto length = std::get<1>(interval1) + std::get<1>(interval2);\n    if (length == 2) {\n        return \"YES\";\n    }\n    for (long long i = 2; i <= length / 2; i++) {\n        if (std::get<1>(interval1) % i == 0 && std::get<1>(interval2) % i == 0) {\n            return \"NO\";\n        }\n    }\n    return \"YES\";",
    "grade-2": {
      "execution": 0
    },
    "3": "long start, end;\n    bool intersectionExists = false;\n    long start1 = std::get<0>(interval1);\n    long end1 = std::get<1>(interval1);\n    long start2 = std::get<0>(interval2);\n    long end2 = std::get<1>(interval2);\n    if (start1 <= start2) {\n        if (end1 >= start2) {\n            intersectionExists = true;\n            start = start2;\n        }\n    } else {\n        if (end2 >= start1) {\n            intersectionExists = true;\n            start = start1;\n        }\n    }\n    if (intersectionExists) {\n        if (end1 < end2) {\n            end = end1;\n        } else {\n            end = end2;\n        }\n        long length = end - start + 1;\n        if (length <= 0) {\n            return \"NO\";\n        }\n        long sq = sqrt(length);\n        for (long i = 2; i <= sq; i++) {\n            if (length % i == 0) {\n                return \"NO\";\n            }\n        }\n        return \"YES\";\n    }\n    return \"NO\";",
    "grade-3": {
      "execution": 0
    },
    "4": "// Do your magic here\n\n  std::string result;\n  long start, end;\n  start = std::max(std::get<0>(interval1), std::get<0>(interval2));\n  end = std::min(std::get<1>(interval1), std::get<1>(interval2));\n  if (start > end) return \"NO\";\n  if (start == end) return \"YES\";\n  for (int i = 2; i < start; i++) {\n    if (start % i == 0) {\n      result = \"NO\";\n      break;\n    }\n    else {\n      result = \"YES\";\n    }\n  }\n  return result;",
    "grade-4": {
      "execution": 0
    },
    "5": "long start1, end1, start2, end2;\n    std::tie(start1, end1) = interval1;\n    std::tie(start2, end2) = interval2;\n    if (end1 < start2 || end2 < start1) return \"NO\";\n    long l = std::max(start1, start2);\n    long r = std::min(end1, end2);\n    if (l == r) return \"YES\";\n    int len = r - l + 1;\n    for (int i = 2; i < len; i++) {\n        if (len % i == 0) return \"NO\";\n    }\n    return \"YES\";",
    "grade-5": {
      "execution": 0
    }
  },
  {
    "intent": "#include<assert.h>\n#include<bits/stdc++.h>\n// The Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3) -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please write a function to efficiently compute the n-th element of the fib4 number sequence.  Do not use recursion.\n// >>> fib4(5)\n// 4\n// >>> fib4(6)\n// 8\n// >>> fib4(7)\n// 14\nlong fib4(long n) {\n",
    "task_id": "46",
    "prompt": "/*\nThe Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:\nfib4(0) -> 0\nfib4(1) -> 0\nfib4(2) -> 2\nfib4(3) -> 0\nfib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\nPlease write a function to efficiently compute the n-th element of the fib4 number sequence.  Do not use recursion.\n>>> fib4(5)\n4\n>>> fib4(6)\n8\n>>> fib4(7)\n14\n*/\n#include<stdio.h>\nusing namespace std;\nint fib4(int n){\n",
    "simplified_intent": "The Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows: fib4(0) -> 0 fib4(1) -> 0 fib4(2) -> 2 fib4(3) -> 0 fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4). Please write a function to efficiently compute the n-th element of the fib4 number sequence. Do not use recursion.",
    "snippet": [
      "    int f[100];\n    f[0]=0;\n    f[1]=0;\n    f[2]=2;\n    f[3]=0;\n    for (int i=4;i<=n;i++)\n    {\n        f[i]=f[i-1]+f[i-2]+f[i-3]+f[i-4];\n    }\n    return f[n];\n}\n"
    ],
    "sample_from": {
      "0": "incoder",
      "1": "incoder",
      "2": "incoder",
      "3": "codex",
      "4": "codex",
      "5": "codex"
    },
    "0": "if (n == 0) {\n        return 0;\n    } else if (n == 1) {\n        return 1;\n    } else if (n == 2) {\n        return 2;\n    } else if (n == 3) {\n        return 0;\n    } else {\n        return fib4(n - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n - 4);\n    }",
    "grade-0": {
      "execution": 0
    },
    "1": "if (n == 0 || n == 1)\n\t\treturn n;\n\tif (n == 2)\n\t\treturn 2;\n\tif (n == 3) {\n\t\tlong a = fib4(n - 1);\n\t\tlong b = fib4(n - 2);\n\t\tlong c = fib4(n - 3);\n\t\treturn a + b + c;\n\t}\n\tif (n == 4) {\n\t\tlong a = fib4(n - 1);\n\t\tlong b = fib4(n - 2);\n\t\tlong c = fib4(n - 3);\n\t\tlong d = fib4(n - 4);\n\t\treturn a + b + c + d;\n\t}\n\tif (n == 5) {\n\t\tlong a = fib4(n - 1);\n\t\tlong b = fib4(n - 2);\n\t\tlong c = fib4(n - 3);\n\t\tlong d = fib4(n - 4);\n\t\tlong e = fib4(n - 5);\n\t\treturn a + b + c + d + e;\n\t}\n\tif (n == 6) {\n\t\tlong a = fib4(n - 1);\n\t\tlong b = fib4(n - 2);\n\t\tlong c = fib4(n - 3);\n\t\tlong d = fib4(n - 4);\n\t\tlong e = fib4(n - 5);\n\t\tlong f = fib4(n - 6);\n\t\treturn a + b + c + d + e + f;\n\t}",
    "grade-1": {
      "execution": 0
    },
    "2": "if (n == 0 || n == 1) {\n        return n;\n    }\n    long a = fib4(n - 1);\n    long b = fib4(n - 2);\n    long c = fib4(n - 3);\n    long d = fib4(n - 4);\n    return a + b + c + d;",
    "grade-2": {
      "execution": 0
    },
    "3": "long *a = new long[n+1];\n    a[0] = 0;\n    a[1] = 0;\n    a[2] = 2;\n    a[3] = 0;\n    for(int i = 4; i <= n; i++) {\n        a[i] = a[i-1] + a[i-2] + a[i-3] + a[i-4];\n    }\n    return a[n];",
    "grade-3": {
      "execution": 1
    },
    "4": "// YOUR CODE HERE\n    return -1;",
    "grade-4": {
      "execution": 0
    },
    "5": "if (n < 4) {\n        if (n == 2) {\n            return 2;\n        }\n        return 0;\n    }\n    long n0 = 0;\n    long n1 = 0;\n    long n2 = 2;\n    long n3 = 0;\n    long n4 = 0;\n    for (int i = 4; i <= n; i++) {\n        n4 = n3 + n2 + n1 + n0;\n        n0 = n1;\n        n1 = n2;\n        n2 = n3;\n        n3 = n4;\n    }\n    return n4;",
    "grade-5": {
      "execution": 1
    }
  },
  {
    "intent": "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s, count the number of uppercase vowels in even indices.\n// For example:\n// count_upper('aBCdEf') returns 1\n// count_upper('abcdefg') returns 0\n// count_upper('dBBE') returns 0\nlong count_upper(std::string s) {\n",
    "task_id": "98",
    "prompt": "/*\nGiven a string s, count the number of uppercase vowels in even indices.\n\nFor example:\ncount_upper(\"aBCdEf\") returns 1\ncount_upper(\"abcdefg\") returns 0\ncount_upper(\"dBBE\") returns 0\n*/\n#include<stdio.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\nint count_upper(string s){\n",
    "simplified_intent": "Given a string s, count the number of uppercase vowels in even indices.",
    "snippet": [
      "    string uvowel=\"AEIOU\";\n    int count=0;\n    for (int i=0;i*2<s.length();i++)\n    if (find(uvowel.begin(),uvowel.end(),s[i*2])!=uvowel.end())\n        count+=1;\n    return count;\n}\n"
    ],
    "sample_from": {
      "0": "incoder",
      "1": "incoder",
      "2": "incoder",
      "3": "codex",
      "4": "codex",
      "5": "codex"
    },
    "0": "long long ans = 0;\n    for(int i = 0; i < s.size(); i += 2) {\n        if(s[i] == 'A' || s[i] == 'E' || s[i] == 'I' || s[i] == 'O' || s[i] == 'U')\n            ans++;\n    }\n    return ans;",
    "grade-0": {
      "execution": 1
    },
    "1": "long count = 0;\n    for (auto itr = s.cbegin(); itr < s.cend(); itr++) {\n        auto temp = *itr;\n        if (temp == 'A' || temp == 'a' || temp == 'E' || temp == 'e' || temp == 'I' || temp == 'i' || temp == 'O' || temp == 'o' || temp == 'U' || temp == 'u') {\n            count++;\n        }\n    }\n    return count;",
    "grade-1": {
      "execution": 0
    },
    "2": "int n = s.length();\n    long ans = 0;\n    for (int i = 0; i < n; ++i) {\n        if (s[i] >= 'A' && s[i] <= 'Z') {\n            ans += 1;\n        }\n        else if (s[i] >= 'a' && s[i] <= 'z') {\n            ans += 1;\n        }\n        else if (s[i] >= '0' && s[i] <= '9') {\n            ans += 1;\n        }\n    }\n    return ans;",
    "grade-2": {
      "execution": 0
    },
    "3": "long vowelCount = 0;\n    for(long i = 0; i < s.length(); i++){\n        if(i % 2 == 0){\n            if(s[i] == 'A' || s[i] == 'E' || s[i] == 'I' || s[i] == 'O' || s[i] == 'U'){\n                vowelCount++;\n            }\n        }\n    }\n    return vowelCount;",
    "grade-3": {
      "execution": 1
    },
    "4": "long count=0;\n\tfor(long i=0;i<s.length();i++)\n\t{\n\t\tif(i%2==0 && s[i]=='A' || s[i]=='E' || s[i]=='I' || s[i]=='O' || s[i]=='U')\n\t\t{\n\t\t\tcount++;\n\t\t}\n\t}\n\treturn count;",
    "grade-4": {
      "execution": 0
    },
    "5": "long count=0;\n    for(int i=0;i<s.length();i++){\n        if(i%2==0 && isupper(s[i])){\n            count++;\n        }\n    }\n    return count;",
    "grade-5": {
      "execution": 0
    }
  },
  {
    "intent": "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups('( ) (( )) (( )( ))')\n// ['()', '(())', '(()())']\nstd::vector<std::string> separate_paren_groups(std::string paren_string) {\n",
    "task_id": "1",
    "prompt": "/*\nInput to this function is a string containing multiple groups of nested parentheses. Your goal is to\nseparate those group into separate strings and return the vector of those.\nSeparate groups are balanced (each open brace is properly closed) and not nested within each other\nIgnore any spaces in the input string.\n>>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n{\"()\", \"(())\", \"(()())\"}\n*/\n#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\nvector<string> separate_paren_groups(string paren_string){\n",
    "simplified_intent": "Input to this function is a string containing multiple groups of nested parentheses. Your goal is to separate those group into separate strings and return the list of those. Separate groups are balanced (each open brace is properly closed) and not nested within each other Ignore any spaces in the input string.",
    "snippet": [
      "    vector<string> all_parens;\n    string current_paren;\n    int level=0;\n    char chr;\n    int i;\n    for (i=0;i<paren_string.length();i++)\n    {\n        chr=paren_string[i];\n        if (chr=='(')\n        {\n        level+=1;\n        current_paren+=chr;\n        }\n        if (chr==')')\n        {\n            level-=1;\n            current_paren+=chr;\n            if (level==0){\n                all_parens.push_back(current_paren);\n                current_paren=\"\";\n            }\n        }\n    }\n    return all_parens;\n}\n"
    ],
    "sample_from": {
      "0": "incoder",
      "1": "incoder",
      "2": "incoder",
      "3": "codex",
      "4": "codex",
      "5": "codex"
    },
    "0": "// your code goes here\n    return {};",
    "grade-0": {
      "execution": 0
    },
    "1": "std::stack<std::string> paren_strings;\n    for (auto it = paren_string.begin(); it != paren_string.end(); ++it) {\n        if (*it == '(') {\n            paren_strings.push(std::string(1, *it));\n        } else if (*it == ')') {\n            std::string paren_string = paren_strings.top();\n            paren_strings.pop();\n            if (paren_strings.empty() || paren_strings.top() != '(') {\n                paren_strings.push(std::string(1, *it));\n            } else {\n                paren_strings.top() = paren_string + std::string(1, *it);\n            }\n        }\n    }\n\n    std::vector<std::string> paren_string_list;\n    while (!paren_strings.empty()) {\n        paren_string_list.emplace_back(std::move(paren_strings.top()));\n        paren_strings.pop();\n    }\n    return paren_string_list;",
    "grade-1": {
      "execution": 0
    },
    "2": "std::vector<std::string> paren_groups;\n    std::string input_string = paren_string;\n\n    for(int i = 0; i < input_string.length(); i++){\n        if(input_string[i] == ')'){\n            paren_groups.push_back(input_string.substr(0,i));\n        }\n        else if(input_string[i] == '('){\n            paren_groups.push_back(input_string.substr(0,i));\n        }\n    }\n\n    return paren_groups;",
    "grade-2": {
      "execution": 0
    },
    "3": "std::vector<std::string> result;\n  std::string temp = \"\";\n  int brace_counter = 0;\n  for (auto i : paren_string) {\n    if (i == '(') {\n      brace_counter++;\n      temp += i;\n    } else if (i == ')') {\n      brace_counter--;\n      temp += i;\n    }\n    if (brace_counter == 0 && temp != \"\") {\n      result.push_back(temp);\n      temp = \"\";\n    }\n  }\n  return result;",
    "grade-3": {
      "execution": 1
    },
    "4": "// Fill this up\n  std::vector<std::string> ans;\n  int open = 0;\n  std::string res = \"\";\n  for(int i = 0; i < paren_string.size(); i++) {\n    if(paren_string[i] == '(') {\n      open++;\n      res += paren_string[i];\n    }\n    else if(paren_string[i] == ')') {\n      open--;\n      res += paren_string[i];\n    }\n    if(open == 0 && res != \"\") {\n      ans.push_back(res);\n      res = \"\";\n    }\n  }\n  return ans;",
    "grade-4": {
      "execution": 1
    },
    "5": "std::vector<std::string> answer;\n    int len = paren_string.length();\n    int i = 0;\n    int open = 0;\n    int start = 0;\n    while (i < len) {\n        if (paren_string[i] == '(') {\n            open++;\n        } else if (paren_string[i] == ')') {\n            open--;\n        }\n        if (open == 0) {\n            if (i != start) {\n                answer.push_back(paren_string.substr(start, i - start + 1));\n            }\n            start = i + 1;\n        }\n        i++;\n    }\n    return answer;",
    "grade-5": {
      "execution": 0
    }
  },
  {
    "intent": "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer n, return a tuple that has the number of even and odd\n// integer palindromes that fall within the range(1, n), inclusive.\n// Example 1:\n// Input: 3\n// Output: (1, 2)\n// Explanation:\n// Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n// Example 2:\n// Input: 12\n// Output: (4, 6)\n// Explanation:\n// Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n// Note:\n// 1. 1 <= n <= 10^3\n// 2. returned tuple has the number of even and odd integer palindromes respectively.\nstd::tuple<long, long> even_odd_palindrome(long n) {\n",
    "task_id": "107",
    "prompt": "/*\nGiven a positive integer n, return a vector that has the number of even and odd\ninteger palindromes that fall within the range(1, n), inclusive.\n\nExample 1:\n\n    Input: 3\n    Output: (1, 2)\n    Explanation:\n    Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n\nExample 2:\n\n    Input: 12\n    Output: (4, 6)\n    Explanation:\n    Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n\nNote:\n    1. 1 <= n <= 10^3\n    2. returned vector has the number of even and odd integer palindromes respectively.\n*/\n#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\nvector<int> even_odd_palindrome(int n){\n",
    "simplified_intent": "Given a positive integer n, return a tuple that has the number of even and odd integer palindromes that fall within the range(1, n), inclusive. Note: 1. 1 <= n <= 10^3 2. returned tuple has the number of even and odd integer palindromes respectively.",
    "snippet": [
      "    int num1=0,num2=0;\n    for (int i=1;i<=n;i++)\n    {\n        string w=to_string(i);\n        string p(w.rbegin(),w.rend());\n        if (w==p and i%2==1) num1+=1;\n        if (w==p and i%2==0) num2+=1;\n            \n    }\n    return {num2,num1};\n}\n"
    ],
    "sample_from": {
      "0": "incoder",
      "1": "incoder",
      "2": "incoder",
      "3": "codex",
      "4": "codex",
      "5": "codex"
    },
    "0": "long even = 0;\n    long odd = 0;\n    for (long i = 1; i <= n; ++i) {\n        if (i % 2 == 0) {\n            even++;\n            if (even > odd && (even % 2 == 0)) {\n                odd += even;\n                even = 0;\n            }\n        }\n        else if (i % 2 == 1) {\n            odd++;\n            if (even > odd && (odd % 2 == 0)) {\n                odd += even;\n                even = 0;\n            }\n        }\n    }\n    return std::make_tuple(even, odd);",
    "grade-0": {
      "execution": 0
    },
    "1": "long even = 1, odd = 1;\n    long mid = n / 2;\n    while (n > 0) {\n        long left_n = mid;\n        long right_n = n - mid;\n        long left_even = even, right_even = even;\n        long left_odd = odd, right_odd = odd;\n        long left_odd_count = left_odd, right_odd_count = right_odd;\n        while (left_n != 0) {\n            long left_n_copy = left_n;\n            left_n /= 2;\n            long left_n_copy_even = left_even;\n            left_even += left_n_copy % 2 == 0 ? 1 : 0;\n            long left_n_copy_odd = left_odd;\n            left_odd += left_n_copy % 2 != 0 ? 1 : 0;\n            long left_n_copy_odd_count = left_odd_count;\n            left_odd_count += left_n_copy % 2 != 0 ? 1 : 0;\n            long right_n_copy = right_n;\n            right_n /= 2;\n            long right_n_copy_even = right_even;\n            right_even += right_n_copy % 2 == 0 ? 1 : 0;\n            long right_n_copy_odd = right_odd;\n            right_odd += right_n_copy % 2 != 0 ? 1 : 0;\n            long right_n_copy_odd_count = right_odd_count;\n            right_odd_count += right_n_copy % 2 != 0 ? 1 : 0;\n            assert(left_n == 0 && right_n == 0);\n            assert(left_n_copy_even == 0 && left_n_copy_odd != 0);\n            assert(right_n_copy_even == 0 && right_n_copy_odd != 0);\n            assert(left_n_copy_odd_count == left_n_copy_odd);\n            assert(right_n_copy_odd_count == right_n_copy_odd);\n            if (left_n_copy == 0) {\n                left_n = left_n_copy_even;\n                left_even = left_n_copy_even;\n                left_odd = left_n_copy_odd;\n                left_odd_count = left_n_copy_odd;\n            }\n            else {\n                left_n = left_n_copy_odd;\n                left_even = left_n_copy_odd;\n                left_odd = left_n_copy_even;\n                left_odd_count = left_n_copy_even;\n            }\n            if (right_n_copy == 0) {\n                right_n = right_n_copy_even;\n                right_even = right_n_copy_even;\n                right_odd = right_n_copy_odd;\n                right_odd_count = right_n_copy_odd;\n            }\n            else {\n                right_n = right_n_copy_odd;\n                right_even = right_n_copy_odd;\n                right_odd = right_n_copy_even;\n                right_odd_count = right_n_copy_even;",
    "grade-1": {
      "execution": 0
    },
    "2": "auto even = std::count_if(std::begin(even_odd), std::end(even_odd), [&n](long x) { return x <= n; });\n    auto odd = std::count_if(std::begin(even_odd), std::end(even_odd), [&n](long x) { return x > n; });\n    return std::make_tuple(even, odd);",
    "grade-2": {
      "execution": 0
    },
    "3": "long even = 0, odd = 0;\n\tif (n % 2 == 0) {\n\t\teven = n / 2;\n\t\todd = n / 2;\n\t} else {\n\t\teven = n / 2;\n\t\todd = n / 2 + 1;\n\t}\n\treturn std::make_tuple(even, odd);",
    "grade-3": {
      "execution": 0
    },
    "4": "long even_count = 0;\n  long odd_count = 0;\n  int mul_10_power = 0;\n  // we can keep on subtracting powers of 10 from n,\n  // till n is zero.\n  // as every integer of the form 10^k, is a palindrome\n  // and we will add 2 for odd and 1 for even integer palindromes\n  // for every power of 10, we get.\n  while (n > 0) {\n    int last_digit = n % 10;\n    // if we are on power of 10,\n    // then we will add 2 for odd, 1 for even integer palindromes\n    if (mul_10_power == 0) {\n      // if we are on power of 10, and last digit is zero,\n      // we will get just one even integer palindrome.\n      if (last_digit == 0) {\n        ++even_count;\n      } else {\n        // if last digit is not zero, we get 10, 100, 1000, and so on\n        // i.e. one even, and one odd integer palindrome.\n        even_count += 2;\n        odd_count += 2;\n      }\n    } else {\n      // if we are not on power of 10, then we will get 9 for odd,\n      // and 9 for even palindromes for every 1, 10, 100, and so on.\n      odd_count += (9 * mul_10_power);\n      even_count += (9 * mul_10_power);\n    }\n    // update the power of 10,\n    // so that we can update the count of even and odd palindromes,\n    // in the next iteration.\n    mul_10_power++;\n    // we will keep on subtracting powers of 10 from n,\n    // till we get zero.\n    n = n / 10;\n  }\n  // return the count of even and odd palindromes respectively.\n  return std::make_tuple(even_count, odd_count);",
    "grade-4": {
      "execution": 0
    },
    "5": "// Write your code here\n    long odd = 0, even = 0;\n    for(long i = 1; i <= n; i++) {\n        if(i % 10 == 0)\n            continue;\n        long rev = 0, temp = i;\n        while(temp) {\n            rev = rev * 10 + temp % 10;\n            temp /= 10;\n        }\n        if(rev == i) {\n            if(i % 2 == 0)\n                even++;\n            else\n                odd++;\n        }\n    }\n    return std::make_tuple(even, odd);",
    "grade-5": {
      "execution": 1
    }
  },
  {
    "intent": "#include<assert.h>\n#include<bits/stdc++.h>\n// Given two positive integers a and b, return the even digits between a\n// and b, in ascending order.\n// For example:\n// generate_integers(2, 8) => [2, 4, 6, 8]\n// generate_integers(8, 2) => [2, 4, 6, 8]\n// generate_integers(10, 14) => []\nstd::vector<long> generate_integers(long a, long b) {\n",
    "task_id": "163",
    "prompt": "/*\nGiven two positive integers a and b, return the even digits between a\nand b, in ascending order.\n\nFor example:\ngenerate_integers(2, 8) => {2, 4, 6, 8}\ngenerate_integers(8, 2) => {2, 4, 6, 8}\ngenerate_integers(10, 14) => {}\n*/\n#include<stdio.h>\n#include<vector>\nusing namespace std;\nvector<int> generate_integers(int a,int b){\n",
    "simplified_intent": "Given two positive integers a and b, return the even digits between a and b, in ascending order.",
    "snippet": [
      "    int m;\n    if (b<a)\n    {\n        m=a;a=b;b=m;\n    }\n\n    vector<int> out={};\n    for (int i=a;i<=b;i++)\n    if (i<10 and i%2==0) out.push_back(i);\n    return out;\n}\n"
    ],
    "sample_from": {
      "0": "incoder",
      "1": "incoder",
      "2": "incoder",
      "3": "codex",
      "4": "codex",
      "5": "codex"
    },
    "0": "std::vector<long> v;\n    for(long n = a; n < b; n += 2) {\n        v.push_back(n);\n    }\n    return v;",
    "grade-0": {
      "execution": 0
    },
    "1": "long even_integers[b - a + 1] = {};\n    long curr_even = 0;\n    long curr_odd = 0;\n    for (long i = a; i <= b; ++i) {\n        if (i % 2 == 0) {\n            even_integers[curr_even + 1] += 1;\n        } else {\n            even_integers[curr_odd] += 1;\n        }\n        curr_odd += (curr_odd / 2);\n        curr_even += (curr_even / 2);\n    }\n    return even_integers;",
    "grade-1": {
      "execution": 0
    },
    "2": "std::vector<long> result;\n  int a_pos = 0;\n  int b_pos = 0;\n  while (a_pos < a && b_pos < b) {\n    // If a_pos is even, then b_pos must be odd too\n    if (a_pos % 2 == 0) {\n      assert(b_pos % 2 == 1);\n    }\n    if (b_pos % 2 == 0) {\n      assert(a_pos % 2 == 1);\n    }\n    result.push_back(a_pos);\n    a_pos++;\n    b_pos++;\n  }\n  return result;",
    "grade-2": {
      "execution": 0
    },
    "3": "std::vector<long> res;\n    if (a > b) {\n        std::swap(a, b);\n    }\n    for (long x = a; x <= b; x++) {\n        if (x % 2 == 0) {\n            res.push_back(x);\n        }\n    }\n    return res;",
    "grade-3": {
      "execution": 0
    },
    "4": "std::vector<long> result;\n    if (a > b)\n        std::swap(a, b);\n    for (; a <= b; a++)\n        if (a % 2 == 0)\n            result.push_back(a);\n    return result;",
    "grade-4": {
      "execution": 0
    },
    "5": "std::vector<long> ivec;\n    long count = 0;\n    if (a == b) {\n        if (a % 2 == 0) {\n            ivec.push_back(a);\n        }\n    } else if (a < b) {\n        for (long num = a; num <= b; num++) {\n            if (num % 2 == 0) {\n                ivec.push_back(num);\n            }\n        }\n    } else {\n        for (long num = b; num <= a; num++) {\n            if (num % 2 == 0) {\n                ivec.push_back(num);\n            }\n        }\n    }\n    return ivec;",
    "grade-5": {
      "execution": 0
    }
  },
  {
    "intent": "#include<assert.h>\n#include<bits/stdc++.h>\n// Insert a number 'delimeter' between every two consecutive elements of input list `numbers'\n// >>> intersperse([], 4)\n// []\n// >>> intersperse([1, 2, 3], 4)\n// [1, 4, 2, 4, 3]\nstd::vector<long> intersperse(std::vector<long> numbers, long delimeter) {\n",
    "task_id": "5",
    "prompt": "/*\nInsert a number \"delimeter\" between every two consecutive elements of input vector `numbers\"\n>>> intersperse({}, 4)\n{}\n>>> intersperse({1, 2, 3}, 4)\n{1, 4, 2, 4, 3}\n*/\n#include<stdio.h>\n#include<vector>\nusing namespace std;\nvector<int> intersperse(vector<int> numbers, int delimeter){ \n",
    "simplified_intent": "Insert a number 'delimeter' between every two consecutive elements of input list `numbers'",
    "snippet": [
      "    vector<int> out={};\n    if (numbers.size()>0) out.push_back(numbers[0]);\n    for (int i=1;i<numbers.size();i++)\n    {\n        out.push_back(delimeter);\n        out.push_back(numbers[i]);\n\n    }\n    return out;\n}\n"
    ],
    "sample_from": {
      "0": "incoder",
      "1": "incoder",
      "2": "incoder",
      "3": "codex",
      "4": "codex",
      "5": "codex"
    },
    "0": "std::vector<long> result;\n  result.reserve(numbers.size() + 1);\n  for (long i : numbers) result.push_back(i);\n  result.push_back(delimeter);\n  for (size_t i = 1; i < result.size(); i++) result.push_back(delimeter + result[i - 1]);\n  return result;",
    "grade-0": {
      "execution": 0
    },
    "1": "std::vector<long> result;\n    int index = 0;\n    for (int i = 0; i < numbers.size(); i++) {\n        if (index == 0) {\n            result.push_back(numbers[i]);\n        }\n        else {\n            result.push_back(delimeter);\n            result.push_back(numbers[i]);\n        }\n        index = index + 1;\n    }\n    return result;",
    "grade-1": {
      "execution": 1
    },
    "2": "std::size_t last = numbers.size()-1;\n    for (std::size_t i=0; i < numbers.size()-1; ++i) {\n        numbers.insert(numbers.begin()+i+1, delimeter);\n    }\n    return numbers;",
    "grade-2": {
      "execution": 0
    },
    "3": "// Print the value of the parameters (as required by the exercise)\n    printf(\"%s(%s, %ld)\\n\", __func__, listToString(numbers).c_str(), delimeter);\n    // Insert code to solve the exercise here\n    std::vector<long> result;\n    if(numbers.size() > 0)\n    {\n        result.push_back(numbers[0]);\n        for(int i = 1; i < numbers.size(); i++)\n        {\n            result.push_back(delimeter);\n            result.push_back(numbers[i]);\n        }\n    }\n    return result;",
    "grade-3": {
      "execution": 0
    },
    "4": "std::vector<long> interspersed;\n    for (auto it = numbers.begin(); it != numbers.end(); ++it) {\n        interspersed.push_back(*it);\n        if (it != numbers.end() - 1)\n            interspersed.push_back(delimeter);\n    }\n    return interspersed;",
    "grade-4": {
      "execution": 1
    },
    "5": "std::vector<long> result;\n    for (std::vector<long>::size_type i = 0; i < numbers.size(); i++) {\n        result.push_back(numbers[i]);\n        if (i != numbers.size() - 1) {\n            result.push_back(delimeter);\n        }\n    }\n    return result;",
    "grade-5": {
      "execution": 1
    }
  },
  {
    "intent": "#include<assert.h>\n#include<bits/stdc++.h>\n// From a given list of integers, generate a list of rolling maximum element found until given moment\n// in the sequence.\n// >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n// [1, 2, 3, 3, 3, 4, 4]\nstd::vector<long> rolling_max(std::vector<long> numbers) {\n",
    "task_id": "9",
    "prompt": "/*\nFrom a given vector of integers, generate a vector of rolling maximum element found until given moment\nin the sequence.\n>>> rolling_max({1, 2, 3, 2, 3, 4, 2})\n{1, 2, 3, 3, 3, 4, 4}\n*/\n#include<stdio.h>\n#include<vector>\nusing namespace std;\nvector<int> rolling_max(vector<int> numbers){\n",
    "simplified_intent": "From a given list of integers, generate a list of rolling maximum element found until given moment in the sequence.",
    "snippet": [
      "    vector<int> out;\n    int max=0;\n    for (int i=0;i<numbers.size();i++)\n    {\n        if (numbers[i]>max) max=numbers[i];\n        out.push_back(max);\n    }\n    return out;\n}\n"
    ],
    "sample_from": {
      "0": "incoder",
      "1": "incoder",
      "2": "incoder",
      "3": "codex",
      "4": "codex",
      "5": "codex"
    },
    "0": "int n = numbers.size();\n    if (n < 2)\n        return numbers;\n    std::vector<long> max_element(n);\n    long max_value = numbers[0];\n    int i = 0;\n    while (i < n) {\n        if (numbers[i] > max_value) {\n            max_value = numbers[i];\n        }\n        max_element[i] = max_value;\n        i++;\n    }\n    long rolling_max_pos = 0;\n    for (long i = n - 1; i >= 0; i--) {\n        if (max_element[i] > numbers[rolling_max_pos]) {\n            max_element[i] = numbers[rolling_max_pos];\n            rolling_max_pos = i;\n        }\n    }\n    return max_element;",
    "grade-0": {
      "execution": 0
    },
    "1": "int size = numbers.size();\n    std::vector<long> max_number(size);\n    for (long i = 0; i < size; ++i) {\n        int j;\n        for (j = i - 1; j >= 0 ; --j) {\n            if (numbers[j] > numbers[i]) {\n                std::swap(numbers[j], numbers[i]);\n                std::swap(max_number[j], max_number[i]);\n            }\n        }\n    }\n    return max_number;",
    "grade-1": {
      "execution": 0
    },
    "2": "int n_elements = numbers.size();\n    // Rolling max can be calculated as max of last two elements.\n    // Rolling max can be found when there are two elements and they are same.\n    if (n_elements == 2) {\n        return numbers;\n    }\n    // Find rolling max till now\n    std::vector<long> rolling_max;\n    for (int i = 0; i < n_elements; i++) {\n        long curr = numbers[i];\n        for (int j = i; j < n_elements - 1; j++) {\n            if (numbers[j] > curr) {\n                curr = numbers[j];\n            }\n        }\n        rolling_max.push_back(curr);\n    }\n    return rolling_max;",
    "grade-2": {
      "execution": 0
    },
    "3": "std::vector<long> max;\n    long max_num = INT_MIN;\n    for (auto num : numbers) {\n        if (num > max_num)\n            max_num = num;\n        max.push_back(max_num);\n    }\n    return max;",
    "grade-3": {
      "execution": 1
    },
    "4": "assert(numbers.size() > 0);\n    std::vector<long> output;\n    auto it = numbers.begin();\n    output.push_back(*it);\n    for (++it; it != numbers.end(); ++it) {\n        output.push_back(std::max(*it, output.back()));\n    }\n    return output;",
    "grade-4": {
      "execution": 0
    },
    "5": "std::vector<long> result;\n  result.push_back(numbers[0]);\n  for (int i = 1; i < numbers.size(); i++) {\n    result.push_back(std::max(result[i - 1], numbers[i]));\n  }\n  return result;",
    "grade-5": {
      "execution": 0
    }
  },
  {
    "intent": "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n// >>> largest_prime_factor(13195)\n// 29\n// >>> largest_prime_factor(2048)\n// 2\nlong largest_prime_factor(long n) {\n",
    "task_id": "59",
    "prompt": "/*\nReturn the largest prime factor of n. Assume n > 1 and is not a prime.\n>>> largest_prime_factor(13195)\n29\n>>> largest_prime_factor(2048)\n2\n*/\n#include<stdio.h>\nusing namespace std;\nint largest_prime_factor(int n){\n",
    "simplified_intent": "Return the largest prime factor of n. Assume n > 1 and is not a prime.",
    "snippet": [
      "    for (int i=2;i*i<=n;i++)\n    while (n%i==0 and n>i)  n=n/i;\n    return n;\n}\n"
    ],
    "sample_from": {
      "0": "incoder",
      "1": "incoder",
      "2": "incoder",
      "3": "codex",
      "4": "codex",
      "5": "codex"
    },
    "0": "if (n<=1)\n        return n;\n    long maxp = 1;\n    long maxq = n-1;\n    long p = 2, q = 2;\n    long while (p<=q) {\n        if (n%(p+q)==0) {\n            if (p > maxp) {\n                maxp = p;\n            }\n            if (q > maxq) {\n                maxq = q;\n            }\n        }\n        ++p;\n        ++q;\n    }\n    return maxp * maxq;",
    "grade-0": {
      "execution": 0
    },
    "1": "if (n == 1) return 2;\n    long m = n;\n    long lsq = 1;\n    long t = 2;\n    while (m > 1) {\n        lsq = lsq * t + (m & 1);\n        m = m/2;\n        t = t + 1;\n    }\n    return lsq;",
    "grade-1": {
      "execution": 0
    },
    "2": "assert(n > 1);\n\tint count = 0;\n\tlong p = 2;\n\t// while (count <= n / p) {\n\twhile (count <= n / p) {\n\t\tp = p * 2;\n\t\tcount++;\n\t}\n\treturn (p);",
    "grade-2": {
      "execution": 0
    },
    "3": "int res = 2;\n    while (n > res) {\n        if (n % res == 0) {\n            n /= res;\n        } else {\n            res++;\n        }\n    }\n    return res;",
    "grade-3": {
      "execution": 1
    },
    "4": "assert(n > 1);\n    long largest = 0;\n    while (n % 2 == 0) {\n        largest = 2;\n        n /= 2;\n    }\n    long i = 3;\n    while (i <= n) {\n        if (n % i == 0) {\n            largest = i;\n            n /= i;\n        } else {\n            i += 2;\n        }\n    }\n    return largest;",
    "grade-4": {
      "execution": 1
    },
    "5": "long i;\n\tfor (i = 2; i <= n; i++) {\n\t\tif (n % i == 0) {\n\t\t\tlong factor = n / i;\n\t\t\tbool is_prime = true;\n\t\t\tlong j;\n\t\t\tfor (j = 2; j <= factor; j++) {\n\t\t\t\tif (factor % j == 0) {\n\t\t\t\t\tis_prime = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (is_prime) {\n\t\t\t\treturn factor;\n\t\t\t}\n\t\t}\n\t}\n\treturn n;",
    "grade-5": {
      "execution": 0
    }
  },
  {
    "intent": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a list of integers.\n// You need to find the largest prime value and return the sum of its digits.\n// Examples:\n// For lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] the output should be 10\n// For lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] the output should be 25\n// For lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] the output should be 13\n// For lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] the output should be 11\n// For lst = [0,81,12,3,1,21] the output should be 3\n// For lst = [0,8,1,2,1,7] the output should be 7\nlong skjkasdkd(std::vector<long> lst) {\n",
    "task_id": "94",
    "prompt": "/*\nYou are given a vector of integers.\nYou need to find the largest prime value and return the sum of its digits.\n\nExamples:\nFor lst = {0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3} the output should be 10\nFor lst = {1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1} the output should be 25\nFor lst = {1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3} the output should be 13\nFor lst = {0,724,32,71,99,32,6,0,5,91,83,0,5,6} the output should be 11\nFor lst = {0,81,12,3,1,21} the output should be 3\nFor lst = {0,8,1,2,1,7} the output should be 7\n*/\n#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\nint skjkasdkd(vector<int> lst){\n",
    "simplified_intent": "You are given a list of integers. You need to find the largest prime value and return the sum of its digits.",
    "snippet": [
      "    int largest=0;\n    for (int i=0;i<lst.size();i++)\n        if (lst[i]>largest)\n        {\n            bool prime=true;\n            for (int j=2;j*j<=lst[i];j++)\n                if (lst[i]%j==0) prime=false;\n            if (prime) largest=lst[i];\n        }\n    int sum=0;\n    string s;\n    s=to_string(largest);\n    for (int i=0;i<s.length();i++)\n        sum+=s[i]-48;\n    return sum;\n}\n#undef NDEBUG\n#include<assert.h>\n"
    ],
    "sample_from": {
      "0": "incoder",
      "1": "incoder",
      "2": "incoder",
      "3": "codex",
      "4": "codex",
      "5": "codex"
    },
    "0": "long ans = 0;\n    int n = lst.size();\n    for (int i = 0; i < n; i++) {\n        // Check if current element is a prime number\n        if (is_prime(lst[i])) {\n            // If it is prime - add its digits to the sum\n            ans += lst[i];\n        }\n    }\n    return ans;",
    "grade-0": {
      "execution": 0
    },
    "1": "long largest = lst.size();\n    for (long i = 0; i < lst.size(); i++) {\n        if (lst[i] > largest) {\n            largest = lst[i];\n        }\n    }\n    long sum = 0;\n    for (long i = 0; i < lst.size(); i++) {\n        if (lst.at(i) == largest) {\n            sum += lst.at(i);\n        }\n    }\n    return sum;",
    "grade-1": {
      "execution": 0
    },
    "2": "assert(lst.size() <= 100000000000); // check overflow\n  if (lst.size() == 0) return 0;\n  // write your code here\n  std::stack<long> s;\n  for (auto i : lst) {\n    s.push(i);\n    if (s.empty()) continue;\n    long maxPrime = std::numeric_limits<long>::max();\n    long sum = 0;\n    for (long j : s) {\n      if (j > maxPrime) continue;\n      if (j == maxPrime) {\n        for (long k = maxPrime; k > j; k--) {\n          if (j % k == 0) break;\n        }\n        if (k == j) return j;\n      } else if ((int)j % maxPrime == 0) {\n        sum += maxPrime;\n        maxPrime = j;\n      }\n    }\n  }\n  return maxPrime;",
    "grade-2": {
      "execution": 0
    },
    "3": "auto isPrime = [](int n) {\n        bool prime = n != 1;\n        for (int i = 2; i < n; i++) {\n            if (n % i == 0) {\n                prime = false;\n                break;\n            }\n        }\n        return prime;\n    };\n    auto toDigits = [](int n) {\n        std::vector<int> digits;\n        while (n > 0) {\n            digits.push_back(n % 10);\n            n /= 10;\n        }\n        std::reverse(digits.begin(), digits.end());\n        return digits;\n    };\n    auto sum = [](std::vector<int> digits) {\n        int res = 0;\n        for (auto digit : digits) {\n            res += digit;\n        }\n        return res;\n    };\n    int largestPrime = 0;\n    for (auto num : lst) {\n        if (isPrime(num) && num > largestPrime) {\n            largestPrime = num;\n        }\n    }\n    return sum(toDigits(largestPrime));",
    "grade-3": {
      "execution": 1
    },
    "4": "std::vector<long> primes;\n    for(int i = 0; i < lst.size(); i++) {\n        for(int j = 2; j < lst[i]; j++) {\n            if(lst[i] % j == 0) {\n                break;\n            }\n            else if(j == lst[i] - 1) {\n                primes.push_back(lst[i]);\n            }\n        }\n    }\n    long maxprime = *std::max_element(primes.begin(), primes.end());\n    std::cout << maxprime << std::endl;\n    int sum = 0;\n    while(maxprime > 0) {\n        sum += maxprime % 10;\n        maxprime /= 10;\n    }\n    return sum;",
    "grade-4": {
      "execution": 1
    },
    "5": "int len = lst.size();\n    if(len == 0) return 0;\n    long largestPrimeValue = 0;\n    for(int i = 0; i < len; i++){\n        long num = lst[i];\n        bool isPrime = true;\n        if(num == 0) continue;\n        if(num == 1) continue;\n        for(int j = 2; j < num/2; j++){\n            if(num % j == 0){\n                isPrime = false;\n                break;\n            }\n        }\n        if(isPrime && largestPrimeValue < num){\n            largestPrimeValue = num;\n        }\n    }\n    int sum = 0;\n    while(largestPrimeValue > 0){\n        sum += largestPrimeValue % 10;\n        largestPrimeValue /= 10;\n    }\n    return sum;",
    "grade-5": {
      "execution": 1
    }
  },
  {
    "intent": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a list of integers.\n// Write a function next_smallest() that returns the 2nd smallest element of the list.\n// Return None if there is no such element.\n// next_smallest([1, 2, 3, 4, 5]) == 2\n// next_smallest([5, 1, 4, 3, 2]) == 2\n// next_smallest([]) == None\n// next_smallest([1, 1]) == None\nstd::optional<long> next_smallest(std::vector<long> lst) {\n",
    "task_id": "90",
    "prompt": "/*\nYou are given a vector of integers.\nWrite a function next_smallest() that returns the 2nd smallest element of the vector.\nReturn None if there is no such element.\n\nnext_smallest({1, 2, 3, 4, 5}) == 2\nnext_smallest({5, 1, 4, 3, 2}) == 2\nnext_smallest({}) == None\nnext_smallest({1, 1}) == None\n*/\n#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nint next_smallest(vector<int> lst){\n",
    "simplified_intent": "You are given a list of integers. Write a function next_smallest() that returns the 2nd smallest element of the list. Return None if there is no such element.",
    "snippet": [
      "    sort(lst.begin(),lst.end());\n    for (int i=1;i<lst.size();i++)\n        if (lst[i]!=lst[i-1]) return lst[i];\n    return -1;\n}\n"
    ],
    "sample_from": {
      "0": "incoder",
      "1": "incoder",
      "2": "incoder",
      "3": "codex",
      "4": "codex",
      "5": "codex"
    },
    "0": "if (lst.empty())\n    return {};\n  auto it = lst.begin();\n  if (*it < *(it + 1))\n    return *it;\n  it = std::next(it);\n  if (*it < *(it + 1))\n    return *it;\n  return {};",
    "grade-0": {
      "execution": 0
    },
    "1": "if (lst.empty()) {\n        return std::nullopt;\n    }\n    long first_elem = std::min_element(std::begin(lst), std::end(lst));\n    std::advance(std::begin(lst), first_elem);\n    if (first_elem != std::end(lst)) {\n        return std::min_element(std::begin(lst), std::end(lst));\n    }\n    return std::nullopt;",
    "grade-1": {
      "execution": 0
    },
    "2": "long min = 0;\n  long max = lst.size() - 1;\n\n  do {\n    long mid = (min + max) / 2;\n    if (min == max) {\n      return std::nullopt;\n    }\n    if (lst[mid] < lst[min]) {\n      min = mid + 1;\n    } else {\n      max = mid - 1;\n    }\n  } while (min < max);\n\n  return lst[min];",
    "grade-2": {
      "execution": 0
    },
    "3": "if (lst.size() <= 1) {\n    return std::nullopt;\n  }\n  long first = LONG_MAX;\n  long second = LONG_MAX;\n  for (long num : lst) {\n    if (num < first) {\n      second = first;\n      first = num;\n    } else if (num < second && num != first) {\n      second = num;\n    }\n  }\n  if (second == LONG_MAX) {\n    return std::nullopt;\n  }\n  return second;",
    "grade-3": {
      "execution": 0
    },
    "4": "if (lst.size() < 2) {\n        return std::nullopt;\n    }\n    std::vector<long> first_smallest(2);\n    std::vector<long> second_smallest(2);\n    first_smallest[0] = lst[0];\n    first_smallest[1] = lst[1];\n    second_smallest[0] = lst[0];\n    second_smallest[1] = lst[1];\n    if (first_smallest[0] > first_smallest[1]) {\n        std::swap(first_smallest[0], first_smallest[1]);\n    }\n    for (auto it = lst.begin() + 2; it != lst.end(); ++it) {\n        if (*it < first_smallest[0]) {\n            second_smallest[0] = first_smallest[0];\n            second_smallest[1] = first_smallest[1];\n            first_smallest[0] = *it;\n            first_smallest[1] = *it;\n        } else if (*it < first_smallest[1]) {\n            second_smallest[0] = first_smallest[1];\n            second_smallest[1] = *it;\n            first_smallest[1] = *it;\n        } else if (*it < second_smallest[0]) {\n            second_smallest[0] = *it;\n            second_smallest[1] = *it;\n        } else if (*it < second_smallest[1]) {\n            second_smallest[1] = *it;\n        }\n    }\n    if (second_smallest[0] == second_smallest[1]) {\n        return std::nullopt;\n    }\n    return second_smallest[1];",
    "grade-4": {
      "execution": 0
    },
    "5": "if (lst.size() < 2) {\n    return std::nullopt;\n  }\n  long m1 = std::numeric_limits<long>::max();\n  long m2 = std::numeric_limits<long>::max();\n  for (long i = 0; i < lst.size(); i++) {\n    if (lst[i] < m1) {\n      m2 = m1;\n      m1 = lst[i];\n    } else if (lst[i] < m2) {\n      m2 = lst[i];\n    }\n  }\n  if (m2 == std::numeric_limits<long>::max()) {\n    return std::nullopt;\n  }\n  return m2;",
    "grade-5": {
      "execution": 0
    }
  },
  {
    "intent": "#include<assert.h>\n#include<bits/stdc++.h>\n// Change numerical base of input number x to base.\n// return string representation after the conversion.\n// base numbers are less than 10.\n// >>> change_base(8, 3)\n// '22'\n// >>> change_base(8, 2)\n// '1000'\n// >>> change_base(7, 2)\n// '111'\nstd::string change_base(long x, long base) {\n",
    "task_id": "44",
    "prompt": "/*\nChange numerical base of input number x to base.\nreturn string representation after the conversion.\nbase numbers are less than 10.\n>>> change_base(8, 3)\n\"22\"\n>>> change_base(8, 2)\n\"1000\"\n>>> change_base(7, 2)\n\"111\"\n*/\n#include<stdio.h>\n#include<string>\nusing namespace std;\nstring change_base(int x,int base){\n",
    "simplified_intent": "Change numerical base of input number x to base. return string representation after the conversion. base numbers are less than 10.",
    "snippet": [
      "    string out=\"\";\n    while (x>0)\n    {\n        out=to_string(x%base)+out;\n        x=x/base;\n    }\n    return out;\n}\n"
    ],
    "sample_from": {
      "0": "incoder",
      "1": "incoder",
      "2": "incoder",
      "3": "codex",
      "4": "codex",
      "5": "codex"
    },
    "0": "std::bitset<sizeof(long)> bs(x);\n    std::string s = bs_to_string(bs);\n    int len = s.length();\n    if (len > base) {\n        std::cout << x << std::endl;\n        return \"error\";\n    }\n    // change from base to base number.\n    long *lptr = reinterpret_cast<long*>(&s[0]);\n    while (lptr != reinterpret_cast<long*>(&s[len - 1])) {\n        *lptr = base;\n        lptr++;\n    }\n    return s;",
    "grade-0": {
      "execution": 0
    },
    "1": "long long n = (long long) base;\n    if (x <= 10) {\n        return std::to_string(x);\n    }\n    if (x < 0) {\n        n = -n;\n        x *= -1;\n    }\n    std::string res;\n    while (x > 0) {\n        res = std::to_string((n % base) + 1) + res;\n        x /= base;\n    }\n    return res;",
    "grade-1": {
      "execution": 0
    },
    "2": "if (base < 10 && base > 1)\n    return \"Invalid base (must be less than 10)\";\n  long d = 1;\n  while (x > base)\n    x /= base;\n  while (x >= base)\n    d *= base;\n  return std::to_string(x + d) + std::string((base - x) % base, '0');",
    "grade-2": {
      "execution": 0
    },
    "3": "std::string x_base_n = \"\";\n  long quotient = x;\n  long remainder = 0;\n  while (quotient != 0) {\n    remainder = quotient % base;\n    quotient = quotient / base;\n    x_base_n += std::to_string(remainder);\n  }\n  std::reverse(x_base_n.begin(), x_base_n.end());\n  return x_base_n;",
    "grade-3": {
      "execution": 1
    },
    "4": "char n_to_c[10] = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9'};\n    long r;\n    std::string s;\n    while (x > 0) {\n        r = x % base;\n        s = n_to_c[r] + s;\n        x = x / base;\n    }\n    return s;",
    "grade-4": {
      "execution": 1
    },
    "5": "std::string result;\n    assert(base < 10);\n    while (x > 0) {\n        long digit = x % base;\n        x /= base;\n        result += std::to_string(digit);\n    }\n    std::reverse(result.begin(), result.end());\n    return result;",
    "grade-5": {
      "execution": 1
    }
  },
  {
    "intent": "#include<assert.h>\n#include<bits/stdc++.h>\n// You'll be given a string of words, and your task is to count the number\n// of boredoms. A boredom is a sentence that starts with the word \"I\".\n// Sentences are delimited by '.', '?' or '!'.\n// For example:\n// >>> is_bored(\"Hello world\")\n// 0\n// >>> is_bored(\"The sky is blue. The sun is shining. I love this weather\")\n// 1\nlong is_bored(std::string S) {\n",
    "task_id": "91",
    "prompt": "/*\nYou'll be given a string of words, and your task is to count the number\nof boredoms. A boredom is a sentence that starts with the word \"I\".\nSentences are delimited by '.', '?' or '!'.\n\nFor example:\n>>> is_bored(\"Hello world\")\n0\n>>> is_bored(\"The sky is blue. The sun is shining. I love this weather\")\n1\n*/\n#include<stdio.h>\n#include<string>\nusing namespace std;\nint is_bored(string S){\n",
    "simplified_intent": "You'll be given a string of words, and your task is to count the number of boredoms. A boredom is a sentence that starts with the word \"I\". Sentences are delimited by '.', '?' or '!'.",
    "snippet": [
      "    bool isstart=true;\n    bool isi=false;\n    int sum=0;\n    for (int i=0;i<S.length();i++)\n    {\n        if (S[i]==' ' and isi) {isi=false; sum+=1;}\n        if (S[i]=='I' and isstart) {isi=true;  }\n        else isi=false;   \n        if (S[i]!=' ') { isstart=false;}\n        if (S[i]=='.' or S[i]=='?' or S[i]=='!') isstart=true;\n    }\n    return sum;\n}\n"
    ],
    "sample_from": {
      "0": "incoder",
      "1": "incoder",
      "2": "incoder",
      "3": "codex",
      "4": "codex",
      "5": "codex"
    },
    "0": "int count = 0;\n    for(int i=0;i<S.size();i++){\n        if(S[i]=='I' || S[i]=='i' || S[i]=='.'){\n            count++;\n        }\n    }\n    return count;",
    "grade-0": {
      "execution": 0
    },
    "1": "int count = 0;\n  std::istringstream iss(S);\n  std::string token;\n  while (std::getline(iss, token, '.') && std::getline(iss, token, '?') && std::getline(iss, token, '!')) {\n    if (token == \"I\")\n      count++;\n  }\n  return count;",
    "grade-1": {
      "execution": 0
    },
    "2": "int b=0;\n  for (int i = 0; i < S.length(); i++) {\n    if (S[i] == '.' || S[i] == '?' || S[i] == '!') {\n      b++;\n    }\n  }\n  return b;",
    "grade-2": {
      "execution": 0
    },
    "3": "int count = 0;\n    std::vector<std::string> words;\n    std::istringstream buf(S);\n    for(std::string word; buf >> word; )\n        words.push_back(word);\n    for(int i = 0; i < words.size(); i++) {\n        if(words[i] == \"I\") {\n            count++;\n        }\n    }\n    return count;",
    "grade-3": {
      "execution": 0
    },
    "4": "long count{0};\n    std::string str=\"\";\n    std::stringstream ss(S);\n    while(ss>>str){\n        if(str==\"I\") count++;\n    }\n    return count;",
    "grade-4": {
      "execution": 0
    },
    "5": "std::stringstream ss(S);\n  std::string item;\n  long line_count = 0;\n  while (std::getline(ss, item, '.')) {\n    if (item.size() > 1 && item[0] == 'I') {\n      line_count++;\n    }\n  }\n  return line_count;",
    "grade-5": {
      "execution": 0
    }
  },
  {
    "intent": "#include<assert.h>\n#include<bits/stdc++.h>\n// Implement a function that takes an non-negative integer and returns an array of the first n\n// integers that are prime numbers and less than n.\n// for example:\n// count_up_to(5) => [2,3]\n// count_up_to(11) => [2,3,5,7]\n// count_up_to(0) => []\n// count_up_to(20) => [2,3,5,7,11,13,17,19]\n// count_up_to(1) => []\n// count_up_to(18) => [2,3,5,7,11,13,17]\nstd::vector<long> count_up_to(long n) {\n",
    "task_id": "96",
    "prompt": "/*\nImplement a function that takes an non-negative integer and returns a vector of the first n\nintegers that are prime numbers and less than n.\nfor example:\ncount_up_to(5) => {2,3}\ncount_up_to(11) => {2,3,5,7}\ncount_up_to(0) => {}\ncount_up_to(20) => {2,3,5,7,11,13,17,19}\ncount_up_to(1) => {}\ncount_up_to(18) => {2,3,5,7,11,13,17}\n*/\n#include<stdio.h>\n#include<vector>\nusing namespace std;\nvector<int> count_up_to(int n){\n",
    "simplified_intent": "Implement a function that takes an non-negative integer and returns an array of the first n integers that are prime numbers and less than n. for",
    "snippet": [
      "    vector<int> out={};\n    int i,j;\n    for (i=2;i<n;i++)\n        if (out.size()==0) {out.push_back(i);}\n        else\n        {\n            bool isp=true;\n            for (j=0;out[j]*out[j]<=i;j++)\n                if (i%out[j]==0) isp=false;\n            if (isp) out.push_back(i);\n        }\n    return out;\n}\n"
    ],
    "sample_from": {
      "0": "incoder",
      "1": "incoder",
      "2": "incoder",
      "3": "codex",
      "4": "codex",
      "5": "codex"
    },
    "0": "if (n == 0 || n == 1)\n        return {};\n    std::vector<long> arr;\n    long curr = 2;\n    while (curr < n) {\n        long flag = 1;\n        for (int i = 3; i <= sqrt(curr); ++i) {\n            if (curr%i == 0) {\n                flag = 0;\n                break;\n            }\n        }\n        if (flag == 1)\n            arr.push_back(curr);\n        curr++;\n    }\n    return arr;",
    "grade-0": {
      "execution": 0
    },
    "1": "std::vector<long> arr;\n    long i = 2;\n    bool flag = true;\n    for (; i < n; i++) {\n        if (flag) {\n            if (n % i == 0) {\n                arr.push_back(i);\n                flag = false;\n            }\n        } else {\n            if (n % i == 0) {\n                arr.push_back(i);\n            }\n        }\n    }\n    return arr;",
    "grade-1": {
      "execution": 0
    },
    "2": "std::vector<long> res;\n  long res = 0;\n  long prime = 1;\n  while (true) {\n    if (n >= prime) {\n      if (n == prime) {\n        res.push_back(prime);\n      } else {\n        res.push_back(n);\n      }\n      break;\n    }\n    for (long i = 2; i <= (n / prime); i++) {\n      if (n % i == 0) {\n        prime = i;\n        break;\n      }\n    }\n  }\n  return res;",
    "grade-2": {
      "execution": 0
    },
    "3": "std::vector<long> result;\n  if (n <= 1) {\n    return result;\n  }\n  // TODO\n  long i = 2;\n  while (i < n) {\n    long j = 2;\n    while (j <= i) {\n      if (i % j == 0) {\n        break;\n      }\n      j++;\n    }\n    if (j == i) {\n      result.push_back(i);\n    }\n    i++;\n  }\n  return result;",
    "grade-3": {
      "execution": 1
    },
    "4": "// check to see if n is greater than 0\n  if (n <= 0) {\n    return {};\n  }\n\n  // declare a vector to return\n  std::vector<long> return_vector;\n\n  // loop from 2 - n\n  for (int i = 2; i < n; i++) {\n    // loop from 2 - i\n    bool is_prime = true;\n    for (int j = 2; j < i; j++) {\n      // check if i mod j is equal to 0\n      if (i % j == 0) {\n        is_prime = false;\n        break;\n      }\n    }\n    if (is_prime) {\n      return_vector.push_back(i);\n    }\n  }\n\n  return return_vector;",
    "grade-4": {
      "execution": 1
    },
    "5": "// Write your code here.",
    "grade-5": {
      "execution": 0
    }
  },
  {
    "intent": "#include<assert.h>\n#include<bits/stdc++.h>\n// Return list with elements incremented by 1.\n// >>> incr_list([1, 2, 3])\n// [2, 3, 4]\n// >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n// [6, 4, 6, 3, 4, 4, 10, 1, 124]\nstd::vector<long> incr_list(std::vector<long> l) {\n",
    "task_id": "42",
    "prompt": "/*\nReturn vector with elements incremented by 1.\n>>> incr_vector({1, 2, 3})\n{2, 3, 4}\n>>> incr_vector({5, 3, 5, 2, 3, 3, 9, 0, 123})\n{6, 4, 6, 3, 4, 4, 10, 1, 124}\n*/\n#include<stdio.h>\n#include<vector>\nusing namespace std;\nvector<int> incr_list(vector<int> l){\n",
    "simplified_intent": "Return list with elements incremented by 1.",
    "snippet": [
      "    for (int i=0;i<l.size();i++)\n        l[i]+=1;\n    return l;\n}\n"
    ],
    "sample_from": {
      "0": "incoder",
      "1": "incoder",
      "2": "incoder",
      "3": "codex",
      "4": "codex",
      "5": "codex"
    },
    "0": "assert(l.size() > 0);\n    std::vector<long> res(l.size());\n    for (size_t i = 0; i < res.size(); ++i) {\n        res[i] = l[i] + 1;\n    }\n    return res;",
    "grade-0": {
      "execution": 0
    },
    "1": "std::vector<long> res(l.size());\n    for (int i = 0; i < l.size(); i++) {\n        res[i] = l[i] + 1;\n    }\n    return res;",
    "grade-1": {
      "execution": 1
    },
    "2": "int n = l.size();\n  assert(n > 0);\n  std::vector<long> res = std::vector<long> (n, 0);\n  for (int i = 0; i < n; i++) {\n    int val = l[i];\n    res[i] += val;\n  }\n  return res;",
    "grade-2": {
      "execution": 0
    },
    "3": "std::vector<long> inc_list;\n    for(auto& i : l)\n        inc_list.push_back(i+1);\n    return inc_list;",
    "grade-3": {
      "execution": 1
    },
    "4": "std::vector<long> ret;\n\tfor (long i = 0; i < l.size(); i++) {\n\t\tret.push_back(l[i] + 1);\n\t}\n\treturn ret;",
    "grade-4": {
      "execution": 1
    },
    "5": "std::vector<long> temp;\n    for(int i=0;i<l.size();i++){\n        temp.push_back(l[i]+1);\n    }\n    return temp;",
    "grade-5": {
      "execution": 1
    }
  },
  {
    "intent": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function count_nums which takes an array of integers and returns\n// the number of elements which has a sum of digits > 0.\n// If a number is negative, then its first signed digit will be negative:\n// e.g. -123 has signed digits -1, 2, and 3.\n// >>> count_nums([]) == 0\n// >>> count_nums([-1, 11, -11]) == 1\n// >>> count_nums([1, 1, 2]) == 3\nlong count_nums(std::vector<long> arr) {\n",
    "task_id": "108",
    "prompt": "/*\nWrite a function count_nums which takes a vector of integers and returns\nthe number of elements which has a sum of digits > 0.\nIf a number is negative, then its first signed digit will be negative:\ne.g. -123 has signed digits -1, 2, and 3.\n>>> count_nums({}) == 0\n>>> count_nums({-1, 11, -11}) == 1\n>>> count_nums({1, 1, 2}) == 3\n*/\n#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\nint count_nums(vector<int> n){\n",
    "simplified_intent": "Write a function count_nums which takes an array of integers and returns the number of elements which has a sum of digits > 0. If a number is negative, then its first signed digit will be negative: e.g. -123 has signed digits -1, 2, and 3.",
    "snippet": [
      "    int num=0;\n    for (int i=0;i<n.size();i++)\n        if (n[i]>0) num+=1;\n        else\n        {\n            int sum=0;\n            int w;\n            w=abs(n[i]);\n            while (w>=10)\n            {\n                sum+=w%10;\n                w=w/10;\n            }\n            sum-=w;\n            if (sum>0) num+=1;\n        }\n    return num;\n}\n"
    ],
    "sample_from": {
      "0": "incoder",
      "1": "incoder",
      "2": "incoder",
      "3": "codex",
      "4": "codex",
      "5": "codex"
    },
    "0": "long sum = 0;\n    for (auto num: arr) sum += num;\n    if (sum < 0) sum += std::abs(sum);\n    return sum;",
    "grade-0": {
      "execution": 0
    },
    "1": "int sum = 0;\n    for (int i = 0; i < arr.size(); i++) {\n        sum += arr[i];\n    }\n    return sum;",
    "grade-1": {
      "execution": 0
    },
    "2": "// Write your code here\n  long ans = 0, sum = 0;\n  for (int i = 0; i < arr.size(); i++) {\n    sum += arr[i];\n    if (sum > 0) ans++;\n  }\n  return ans;",
    "grade-2": {
      "execution": 0
    },
    "3": "int count = 0;\n    for (auto i = arr.begin(); i != arr.end(); i++) {\n        int sum = 0;\n        if (*i < 0) {\n            sum += (*i) % 10;\n            int a = (*i) / 10;\n            sum += (a) % 10;\n            int b = a / 10;\n            sum += (b) % 10;\n        } else {\n            while (*i != 0) {\n                sum += (*i) % 10;\n                *i = *i / 10;\n            }\n        }\n        if (sum > 0)\n            count++;\n    }\n    return count;",
    "grade-3": {
      "execution": 0
    },
    "4": "if (arr.size() == 0) return 0;\n    int total = 0;\n    for (int i = 0; i < arr.size(); i++) {\n        int temp = 0;\n        int num = arr[i];\n        while (num != 0) {\n            temp += num % 10;\n            num /= 10;\n        }\n        if (temp > 0) {\n            total++;\n        }\n    }\n    return total;",
    "grade-4": {
      "execution": 0
    },
    "5": "long count = 0;\n    for (int i = 0; i < arr.size(); i++) {\n        long sum = 0;\n        long current = arr[i];\n        // Count the number of digits in the current integer\n        while (current != 0) {\n            sum += current % 10;\n            current /= 10;\n        }\n        if (sum > 0) {\n            count++;\n        }\n    }\n    return count;",
    "grade-5": {
      "execution": 0
    }
  },
  {
    "intent": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function which sorts the given list of integers\n// in ascending order according to the sum of their digits.\n// Note: if there are several items with similar sum of their digits,\n// order them based on their index in original list.\n// For example:\n// >>> order_by_points([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n// >>> order_by_points([]) == []\nstd::vector<long> order_by_points(std::vector<long> nums) {\n",
    "task_id": "145",
    "prompt": "/*\nWrite a function which sorts the given vector of integers\nin ascending order according to the sum of their digits.\nNote: if there are several items with similar sum of their digits,\norder them based on their index in original vector.\n\nFor example:\n>>> order_by_points({1, 11, -1, -11, -12}) == {-1, -11, 1, -12, 11}\n>>> order_by_points({}) == {}\n*/\n#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\nvector<int> order_by_points(vector<int> nums){\n",
    "simplified_intent": "Write a function which sorts the given list of integers in ascending order according to the sum of their digits. Note: if there are several items with similar sum of their digits, order them based on their index in original list.",
    "snippet": [
      "    vector<int> sumdigit={};\n    for (int i=0;i<nums.size();i++)\n    {\n        string w=to_string(abs(nums[i]));\n        int sum=0;\n        for (int j=1;j<w.length();j++)\n            sum+=w[j]-48;\n        if (nums[i]>0) sum+=w[0]-48;\n        else sum-=w[0]-48;\n        sumdigit.push_back(sum);\n    }\n    int m;\n    for (int i=0;i<nums.size();i++)\n    for (int j=1;j<nums.size();j++)\n    if (sumdigit[j-1]>sumdigit[j])\n    {\n        m=sumdigit[j];sumdigit[j]=sumdigit[j-1];sumdigit[j-1]=m;\n        m=nums[j];nums[j]=nums[j-1];nums[j-1]=m;\n    }\n     \n    return nums;\n}\n"
    ],
    "sample_from": {
      "0": "incoder",
      "1": "incoder",
      "2": "incoder",
      "3": "codex",
      "4": "codex",
      "5": "codex"
    },
    "0": "std::sort(nums.begin(), nums.end(), [&](long a, long b) -> bool {\n        return a<b;\n    });\n    return nums;",
    "grade-0": {
      "execution": 0
    },
    "1": "// Write your code here.\n    long sum = 0;\n    for (long num : nums) {\n        sum += num;\n    }\n    std::vector<long> res(nums.size());\n    for (long i = 0; i < nums.size(); i++) {\n        int j;\n        for (j = 0; j < nums.size(); j++) {\n            if (i == j)\n                continue;\n            if (nums[i] + nums[j] == sum)\n                res[i] = nums[j];\n        }\n    }\n    return res;",
    "grade-1": {
      "execution": 0
    },
    "2": "std::vector<long> ans;\n    int largestSumSoFar = INT_MIN;\n    int currentSum = INT_MIN;\n    for (int num : nums) {\n        currentSum += num;\n        largestSumSoFar = max(largestSumSoFar, currentSum);\n        ans.push_back(currentSum);\n    }\n    std::sort(ans.begin(), ans.end(), [](long a, long b) -> bool {\n        return a < b;\n    });\n    return ans;",
    "grade-2": {
      "execution": 0
    },
    "3": "std::vector<long> result, values;\n    int sum{}, temp{};\n    for(int i=0; i<nums.size(); i++){\n        temp = nums[i];\n        sum = 0;\n        if(temp<0){\n            temp = temp*(-1);\n        }\n        while(temp!=0){\n            sum = sum + temp%10;\n            temp = temp/10;\n        }\n        values.push_back(sum);\n    }\n    std::vector<long> original = nums;\n    int minIndex{}, minValue{};\n    while(values.size()!=0){\n        minValue = values[0];\n        minIndex = 0;\n        for(int i=0; i<values.size(); i++){\n            if(values[i]<minValue){\n                minValue = values[i];\n                minIndex = i;\n            }\n        }\n        for(int i=0; i<original.size(); i++){\n            if(original[i]==nums[minIndex]){\n                result.push_back(original[i]);\n                original.erase(original.begin()+i);\n                nums.erase(nums.begin()+minIndex);\n                values.erase(values.begin()+minIndex);\n                break;\n            }\n        }\n    }\n    return result;",
    "grade-3": {
      "execution": 0
    },
    "4": "std::vector<long> sumVector;\n\tstd::vector<long> originalVector;\n\tfor (auto &i : nums) {\n\t\tint sum = 0;\n\t\tfor (int j = i; j != 0; j /= 10) {\n\t\t\tsum += j % 10;\n\t\t}\n\t\tsumVector.push_back(sum);\n\t\toriginalVector.push_back(i);\n\t}\n\tsort(sumVector.begin(), sumVector.end());\n\tfor (int i = 0; i < sumVector.size(); i++) {\n\t\tfor (int j = 0; j < originalVector.size(); j++) {\n\t\t\tint sum = 0;\n\t\t\tfor (int k = originalVector[j]; k != 0; k /= 10) {\n\t\t\t\tsum += k % 10;\n\t\t\t}\n\t\t\tif (sum == sumVector[i]) {\n\t\t\t\tnums[i] = originalVector[j];\n\t\t\t\toriginalVector[j] = 10000000;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn nums;",
    "grade-4": {
      "execution": 0
    },
    "5": "std::vector<long> result;\n    int i = 0;\n    while (i < nums.size()) {\n        // std::cout << \"i = \" << i << std::endl;\n        int min = INT_MAX;\n        int min_index = 0;\n        int j = 0;\n        while (j < nums.size()) {\n            if (nums[j] < min && nums[j] > 0) {\n                min = nums[j];\n                min_index = j;\n            }\n            j++;\n        }\n        result.push_back(min);\n        nums[min_index] = INT_MAX;\n        i++;\n    }\n    return result;",
    "grade-5": {
      "execution": 0
    }
  },
  {
    "intent": "#include<assert.h>\n#include<bits/stdc++.h>\n// \"\n// This function will take a list of integers. For all entries in the list, the function shall square the integer entry if its index is a \n// multiple of 3 and will cube the integer entry if its index is a multiple of 4 and not a multiple of 3. The function will not \n// change the entries in the list whose indexes are not a multiple of 3 or 4. The function shall then return the sum of all entries. \n// Examples:\n// For lst = [1,2,3] the output should be 6\n// For lst = []  the output should be 0\n// For lst = [-1,-5,2,-1,-5]  the output should be -126\nlong sum_squares(std::vector<long> lst) {\n",
    "task_id": "142",
    "prompt": "/*\n\"\nThis function will take a vector of integers. For all entries in the vector, the function shall square the integer entry if its index is a \nmultiple of 3 and will cube the integer entry if its index is a multiple of 4 and not a multiple of 3. The function will not \nchange the entries in the vector whose indexes are not a multiple of 3 or 4. The function shall then return the sum of all entries. \n\nExamples:\nFor lst = {1,2,3} the output should be 6\nFor lst = {}  the output should be 0\nFor lst = {-1,-5,2,-1,-5}  the output should be -126\n*/\n#include<stdio.h>\n#include<vector>\nusing namespace std;\nint sum_squares(vector<int> lst){\n",
    "simplified_intent": "\" This function will take a list of integers. For all entries in the list, the function shall square the integer entry if its index is a multiple of 3 and will cube the integer entry if its index is a multiple of 4 and not a multiple of 3. The function will not change the entries in the list whose indexes are not a multiple of 3 or 4. The function shall then return the sum of all entries.",
    "snippet": [
      "    int sum=0;\n    for (int i=0;i<lst.size();i++)\n        if (i%3==0) sum+=lst[i]*lst[i];\n        else if (i%4==0) sum+=lst[i]*lst[i]*lst[i];\n        else sum+=lst[i];\n    return sum;\n}\n"
    ],
    "sample_from": {
      "0": "incoder",
      "1": "incoder",
      "2": "incoder",
      "3": "codex",
      "4": "codex",
      "5": "codex"
    },
    "0": "// \"\n    // Write a program that can add up all the squares of even indexes of lst, all the squares of odd indexes of lst, and \n    // the sum of all the entries of lst, ignoring the entries whose indexes are not a multiple of 3 or 4\n    // \"\n    // \"\n    // \"\n    // \"\n    // \"\n    // \"\n    // \"\n    // \"\n    // \"\n    long long ans = 0, odd=0, even=0;\n    for(int i=0;i<lst.size();i++) {\n        if(i % 2 == 0) {\n            even+=lst[i];\n        } else {\n            odd+=lst[i];\n        }\n    }\n    ans = even+odd;\n    return ans;",
    "grade-0": {
      "execution": 0
    },
    "1": "// your code goes here\n    long sum = 0;\n    long a = lst[0];\n    for (long i = 0; i < lst.size(); i++) {\n        if(i % 3 == 0) {\n            long b = a*a;\n            sum += b;\n            \n        }\n        else if(i % 4 == 0 || i % 4 == 2) {\n            long b = a*a;\n            sum += b;\n            \n        }\n        else {\n            sum += lst[i];\n            \n        }\n        a = lst[i];\n    }\n    return sum;",
    "grade-1": {
      "execution": 0
    },
    "2": "// Your code goes here\n    long sum = 0;\n    assert(lst.size() == 0 || lst.size() == 1 || lst.size() % 3 == 0);\n    if (lst.size() == 0) {\n        return 0;\n    }\n    for (int i = 0; i < (lst.size() - 1); i += 3) {\n        sum += lst[i] * lst[i];\n    }\n    for (int i = 0; i < (lst.size() - 1); i += 4) {\n        sum += lst[i] * lst[i];\n    }\n    for (int i = (lst.size() - 2); i >= 0; i -= 3) {\n        sum += lst[i] * lst[i];\n    }\n    for (int i = (lst.size() - 2); i >= 0; i -= 4) {\n        sum += lst[i] * lst[i];\n    }\n    return sum;",
    "grade-2": {
      "execution": 0
    },
    "3": "long long sum = 0;\n\tfor (int i = 0; i < lst.size(); i++) {\n\t\tif (i % 3 == 0) {\n\t\t\tsum += lst[i] * lst[i];\n\t\t}\n\t\telse if (i % 4 == 0 && i % 3 != 0) {\n\t\t\tsum += lst[i] * lst[i] * lst[i];\n\t\t}\n\t\telse {\n\t\t\tsum += lst[i];\n\t\t}\n\t}\n\treturn sum;",
    "grade-3": {
      "execution": 1
    },
    "4": "long sum = 0;\n    for (int i = 0; i < lst.size(); i++) {\n        if ((i+1) % 3 == 0 && (i+1) % 4 != 0) {\n            lst[i] = lst[i] * lst[i];\n        }\n        else if ((i+1) % 4 == 0) {\n            lst[i] = lst[i] * lst[i] * lst[i];\n        }\n        sum += lst[i];\n    }\n    return sum;",
    "grade-4": {
      "execution": 0
    },
    "5": "long sum=0;\n    for(long i=0;i<lst.size();i++){\n        if(i%3==0)\n            sum+=lst[i]*lst[i];\n        else if(i%4==0 && i%3!=0)\n            sum+=lst[i]*lst[i]*lst[i];\n        else\n            sum+=lst[i];\n    }\n    return sum;",
    "grade-5": {
      "execution": 1
    }
  },
  {
    "intent": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that takes a message, and encodes in such a \n// way that it swaps case of all letters, replaces all vowels in \n// the message with the letter that appears 2 places ahead of that \n// vowel in the english alphabet. \n// Assume only letters. \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n// 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n",
    "task_id": "93",
    "prompt": "/*\nWrite a function that takes a message, and encodes in such a \nway that it swaps case of all letters, replaces all vowels in \nthe message with the letter that appears 2 places ahead of that \nvowel in the english alphabet. \nAssume only letters. \n\nExamples:\n>>> encode('test\")\n\"TGST\"\n>>> encode(\"This is a message\")\n'tHKS KS C MGSSCGG\"\n*/\n#include<stdio.h>\n#include<string>\n#include<algorithm>\nusing namespace std;\nstring encode(string message){\n",
    "simplified_intent": "Write a function that takes a message, and encodes in such a way that it swaps case of all letters, replaces all vowels in the message with the letter that appears 2 places ahead of that vowel in the english alphabet. Assume only letters.",
    "snippet": [
      "    string vowels=\"aeiouAEIOU\";\n    string out=\"\";\n    for (int i=0;i<message.length();i++)\n    {\n        char w=message[i];\n        if (w>=97 and w<=122){w=w-32;}\n        else if (w>=65 and w<=90) w=w+32;\n        if (find(vowels.begin(),vowels.end(),w)!=vowels.end()) w=w+2;\n        out=out+w;\n    }\n    return out;\n}\n"
    ],
    "sample_from": {
      "0": "incoder",
      "1": "incoder",
      "2": "incoder",
      "3": "codex",
      "4": "codex",
      "5": "codex"
    },
    "0": "std::string ans;\n    for (std::string::size_type i = 0; i < message.length(); i++){\n        std::swap(message[i], message[i-(int)message.length()]);\n        char firstVowel = message[i];\n        std::swap(message[i], message[i-(message.length()-2)]);\n        char secondVowel = message[i];\n        std::string currentChar = message[i];\n        char firstLetter = currentChar[0];\n        char secondLetter = currentChar[1];\n        if (firstVowel == 'a' || firstVowel == 'e' || firstVowel == 'i' || firstVowel == 'o' || firstVowel == 'u'){\n            firstLetter = 'A';\n        }\n        if (secondVowel == 'a' || secondVowel == 'e' || secondVowel == 'i' || secondVowel == 'o' || secondVowel == 'u'){\n            secondLetter = 'A';\n        }\n        ans += firstLetter + secondLetter + currentChar;\n    }\n    return ans;",
    "grade-0": {
      "execution": 0
    },
    "1": "assert(!message.empty());\n    std::string encodedMessage = \"\";\n    int vowels[26] = {\n        0, 1 , 2, 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27\n    };\n    for(int i = 0; i < message.length(); i++) {\n        char currentChar = message[i];\n        if(currentChar >= 'a' && currentChar <= 'z') {\n            char nextChar = message[i+1];\n            char prevChar = message[i-1];\n            char nextVowel = vowels[(nextChar - 'a' + 1)];\n            char prevVowel = vowels[(prevChar - 'a' + 1)];\n            if(nextVowel == prevVowel) {\n                encodedMessage += currentChar;\n            } else {\n                encodedMessage += currentChar + prevVowel;\n            }\n        } else {\n            encodedMessage += currentChar;\n        }\n    }\n    return encodedMessage;",
    "grade-1": {
      "execution": 0
    },
    "2": "// Complete this function. \n    // Assume only letters. \n    // Write your logic here",
    "grade-2": {
      "execution": 0
    },
    "3": "char vowels[5] = {'a', 'e', 'i', 'o', 'u'};\n\tchar replaced_vowels[5] = {'c', 'g', 'k', 'o', 's'};\n\tstd::string result = \"\";\n\tfor (int i = 0; i < message.length(); i++) {\n\t\tchar ch = message[i];\n\t\tif (ch >= 'a' && ch <= 'z') {\n\t\t\tch = ch - 'a' + 'A';\n\t\t} else if (ch >= 'A' && ch <= 'Z') {\n\t\t\tch = ch - 'A' + 'a';\n\t\t}\n\t\tfor (int j = 0; j < 5; j++) {\n\t\t\tif (ch == vowels[j]) {\n\t\t\t\tch = replaced_vowels[j];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tresult += ch;\n\t}\n\treturn result;",
    "grade-3": {
      "execution": 0
    },
    "4": "std::string encoded_message;\n    std::vector<char>::iterator iterator;\n    std::vector<char> char_vector(message.begin(), message.end());\n    std::unordered_set<char> vowels {'a', 'e', 'i', 'o', 'u'};\n    for (iterator = char_vector.begin(); iterator != char_vector.end(); iterator++) {\n        if (isupper(*iterator)) {\n            if (vowels.find(tolower(*iterator)) != vowels.end()) {\n                if (*iterator == 'U')\n                    *iterator = 'A';\n                else\n                    *iterator = *iterator + 2;\n            }\n            *iterator = tolower(*iterator);\n        }\n        else if (islower(*iterator)) {\n            if (vowels.find(*iterator) != vowels.end()) {\n                if (*iterator == 'u')\n                    *iterator = 'a';\n                else\n                    *iterator = *iterator + 2;\n            }\n            *iterator = toupper(*iterator);\n        }\n        encoded_message += *iterator;\n    }\n    return encoded_message;",
    "grade-4": {
      "execution": 0
    },
    "5": "std::string encoded = \"\";\n  int size = message.size();\n  std::string vowels = \"AEIOUaeiou\";\n  for (int i = 0; i < size; i++) {\n    if (vowels.find(message[i]) == std::string::npos) {\n      if (message[i] >= 'a' && message[i] <= 'z') {\n        encoded += (char)((int)message[i] - 32);\n      } else {\n        encoded += (char)((int)message[i] + 32);\n      }\n    } else {\n      switch (message[i]) {\n        case 'A':\n        case 'a': encoded += 'C'; break;\n        case 'E':\n        case 'e': encoded += 'G'; break;\n        case 'I':\n        case 'i': encoded += 'K'; break;\n        case 'O':\n        case 'o': encoded += 'M'; break;\n        case 'U':\n        case 'u': encoded += 'Q'; break;\n      }\n    }\n  }\n  return encoded;",
    "grade-5": {
      "execution": 0
    }
  },
  {
    "intent": "#include<assert.h>\n#include<bits/stdc++.h>\n// Imagine a road that's a perfectly straight infinitely long line.\n// n cars are driving left to right;  simultaneously, a different set of n cars\n// are driving right to left.   The two sets of cars start out being very far from\n// each other.  All cars move in the same speed.  Two cars are said to collide\n// when a car that's moving left to right hits a car that's moving right to left.\n// However, the cars are infinitely sturdy and strong; as a result, they continue moving\n// in their trajectory as if they did not collide.\n// This function outputs the number of such collisions.\nlong car_race_collision(long n) {\n",
    "task_id": "41",
    "prompt": "/*\nImagine a road that's a perfectly straight infinitely long line.\nn cars are driving left to right;  simultaneously, a different set of n cars\nare driving right to left.   The two sets of cars start out being very far from\neach other.  All cars move in the same speed.  Two cars are said to collide\nwhen a car that's moving left to right hits a car that's moving right to left.\nHowever, the cars are infinitely sturdy and strong; as a result, they continue moving\nin their trajectory as if they did not collide.\n\nThis function outputs the number of such collisions.\n*/\n#include<stdio.h>\nusing namespace std;\nint car_race_collision(int n){\n",
    "simplified_intent": "Imagine a road that's a perfectly straight infinitely long line. n cars are driving left to right; simultaneously, a different set of n cars are driving right to left. The two sets of cars start out being very far from each other. All cars move in the same speed. Two cars are said to collide when a car that's moving left to right hits a car that's moving right to left. However, the cars are infinitely sturdy and strong; as a result, they continue moving in their trajectory as if they did not collide. This function outputs the number of such collisions.",
    "snippet": [
      "    return n*n;\n}\n"
    ],
    "sample_from": {
      "0": "incoder",
      "1": "incoder",
      "2": "incoder",
      "3": "codex",
      "4": "codex",
      "5": "codex"
    },
    "0": "long t[n], m[n], i, j, k;\n    long ans = 0;\n    t[0] = t[1] = n + 1;\n    m[0] = m[1] = 1;\n    for (i = 2; i <= n; i++) {\n        for (j = 0; j <= i - 1; j++) {\n            for (k = i + 1; k < n; k++) {\n                if (t[j] > t[k]) {\n                    t[j] = t[k];\n                    m[j] = m[k];\n                }\n            }\n        }\n    }\n    for (i = 1; i <= n; i++) {\n        if (m[i] < m[i + 1])\n            ans = ans + i;\n    }\n    return ans;",
    "grade-0": {
      "execution": 0
    },
    "1": "long long sum = 0;\n    for (long long i = 0; i < n; i++) {\n        long long j;\n        for (j = 0; j < n; j++) {\n            if (i != j) {\n                if (i != j && j % 2 == 0 && j / 2 == i) {\n                    sum++;\n                }\n            }\n        }\n    }\n    return sum;",
    "grade-1": {
      "execution": 0
    },
    "2": "long long int sum = 0;\n    for (long long int i = 0; i < n; i++) {\n        // A car is located at position (0,0).\n        // The goal is to move from left to right as quickly as possible.\n        // A car can only move right if it has moved exactly 'x' positions\n        // before it moved left.\n        long long int x = 0, y = 0;\n        long long int xp = 0, yp = 0;\n\n        // Pick a random car to move.\n        x = rand() % n;\n\n        // Move until we're not moving any more.\n        while (true) {\n            // Determine how far we can move right from this car.\n            xp = x + rand() % n;\n\n            // Move one more car.\n            y = rand() % n;\n\n            // If we've gone through this car, we can stop.\n            if (x == xp)\n                break;\n\n            // If we've gone through any cars before this one, we have a collision.\n            while (x < xp) {\n                sum++;\n                // Swap the two cars.\n                x = xp;\n                xp = y;\n                y = yp;\n                yp = x;\n            }\n        }\n    }\n    return sum;",
    "grade-2": {
      "execution": 0
    },
    "3": "// when we look from left to right, a car going from left to right appears to be\n    // increasing in position, and a car going from right to left appears to be decreasing\n    // in position.\n    // we use a hash table to store the range of positions occcupied by each left-to-right\n    // car.\n    // for each right-to-left car, we check whether it collides with any of the left-to-right\n    // cars in the hash table.  if the right-to-left car collides with a left-to-right car,\n    // we increment the number of collisions by 1.\n    // we iterate this entire process until all right-to-left cars are checked.\n    // in order to check how far we have to go to check all right-to-left cars,\n    // we keep track of the right-most left-to-right car and the left-most right-to-left car.\n    std::map<long, long> map;\n    long l = 0;\n    long r = 0;\n    long collisions = 0;\n    for (long i = 0; i < n; i++) {\n        l += i + 1;\n        r += n - i;\n        for (long j = 0; j < n; j++) {\n            // if there are collisions between the ith car going left to right and the jth car\n            // going right to left, then we increment the number of collisions by 1.\n            if (map.find(j + 1) != map.end() && map[j + 1] >= r - j) {\n                collisions++;\n            }\n        }\n        // add the range of positions occupied by the ith car going left to right.\n        map[i + 1] = l + i;\n    }\n    return collisions;",
    "grade-3": {
      "execution": 0
    },
    "4": "if (n < 1) {\n        return 0;\n    }\n    if (n == 1) {\n        return 1;\n    }\n    long long num = 1;\n    long long den = 1;\n    long long frac = 0;\n    for (long i = n - 1; i > 0; i--) {\n        num *= (i + n);\n        den *= i;\n        while ((num % 2 == 0) && (den % 2 == 0)) {\n            num /= 2;\n            den /= 2;\n        }\n        frac += (num / den);\n    }\n    return frac;",
    "grade-4": {
      "execution": 0
    },
    "5": "long cars[n];\n\tlong cars1[n];\n\tfor (long i = 0; i < n; i++) {\n\t\tcars[i] = i;\n\t\tcars1[i] = n - i - 1;\n\t}\n\tlong result = 0;\n\tlong i = 0;\n\tlong j = 0;\n\twhile (i < n && j < n) {\n\t\tif (cars[i] < cars1[j]) {\n\t\t\ti++;\n\t\t}\n\t\telse if (cars[i] > cars1[j]) {\n\t\t\tj++;\n\t\t}\n\t\telse {\n\t\t\tresult++;\n\t\t\ti++;\n\t\t\tj++;\n\t\t}\n\t}\n\treturn result;",
    "grade-5": {
      "execution": 0
    }
  },
  {
    "intent": "#include<assert.h>\n#include<bits/stdc++.h>\n// Checks if given string is a palindrome\n// >>> is_palindrome('')\n// True\n// >>> is_palindrome('aba')\n// True\n// >>> is_palindrome('aaaaa')\n// True\n// >>> is_palindrome('zbcd')\n// False\nbool is_palindrome(std::string text) {\n",
    "task_id": "48",
    "prompt": "/*\nChecks if given string is a palindrome\n>>> is_palindrome(\"\")\ntrue\n>>> is_palindrome(\"aba\")\ntrue\n>>> is_palindrome(\"aaaaa\")\ntrue\n>>> is_palindrome(\"zbcd\")\nfalse\n*/\n#include<stdio.h>\n#include<string>\nusing namespace std;\nbool is_palindrome(string text){\n",
    "simplified_intent": "Checks if given string is a palindrome",
    "snippet": [
      "    string pr(text.rbegin(),text.rend());\n    return pr==text;\n}\n"
    ],
    "sample_from": {
      "0": "incoder",
      "1": "incoder",
      "2": "incoder",
      "3": "codex",
      "4": "codex",
      "5": "codex"
    },
    "0": "int len = text.size();\n    int i;\n    for (i = 0; i < len/2; i++) {\n        if (text[i] != text[(len - 1) - i]) {\n            return false;\n        }\n    }\n    return true;",
    "grade-0": {
      "execution": 1
    },
    "1": "if(text.size() < 2) return true;\n    int length = text.length();\n    for (int i = 0; i < length / 2; i++) {\n        if(text[i] != text[length - 1 - i]) {\n            return false;\n        }\n    }\n    return true;",
    "grade-1": {
      "execution": 1
    },
    "2": "if (text.size() < 2)\n        return true;\n    for (int i = 0; i <= text.size() / 2; i++) {\n        if (text[i] != text[text.size() - 1 - i])\n            return false;\n    }\n    return true;",
    "grade-2": {
      "execution": 1
    },
    "3": "int n = text.length();\n    std::string text2 = text;\n    std::reverse(text2.begin(), text2.end());\n    // Check if text is palindrome\n    if (text == text2) {\n        return true;\n    }\n    else {\n        return false;\n    }",
    "grade-3": {
      "execution": 1
    },
    "4": "return false;",
    "grade-4": {
      "execution": 0
    },
    "5": "auto size = text.size();\n    if (size <= 1) {\n        return true;\n    }\n    if (text[0] != text[size - 1]) {\n        return false;\n    }\n    return is_palindrome(text.substr(1, size - 2));",
    "grade-5": {
      "execution": 1
    }
  },
  {
    "intent": "#include<assert.h>\n#include<bits/stdc++.h>\n// It is the last week of the semester and the teacher has to give the grades\n// to students. The teacher has been making her own algorithm for grading.\n// The only problem is, she has lost the code she used for grading.\n// She has given you a list of GPAs for some students and you have to write \n// a function that can output a list of letter grades using the following table:\n// GPA       |    Letter grade\n// 4.0                A+\n// > 3.7                A \n// > 3.3                A- \n// > 3.0                B+\n// > 2.7                B \n// > 2.3                B-\n// > 2.0                C+\n// > 1.7                C\n// > 1.3                C-\n// > 1.0                D+ \n// > 0.7                D \n// > 0.0                D-\n// 0.0                E\n// Example:\n// grade_equation([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']\nstd::vector<std::string> numerical_letter_grade(std::vector<float> grades) {\n",
    "task_id": "81",
    "prompt": "/*\nIt is the last week of the semester and the teacher has to give the grades\nto students. The teacher has been making her own algorithm for grading.\nThe only problem is, she has lost the code she used for grading.\nShe has given you a vector of GPAs for some students and you have to write \na function that can output a vector of letter grades using the following table:\n         GPA       |    Letter grade\n          4.0                A+\n        > 3.7                A \n        > 3.3                A- \n        > 3.0                B+\n        > 2.7                B \n        > 2.3                B-\n        > 2.0                C+\n        > 1.7                C\n        > 1.3                C-\n        > 1.0                D+ \n        > 0.7                D \n        > 0.0                D-\n          0.0                E\n\n\nExample:\ngrade_equation({4.0, 3, 1.7, 2, 3.5}) ==> {\"A+\", \"B\", \"C-\", \"C\", \"A-\"}\n*/\n#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\nvector<string> numerical_letter_grade(vector<float> grades){\n",
    "simplified_intent": "It is the last week of the semester and the teacher has to give the grades to students. The teacher has been making her own algorithm for grading. The only problem is, she has lost the code she used for grading. She has given you a list of GPAs for some students and you have to write a function that can output a list of letter grades using the following table: GPA | Letter grade 4.0 A+ > 3.7 A > 3.3 A- > 3.0 B+ > 2.7 B > 2.3 B- > 2.0 C+ > 1.7 C > 1.3 C- > 1.0 D+ > 0.7 D > 0.0 D- 0.0 E",
    "snippet": [
      "    vector<string> out={};\n    for (int i=0;i<grades.size();i++)\n    {\n        if (grades[i]>=3.9999) out.push_back(\"A+\");\n        if (grades[i]>3.7001 and grades[i]<3.9999) out.push_back(\"A\");\n        if (grades[i]>3.3001 and grades[i]<=3.7001) out.push_back(\"A-\");\n        if (grades[i]>3.0001 and grades[i]<=3.3001) out.push_back(\"B+\");\n        if (grades[i]>2.7001 and grades[i]<=3.0001) out.push_back(\"B\");\n        if (grades[i]>2.3001 and grades[i]<=2.7001) out.push_back(\"B-\");\n        if (grades[i]>2.0001 and grades[i]<=2.3001) out.push_back(\"C+\");\n        if (grades[i]>1.7001 and grades[i]<=2.0001) out.push_back(\"C\");\n        if (grades[i]>1.3001 and grades[i]<=1.7001) out.push_back(\"C-\");\n        if (grades[i]>1.0001 and grades[i]<=1.3001) out.push_back(\"D+\");\n        if (grades[i]>0.7001 and grades[i]<=1.0001) out.push_back(\"D\");\n        if (grades[i]>0.0001 and grades[i]<=0.7001) out.push_back(\"D-\");\n        if (grades[i]<=0.0001) out.push_back(\"E\");\n    }\n    return out;\n}\n"
    ],
    "sample_from": {
      "0": "incoder",
      "1": "incoder",
      "2": "incoder",
      "3": "codex",
      "4": "codex",
      "5": "codex"
    },
    "0": "// Your code goes here\n    std::vector<std::string> letter_grades;\n    assert(grades.size() <= 15);\n    int length = grades.size();\n    for (int i = 0; i < length; i++) {\n        if (grades[i] < 3.0) {\n            letter_grades.push_back(\"A\");\n        } else if (grades[i] <= 3.3) {\n            letter_grades.push_back(\"A-\");\n        } else if (grades[i] <= 3.7) {\n            letter_grades.push_back(\"A+\");\n        } else if (grades[i] <= 4.0) {\n            letter_grades.push_back(\"B+\");\n        } else if (grades[i] <= 4.3) {\n            letter_grades.push_back(\"B\");\n        } else if (grades[i] <= 4.7) {\n            letter_grades.push_back(\"B\");\n        } else if (grades[i] <= 5.0) {\n            letter_grades.push_back(\"B-\");\n        } else if (grades[i] <= 5.3) {\n            letter_grades.push_back(\"B+\");\n        } else if (grades[i] <= 5.7) {\n            letter_grades.push_back(\"C+\");\n        } else if (grades[i] <= 6.0) {\n            letter_grades.push_back(\"C\");\n        } else if (grades[i] <= 6.3) {\n            letter_grades.push_back(\"C-\");\n        } else if (grades[i] <= 6.7) {\n            letter_grades.push_back(\"C+\");\n        } else if (grades[i] <= 7.0) {\n            letter_grades.push_back(\"D+\");\n        } else if (grades[i] <= 7.3) {\n            letter_grades.push_back(\"D\");\n        } else if (grades[i] <= 7.7) {\n            letter_grades.push_back(\"D\");\n        } else if (grades[i] <= 8.0) {\n            letter_grades.push_back(\"D-\");\n        } else if (grades[i] <= 8.3) {\n            letter_grades.push_back(\"D-\");\n        } else if (grades[i] <= 8.7) {\n            letter_grades.push_back(\"D\");\n        } else if (grades[i] <= 9.0) {\n            letter_grades.push_back(\"E\");\n        } else {\n            letter_grades.push_back(\"D\");\n        }\n    }\n    return letter_grades;",
    "grade-0": {
      "execution": 0
    },
    "1": "std::vector<std::string> grades_vector;\n    float min_grade = *std::min_element(grades.begin(), grades.end()); // Find minimum value\n    float max_grade = *std::max_element(grades.begin(), grades.end()); // Find maximum value\n    float avg_grade = std::accumulate(grades.begin(), grades.end(), 0) / grades.size(); // Calculate average of all grades\n    float sum_of_grades = 0.0; // Summation of the grades\n    for (float grade : grades) {\n        sum_of_grades += grade; // Add all grades to sum variable\n    }\n    std::vector<std::string> grades_letter_grade;\n    grades_letter_grade.push_back(\"E\"); // Add E grade to the grades_letter_grade\n    if (sum_of_grades == 0.0) { // If all grades are 0.0\n        grades_letter_grade.push_back(\"F\"); // Add F grade to the grades_letter_grade\n    }\n    else { // If not all grades are 0.0\n        // For each grade\n        for (float grade : grades) {\n            float percentage = (grade - min_grade) / (max_grade - min_grade); // Calculate percentage\n            // If percentage is less than 0\n            if (percentage < 0) {\n                percentage = -0.0;\n            }\n            std::string letter_grade;\n            if (percentage >= 0.0) { // If percentage is greater than or equal to 0\n                if (percentage < 0.35) { // If percentage is less than 0.35\n                    letter_grade = \"A-\";\n                }\n                else if (percentage < 0.70) { // If percentage is less than 0.70\n                    letter_grade = \"B-\";\n                }\n                else if (percentage < 0.85) { // If percentage is less than 0.85\n                    letter_grade = \"B-\";\n                }\n                else if (percentage < 1.05) { // If percentage is less than 1.05\n                    letter_grade = \"B+\";\n                }\n                else if (percentage < 1.35) { // If percentage is less than 1.35\n                    letter_grade = \"C+\";\n                }\n                else if (percentage < 1.65) { // If percentage is less than 1.65\n                    letter_grade = \"C-\";\n                }\n                else if (percentage < 1.85) { // If percentage is less than 1.85\n                    letter_grade = \"C+\";\n                }\n                else if (percentage < 2.05) { // If percentage is less than 2.05\n                    letter_grade = \"D+\";\n                }\n                else if (percentage < 2.35) { // If percentage is less than 2.35\n                    letter_grade = \"D-\";\n                }\n                else if (percentage < 2.65) { // If percentage is less than 2.65\n                    letter_grade = \"D+\";\n                }\n                else if (percentage < 2.85) { // If percentage is less than 2.85",
    "grade-1": {
      "execution": 0
    },
    "2": "std::vector<std::string> letter_grades;\n    for (float grade: grades) {\n        auto it = std::find_if(grades.begin(), grades.end(), [&grade]\n            { return grade > 3.0; }); // Find first grade > 3.0\n        auto next_ = std::next(it);\n        if (next_ - it == 2) {\n            letter_grades.push_back(\"A+\");\n        } else if (next_ - it == 1) {\n            letter_grades.push_back(\"A\");\n        } else if (next_ - it == 0) {\n            letter_grades.push_back(\"B\");\n        } else if (next_ - it == -2) {\n            letter_grades.push_back(\"B\");\n        } else if (next_ - it == -3) {\n            letter_grades.push_back(\"B-\");\n        } else if (next_ - it == -4) {\n            letter_grades.push_back(\"B-\");\n        } else if (next_ - it == -5) {\n            letter_grades.push_back(\"B-\");\n        } else if (next_ - it == -6) {\n            letter_grades.push_back(\"B-\");\n        } else if (next_ - it == -7) {\n            letter_grades.push_back(\"B-\");\n        } else if (next_ - it == -8) {\n            letter_grades.push_back(\"B-\");\n        } else if (next_ - it == -9) {\n            letter_grades.push_back(\"B-\");\n        } else if (next_ - it == -10) {\n            letter_grades.push_back(\"B-\");\n        } else if (next_ - it == -11) {\n            letter_grades.push_back(\"B-\");\n        } else if (next_ - it == -12) {\n            letter_grades.push_back(\"B-\");\n        } else if (next_ - it == -13) {\n            letter_grades.push_back(\"B-\");\n        } else if (next_ - it == -14) {\n            letter_grades.push_back(\"B-\");\n        } else if (next_ - it == -15) {\n            letter_grades.push_back(\"B-\");\n        } else if (next_ - it == -16) {\n            letter_grades.push_back(\"B-\");\n        } else if (next_ - it == -17) {\n            letter_grades.push_back(\"B-\");\n        } else if (next_ - it == -18) {\n            letter_grades.push_back(\"B-\");\n        } else if (next_ - it == -19) {\n            letter_grades.push_back(\"B-\");\n        } else if (next_ - it == -20) {\n            letter_grades.push_back(\"B-\");\n        } else if (next_ - it == -21) {\n            letter_grades.push_back(\"B-\");\n        } else if (next_ - it == -22) {\n            letter_grades.push_back(\"B-\");\n        } else if (next_ - it == -23) {\n            letter_grades.push_back(\"B-\");\n        } else if (next_ - it == -24) {\n            letter_grades.push_back(\"B-\");\n        } else if (next_ - it == -25) {\n            letter_grade",
    "grade-2": {
      "execution": 0
    },
    "3": "std::vector<std::string> letter_grades;\n    for (float i : grades) {\n        std::string grade;\n        if (i >= 4.0) {\n            grade = \"A+\";\n        } else if (i >= 3.7) {\n            grade = \"A\";\n        } else if (i >= 3.3) {\n            grade = \"A-\";\n        } else if (i >= 3.0) {\n            grade = \"B+\";\n        } else if (i >= 2.7) {\n            grade = \"B\";\n        } else if (i >= 2.3) {\n            grade = \"B-\";\n        } else if (i >= 2.0) {\n            grade = \"C+\";\n        } else if (i >= 1.7) {\n            grade = \"C\";\n        } else if (i >= 1.3) {\n            grade = \"C-\";\n        } else if (i >= 1.0) {\n            grade = \"D+\";\n        } else if (i >= 0.7) {\n            grade = \"D\";\n        } else if (i > 0.0) {\n            grade = \"D-\";\n        } else {\n            grade = \"E\";\n        }\n        letter_grades.push_back(grade);\n    }\n    return letter_grades;",
    "grade-3": {
      "execution": 0
    },
    "4": "// your code here\n    return {};",
    "grade-4": {
      "execution": 0
    },
    "5": "std::vector<std::string> a;\n  for(auto &x: grades){\n    if(x == 4) a.push_back(\"A+\");\n    else if(x > 3.7) a.push_back(\"A\");\n    else if(x > 3.3) a.push_back(\"A-\");\n    else if(x > 3) a.push_back(\"B+\");\n    else if(x > 2.7) a.push_back(\"B\");\n    else if(x > 2.3) a.push_back(\"B-\");\n    else if(x > 2) a.push_back(\"C+\");\n    else if(x > 1.7) a.push_back(\"C\");\n    else if(x > 1.3) a.push_back(\"C-\");\n    else if(x > 1) a.push_back(\"D+\");\n    else if(x > 0.7) a.push_back(\"D\");\n    else if(x > 0) a.push_back(\"D-\");\n    else a.push_back(\"E\");\n  }\n  return a;",
    "grade-5": {
      "execution": 0
    }
  },
  {
    "intent": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that returns a tuple (a, b), where 'a' is\n// the largest of negative integers, and 'b' is the smallest\n// of positive integers in a list.\n// If there is no negative or positive integers, return them as None.\n// Examples:\n// largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n// largest_smallest_integers([]) == (None, None)\n// largest_smallest_integers([0]) == (None, None)\nstd::tuple<std::optional<long>, std::optional<long>> largest_smallest_integers(std::vector<long> lst) {\n",
    "task_id": "136",
    "prompt": "/*\nCreate a function that returns a vector (a, b), where \"a\" is\nthe largest of negative integers, and \"b\" is the smallest\nof positive integers in a vector.\nIf there is no negative or positive integers, return them as 0.\n\nExamples:\nlargest_smallest_integers({2, 4, 1, 3, 5, 7}) == {0, 1}\nlargest_smallest_integers({}) == {0,0}\nlargest_smallest_integers({0}) == {0,0}\n*/\n#include<stdio.h>\n#include<vector>\nusing namespace std;\nvector<int> largest_smallest_integers(vector<int> lst){\n",
    "simplified_intent": "Create a function that returns a tuple (a, b), where 'a' is the largest of negative integers, and 'b' is the smallest of positive integers in a list. If there is no negative or positive integers, return them as None.",
    "snippet": [
      "    int maxneg=0,minpos=0;\n    for (int i=0;i<lst.size();i++)\n    {\n        if (lst[i]<0 and (maxneg==0 or lst[i]>maxneg)) maxneg=lst[i];\n        if (lst[i]>0 and (minpos==0 or lst[i]<minpos)) minpos=lst[i];\n    }\n    return {maxneg,minpos};\n}\n"
    ],
    "sample_from": {
      "0": "incoder",
      "1": "incoder",
      "2": "incoder",
      "3": "codex",
      "4": "codex",
      "5": "codex"
    },
    "0": "for (auto i : lst) {\n        if (i < 0) {\n            return {i, None};\n        } else if (i >= 0) {\n            return {None, i};\n        }\n    }\n    return {None, None};",
    "grade-0": {
      "execution": 0
    },
    "1": "std::optional<long> largest;\n  std::optional<long> smallest;\n\n  if (lst.empty())\n    return std::tuple<std::optional<long>, std::optional<long>>();\n\n  for (long number : lst) {\n    if (number < 0) {\n      largest = number;\n    } else if (number > 0) {\n      smallest = number;\n    }\n  }\n\n  return std::tuple<std::optional<long>, std::optional<long>>(largest, smallest);",
    "grade-1": {
      "execution": 0
    },
    "2": "if (lst.size() < 2) {\n        return std::tuple<std::optional<long>, std::optional<long>>(std::nullopt, std::nullopt);\n    }\n    std::optional<long> largest = std::nullopt;\n    std::optional<long> smallest = std::nullopt;\n    for (long i : lst) {\n        if (i < 0) {\n            if (largest == std::nullopt) {\n                largest = i;\n            } else {\n                largest = std::nullopt;\n            }\n        } else {\n            if (smallest == std::nullopt) {\n                smallest = i;\n            } else {\n                smallest = std::nullopt;\n            }\n        }\n    }\n    if (largest != std::nullopt && smallest != std::nullopt) {\n        return std::tuple<std::optional<long>, std::optional<long>>(largest, smallest);\n    } else {\n        return std::tuple<std::optional<long>, std::optional<long>>(std::nullopt, std::nullopt);\n    }",
    "grade-2": {
      "execution": 0
    },
    "3": "int n = lst.size();\n    if(n == 0)\n        return {std::nullopt, std::nullopt};\n    int max = -INT_MAX;\n    int min = INT_MAX;\n    for(int i = 0; i < n; i++) {\n        if(lst[i] > 0) {\n            if(lst[i] < min)\n                min = lst[i];\n        }\n        else {\n            if(lst[i] > max)\n                max = lst[i];\n        }\n    }\n    if(max == -INT_MAX && min == INT_MAX)\n        return {std::nullopt, std::nullopt};\n    else if(max == -INT_MAX)\n        return {std::nullopt, min};\n    else if(min == INT_MAX)\n        return {max, std::nullopt};\n    else\n        return {max, min};",
    "grade-3": {
      "execution": 0
    },
    "4": "int large = -1, small = 1;\n\tbool hasPositive = false, hasNegative = false;\n\tstd::tuple<std::optional<long>, std::optional<long>> answer;\n\tfor (int i = 0; i < lst.size(); i++) {\n\t\tif (lst[i] > 0) {\n\t\t\thasPositive = true;\n\t\t\tif (lst[i] < small) {\n\t\t\t\tsmall = lst[i];\n\t\t\t}\n\t\t}\n\t\telse if (lst[i] < 0) {\n\t\t\thasNegative = true;\n\t\t\tif (lst[i] > large) {\n\t\t\t\tlarge = lst[i];\n\t\t\t}\n\t\t}\n\t}\n\tif (hasPositive) {\n\t\tstd::get<1>(answer) = small;\n\t}\n\telse {\n\t\tstd::get<1>(answer) = {};\n\t}\n\tif (hasNegative) {\n\t\tstd::get<0>(answer) = large;\n\t}\n\telse {\n\t\tstd::get<0>(answer) = {};\n\t}\n\treturn answer;",
    "grade-4": {
      "execution": 0
    },
    "5": "std::optional<long> a, b;\n    for (long l : lst) {\n        if (l > 0) {\n            if (!b.has_value() || l < b.value()) {\n                b = l;\n            }\n        } else if (l < 0) {\n            if (!a.has_value() || l > a.value()) {\n                a = l;\n            }\n        }\n    }\n    return {a, b};",
    "grade-5": {
      "execution": 0
    }
  },
  {
    "intent": "#include<assert.h>\n#include<bits/stdc++.h>\n// Return n-th Fibonacci number.\n// >>> fib(10)\n// 55\n// >>> fib(1)\n// 1\n// >>> fib(8)\n// 21\nlong fib(long n) {\n",
    "task_id": "55",
    "prompt": "/*\nReturn n-th Fibonacci number.\n>>> fib(10)\n55\n>>> fib(1)\n1\n>>> fib(8)\n21\n*/\n#include<stdio.h>\nusing namespace std;\nint fib(int n){\n",
    "simplified_intent": "Return n-th Fibonacci number.",
    "snippet": [
      "    int f[1000];\n    f[0]=0;f[1]=1;\n    for (int i=2;i<=n; i++)\n    f[i]=f[i-1]+f[i-2];\n    return f[n];\n}\n"
    ],
    "sample_from": {
      "0": "incoder",
      "1": "incoder",
      "2": "incoder",
      "3": "codex",
      "4": "codex",
      "5": "codex"
    },
    "0": "if (n <= 1) return n;\n  long a = 1;\n  long b = 1;\n  for (long i = 1; i <= n; i++) {\n    long temp = a + b;\n    a = b;\n    b = temp;\n  }\n  return b;",
    "grade-0": {
      "execution": 0
    },
    "1": "if(n<2) return 1;\n    long result = fib(n - 1) + fib(n - 2);\n    return result;",
    "grade-1": {
      "execution": 0
    },
    "2": "if (n < 2)\n        return n;\n    return fib(n - 1) + fib(n - 2);",
    "grade-2": {
      "execution": 1
    },
    "3": "if (n==0) return 0;\n  else if (n==1) return 1;\n  else return fib(n-1)+fib(n-2);",
    "grade-3": {
      "execution": 1
    },
    "4": "if (n < 2) {\n        return n;\n    }\n    else {\n        return fib(n-1) + fib(n-2);\n    }",
    "grade-4": {
      "execution": 1
    },
    "5": "long a = 0, b = 1, c, i;\n   if( n == 0)\n      return a;\n   for (i = 2; i <= n; i++)\n   {\n      c = a + b;\n      a = b;\n      b = c;\n   }\n   return b;",
    "grade-5": {
      "execution": 1
    }
  },
  {
    "intent": "#include<assert.h>\n#include<bits/stdc++.h>\n// Circular shift the digits of the integer x, shift the digits right by shift\n// and return the result as a string.\n// If shift > number of digits, return digits reversed.\n// >>> circular_shift(12, 1)\n// \"21\"\n// >>> circular_shift(12, 2)\n// \"12\"\nstd::string circular_shift(long x, long shift) {\n",
    "task_id": "65",
    "prompt": "/*\nCircular shift the digits of the integer x, shift the digits right by shift\nand return the result as a string.\nIf shift > number of digits, return digits reversed.\n>>> circular_shift(12, 1)\n\"21\"\n>>> circular_shift(12, 2)\n\"12\"\n*/\n#include<stdio.h>\n#include<string>\nusing namespace std;\nstring circular_shift(int x,int shift){\n",
    "simplified_intent": "Circular shift the digits of the integer x, shift the digits right by shift and return the result as a string. If shift > number of digits, return digits reversed.",
    "snippet": [
      "    string xs;\n    xs=to_string(x);\n    if (xs.length()<shift)\n    {\n        string s(xs.rbegin(),xs.rend());\n        return s;\n    }\n    xs=xs.substr(xs.length()-shift)+xs.substr(0,xs.length()-shift);\n    return xs;\n}\n"
    ],
    "sample_from": {
      "0": "incoder",
      "1": "incoder",
      "2": "incoder",
      "3": "codex",
      "4": "codex",
      "5": "codex"
    },
    "0": "if (shift > log10((double)x))\n        shift = shift % log10((double)x);\n    if (shift < 0) shift = shift % 10;\n    long s = 0, r = 1;\n    do {\n        s = (r * x / 10000) % 10 + s;\n        x = (r / 10000) / 100;\n        r = x;\n    } while (shift-- > 0);\n    return std::to_string(r) + std::to_string(s);",
    "grade-0": {
      "execution": 0
    },
    "1": "std::ostringstream oss;\n  while (x != 0) {\n    oss << (x % 10);\n    x /= 10;\n  }\n  while (shift > oss.str().size()) {\n    oss << ((x % 10) % 10);\n    x /= 10;\n  }\n  oss << (x % 10);\n  return oss.str();",
    "grade-1": {
      "execution": 0
    },
    "2": "assert(shift > 0 && shift < 60);\n  // If shift is odd, shift by one and add the leading zero.\n  if (shift % 2 == 1) {\n    shift += 1;\n  }\n  std::string ans = \"\";\n  char digit = ' ';\n  while (shift >= 60) {\n    digit = x % 10;\n    x /= 10;\n    shift -= 60;\n    ans += std::to_string(shift) + std::to_string(digit);\n  }\n  digit = x % 10;\n  shift -= 1;\n  ans += std::to_string(shift) + std::to_string(digit);\n  return ans;",
    "grade-2": {
      "execution": 0
    },
    "3": "std::string result;\n    std::string str = std::to_string(x);\n    if (shift > str.length()) {\n        result = std::string(str.rbegin(), str.rend());\n    } else {\n        result = str.substr(str.length() - shift) + str.substr(0, str.length() - shift);\n    }\n    return result;",
    "grade-3": {
      "execution": 1
    },
    "4": "assert(shift > 0);\n  std::string str = std::to_string(x);\n  long size = str.size();\n  shift = shift % size;\n  std::string str1 = str.substr(size - shift, shift);\n  std::string str2 = str.substr(0, size - shift);\n  return str1 + str2;",
    "grade-4": {
      "execution": 0
    },
    "5": "std::stringstream ss;\n  long num_digits = std::log10(x) + 1;\n  shift = shift % num_digits;\n  if (shift == 0) {\n    ss << x;\n    return ss.str();\n  }\n  // If shifted more than number of digits, reverse and return\n  if (shift > num_digits) {\n    std::string s = std::to_string(x);\n    std::reverse(s.begin(), s.end());\n    return s;\n  }\n  std::string s = std::to_string(x);\n  std::string prefix = s.substr(0, shift);\n  std::string suffix = s.substr(shift, num_digits - shift);\n  ss << suffix << prefix;\n  return ss.str();",
    "grade-5": {
      "execution": 0
    }
  },
  {
    "intent": "#include<assert.h>\n#include<bits/stdc++.h>\n// Return maximum element in the list.\n// >>> max_element([1, 2, 3])\n// 3\n// >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n// 123\nlong max_element(std::vector<long> l) {\n",
    "task_id": "35",
    "prompt": "/*\nReturn maximum element in the vector.\n>>> max_element({1, 2, 3})\n3\n>>> max_element({5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10})\n123\n*/\n#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\nfloat max_element(vector<float> l){\n",
    "simplified_intent": "Return maximum element in the list.",
    "snippet": [
      "  float max=-10000;\n  for (int i=0;i<l.size();i++)\n  if (max<l[i]) max=l[i];\n  return max;\n\n}\n"
    ],
    "sample_from": {
      "0": "incoder",
      "1": "incoder",
      "2": "incoder",
      "3": "codex",
      "4": "codex",
      "5": "codex"
    },
    "0": "std::sort(l.begin(), l.end());\n    long index = l.size()-1;\n    for (index--; index >= 0; index--) {\n        if (l[index] < l[index+1]) return l[index];\n    }\n    return l[0];",
    "grade-0": {
      "execution": 0
    },
    "1": "long max = l[0];\n    for (long i = 1; i < l.size(); i++) {\n        if (l[i] > max) max = l[i];\n    }\n    return max;",
    "grade-1": {
      "execution": 1
    },
    "2": "assert(l.size() > 0);\n  long long largest = l[0];\n  for (long long i = 1; i < l.size(); i++) {\n    if (l[i] > largest) {\n      largest = l[i];\n    }\n  }\n  return largest;",
    "grade-2": {
      "execution": 1
    },
    "3": "if(l.size() == 0) return -1;\n    long max = l[0];\n    for(long x : l) {\n        if(x > max) max = x;\n    }\n    return max;",
    "grade-3": {
      "execution": 1
    },
    "4": "// TODO: Implement\n\t//return 0;\n\tlong ma=l[0];\n\tfor(int i=0;i<l.size();i++)\n\t{\n\t\tif(l[i]>ma)\n\t\t\tma=l[i];\n\t}\n\treturn ma;",
    "grade-4": {
      "execution": 1
    },
    "5": "long ret = -1;\n\tfor (int i = 0; i < l.size(); i++) {\n\t\tif (l[i] > ret)\n\t\t\tret = l[i];\n\t}\n\treturn ret;",
    "grade-5": {
      "execution": 1
    }
  },
  {
    "intent": "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n// Examples\n// solution([5, 8, 7, 1]) ==> 12\n// solution([3, 3, 3, 3, 3]) ==> 9\n// solution([30, 13, 24, 321]) ==>0\nlong solution(std::vector<long> lst) {\n",
    "task_id": "121",
    "prompt": "/*\nGiven a non-empty vector of integers, return the sum of all of the odd elements that are in even positions.\n\n\nExamples\nsolution({5, 8, 7, 1}) ==> 12\nsolution({3, 3, 3, 3, 3}) ==> 9\nsolution({30, 13, 24, 321}) ==>0\n*/\n#include<stdio.h>\n#include<vector>\nusing namespace std;\nint solutions(vector<int> lst){\n",
    "simplified_intent": "Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.",
    "snippet": [
      "    int sum=0;\n    for (int i=0;i*2<lst.size();i++)\n        if (lst[i*2]%2==1) sum+=lst[i*2];\n    return sum;\n}\n"
    ],
    "sample_from": {
      "0": "incoder",
      "1": "incoder",
      "2": "incoder",
      "3": "codex",
      "4": "codex",
      "5": "codex"
    },
    "0": "long long sum = 0;\n    for (long i = 0; i < lst.size(); i++) {\n        if (i % 2 == 0) {\n            sum += lst[i];\n        }\n    }\n    return sum;",
    "grade-0": {
      "execution": 0
    },
    "1": "long result = 0;\n    for (int i = 0; i < (int)lst.size(); i++) {\n        if (lst[(i + 1) % 2] == 1) {\n            result += lst[i];\n        }\n    }\n    return result;",
    "grade-1": {
      "execution": 0
    },
    "2": "long ans = 0;\n    for (int i = 0; i < lst.size(); i++) {\n        if (i % 2 == 1) {\n            ans += lst[i];\n        }\n    }\n    return ans;",
    "grade-2": {
      "execution": 0
    },
    "3": "if(lst.size() == 0)\n    return 0;\n  long sum = 0;\n  for(long i = 0; i < lst.size(); i++)\n  {\n    if(i % 2 == 0 && lst[i] % 2 != 0)\n      sum += lst[i];\n  }\n  return sum;",
    "grade-3": {
      "execution": 1
    },
    "4": "int i = 0;\n  int even = 0;\n  int odd = 0;\n  for (auto num : lst) {\n    if (i % 2 == 0) {\n      even += num;\n    } else {\n      odd += num;\n    }\n    i++;\n  }\n  return even - odd;",
    "grade-4": {
      "execution": 0
    },
    "5": "long sum = 0;\n  for (int i = 0; i < lst.size(); i++) {\n    if (i % 2 == 0 && lst[i] % 2 != 0) {\n      sum += lst[i];\n    }\n  }\n  return sum;",
    "grade-5": {
      "execution": 1
    }
  },
  {
    "intent": "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a tuple containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty tuple if planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n",
    "task_id": "148",
    "prompt": "/*\nThere are eight planets in our solar system: the closerst to the Sun \nis Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \nUranus, Neptune.\nWrite a function that takes two planet names as strings planet1 and planet2. \nThe function should return a vector containing all planets whose orbits are \nlocated between the orbit of planet1 and the orbit of planet2, sorted by \nthe proximity to the sun. \nThe function should return an empty vector if planet1 or planet2\nare not correct planet names. \nExamples\nbf(\"Jupiter\", \"Neptune\") ==> {\"Saturn\", \"Uranus\"}\nbf(\"Earth\", \"Mercury\") ==> {\"Venus\"}\nbf(\"Mercury\", \"Uranus\") ==> {\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n*/\n#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\nvector<string> bf(string planet1,string planet2){\n",
    "simplified_intent": "There are eight planets in our solar system: the closerst to the Sun is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, Uranus, Neptune. Write a function that takes two planet names as strings planet1 and planet2. The function should return a tuple containing all planets whose orbits are located between the orbit of planet1 and the orbit of planet2, sorted by the proximity to the sun. The function should return an empty tuple if planet1 or planet2 are not correct planet names.",
    "snippet": [
      "    vector<string> planets={\"Mercury\",\"Venus\",\"Earth\",\"Mars\",\"Jupiter\",\"Saturn\",\"Uranus\",\"Neptune\"};\n    int pos1=-1,pos2=-1,m;\n    for (m=0;m<planets.size();m++)\n    {\n    if (planets[m]==planet1) pos1=m;\n    if (planets[m]==planet2) pos2=m;\n    }\n    if (pos1==-1 or pos2==-1) return {};\n    if (pos1>pos2) {m=pos1;pos1=pos2;pos2=m;}\n    vector<string> out={};\n    for (m=pos1+1;m<pos2;m++)\n    out.push_back(planets[m]);\n    return out;\n}\n"
    ],
    "sample_from": {
      "0": "incoder",
      "1": "incoder",
      "2": "incoder",
      "3": "codex",
      "4": "codex",
      "5": "codex"
    },
    "0": "using std::cout;\n    using std::cin;\n    using std::string;\n    using std::vector;\n    using std::tuple;\n    using std::pair;\n    using std::make_pair;\n    using std::sort;\n    using std::distance;\n    vector<string> planet;\n    planet.push_back(planet1);\n    planet.push_back(planet2);\n    sort(begin(planet), end(planet), [](string a, string b) { return distance(a, b) < distance(planet[0], planet[1]); });\n    sort(begin(planet), end(planet));\n    vector<string>::iterator it1 = begin(planet);\n    vector<string>::iterator it2 = it1;\n    vector<string>::iterator it3 = it2;\n    for (vector<string>::iterator it2 = begin(planet); it2 != end(planet); it2++) \n    {\n        for (vector<string>::iterator it3 = it2; it3 != begin(planet); it3++) \n        {\n            cout << distance(it1, it3) << \" \";\n            it1 = it3;\n        }\n        cout << endl;\n    }\n    tuple<string, vector<string>> res = make_pair(planet1, planet);\n    return res;",
    "grade-0": {
      "execution": 0
    },
    "1": "//your code here\n    assert(planet1 != \"\");\n    assert(planet2 != \"\");\n    std::string planet1_name;\n    std::string planet2_name;\n    std::tie(planet1_name, planet2_name) = split(planet1, planet2);\n    std::tuple<std::string> orbit = std::make_tuple(planet1_name, planet2_name);\n    return orbit;",
    "grade-1": {
      "execution": 0
    },
    "2": "if(planet1 == \"Mercury\" && planet2 == \"Earth\") return std::make_tuple(\"Mercury\", \"Venus\");\n    if(planet1 == \"Earth\" && planet2 == \"Jupiter\") return std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\");\n    if(planet1 == \"Earth\" && planet2 == \"Neptune\") return std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\");\n    if(planet1 == \"Venus\" && planet2 == \"Mars\") return std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\");\n    if(planet1 == \"Venus\" && planet2 == \"Neptune\") return std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\");\n    if(planet1 == \"Venus\" && planet2 == \"Jupiter\") return std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\");\n    if(planet1 == \"Mars\" && planet2 == \"Jupiter\") return std::make_tuple(\"Mars\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\");\n    if(planet1 == \"Mars\" && planet2 == \"Neptune\") return std::make_tuple(\"Mars\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\");\n    if(planet1 == \"Mars\" && planet2 == \"Saturn\") return std::make_tuple(\"Mars\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\");\n    if(planet1 == \"Mars\" && planet2 == \"Uranus\") return std::make_tuple(\"Mars\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\");\n    if(planet1 == \"Saturn\" && planet2 == \"Uranus\") return std::make_tuple(\"Mars\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\");\n    if(planet1 == \"Saturn\" && planet2 == \"Neptune\") return std::make_tuple(\"Mars\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\");\n    if(planet1 == \"Saturn\" && planet2 == \"Jupiter\") return std::make_tuple(\"Mars\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\");\n    if(planet1 == \"Saturn\" && planet2 == \"Mars\") return std::make_tuple(\"Mars\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\");\n    if(planet1 == \"Saturn\" && planet2 == \"Mercury\") return std::make_tuple(\"Mars\", \"Earth",
    "grade-2": {
      "execution": 0
    },
    "3": "// your code here",
    "grade-3": {
      "execution": 0
    },
    "4": "const std::map<std::string, int> planets {\n    {\"Mercury\", 1},\n    {\"Venus\", 2},\n    {\"Earth\", 3},\n    {\"Mars\", 4},\n    {\"Jupiter\", 5},\n    {\"Saturn\", 6},\n    {\"Uranus\", 7},\n    {\"Neptune\", 8}\n  };\n  const auto begin = planets.find(planet1);\n  const auto end = planets.find(planet2);\n  if (begin == planets.end() || end == planets.end()) {\n    return {};\n  }\n  const int min = std::min(begin->second, end->second);\n  const int max = std::max(begin->second, end->second);\n  std::vector<std::string> planetsBetween;\n  for (const auto& planet : planets) {\n    if (planet.second > min && planet.second < max) {\n      planetsBetween.push_back(planet.first);\n    }\n  }\n  return std::make_tuple(planetsBetween[0], planetsBetween[1]);",
    "grade-4": {
      "execution": 0
    },
    "5": "std::vector<std::string> planets = {\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"};\n  std::vector<std::string>::iterator it1 = std::find(planets.begin(), planets.end(), planet1);\n  std::vector<std::string>::iterator it2 = std::find(planets.begin(), planets.end(), planet2);\n  if(it1 == planets.end() || it2 == planets.end())\n  {\n    return std::make_tuple();\n  }\n  if(it1 > it2)\n  {\n    std::vector<std::string>::iterator temp = it1;\n    it1 = it2;\n    it2 = temp;\n  }\n  it1++;\n  std::vector<std::string> res(it1, it2);\n  return std::make_tuple(res[0], res[1], res[2], res[3], res[4]);",
    "grade-5": {
      "execution": 0
    }
  },
  {
    "intent": "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long> parse_nested_parens(std::string paren_string) {\n",
    "task_id": "6",
    "prompt": "/*\nInput to this function is a string represented multiple groups for nested parentheses separated by spaces.\nFor each of the group, output the deepest level of nesting of parentheses.\nE.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n>>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n{2, 3, 1, 3}\n*/\n#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\nvector<int> parse_nested_parens(string paren_string){\n",
    "simplified_intent": "Input to this function is a string represented multiple groups for nested parentheses separated by spaces. For each of the group, output the deepest level of nesting of parentheses. E.g. (()()) has maximum two levels of nesting while ((())) has three.",
    "snippet": [
      "    vector<int> all_levels;\n    string current_paren;\n    int level=0,max_level=0;\n    char chr;\n    int i;\n    for (i=0;i<paren_string.length();i++)\n    {\n        chr=paren_string[i];\n        if (chr=='(')\n        {\n        level+=1;\n        if (level>max_level) max_level=level;\n        current_paren+=chr;\n        }\n        if (chr==')')\n        {\n            level-=1;\n            current_paren+=chr;\n            if (level==0){\n                all_levels.push_back(max_level);\n                current_paren=\"\";\n                max_level=0;\n            }\n        }\n    }\n    return all_levels;\n}\n"
    ],
    "sample_from": {
      "0": "incoder",
      "1": "incoder",
      "2": "incoder",
      "3": "codex",
      "4": "codex",
      "5": "codex"
    },
    "0": "auto paren_vec = paren_string.rfind_first_of(\"()\");\n    if (paren_vec != std::string::npos) {\n        auto left_bracket = paren_string.substr(0, paren_vec);\n        auto right_bracket = paren_string.substr(paren_vec + 2, paren_string.size() - paren_vec);\n        auto left_brackets = left_bracket.split(\"((\");\n        auto right_brackets = right_bracket.split(\"((\");\n        std::vector<long> result{};\n        for (long i = 0; i < left_brackets.size(); i++) {\n            auto left_brackets_len = left_brackets.size();\n            auto right_brackets_len = right_brackets.size();\n            if (left_brackets_len > right_brackets_len) {\n                result.push_back(left_brackets_len + 1);\n            } else if (left_brackets_len < right_brackets_len) {\n                result.push_back(left_brackets_len + right_brackets_len);\n            } else {\n                for (long j = 0; j < left_brackets_len; j++) {\n                    result.push_back(j + 1);\n                }\n            }\n        }\n        return result;\n    } else {\n        throw std::runtime_error(\"Failed to parse input string!\");\n    }",
    "grade-0": {
      "execution": 0
    },
    "1": "std::vector<long> levels;\n  std::string current_paren_string = paren_string;\n  while (true) {\n    std::size_t found = paren_string.find('(');\n    if (found == std::string::npos)\n      break;\n    levels.size();\n    levels.push_back(levels.size());\n    current_paren_string = paren_string.substr(0, found);\n    paren_string = current_paren_string;\n  }\n  return levels;",
    "grade-1": {
      "execution": 0
    },
    "2": "std::vector<long> paren_depth;\n    for (char c : paren_string)\n        if (paren_depth.empty() || paren_depth[paren_depth.size() - 1] <= ++c)\n            paren_depth.push_back(c);\n    return paren_depth;",
    "grade-2": {
      "execution": 0
    },
    "3": "std::vector<long> ans;\n    long nest_level = 0;\n    long max_nest_level = 0;\n    for (int i = 0; i < paren_string.size(); i++) {\n        if (paren_string[i] == '(') {\n            nest_level++;\n            max_nest_level = std::max(max_nest_level, nest_level);\n        } else if (paren_string[i] == ')') {\n            nest_level--;\n        } else if (paren_string[i] == ' ') {\n            ans.push_back(max_nest_level);\n            max_nest_level = 0;\n            nest_level = 0;\n        }\n    }\n    return ans;",
    "grade-3": {
      "execution": 0
    },
    "4": "// Edge cases\n\tif (paren_string.empty()) {\n\t\treturn {};\n\t}\n\tif (paren_string.length() == 1) {\n\t\treturn {0};\n\t}\n\tif (paren_string.length() == 2) {\n\t\treturn {0};\n\t}\n\t// Normal cases\n\tstd::vector<long> results;\n\t// Count all left parentheses in each word\n\tfor (int i = 0; i < paren_string.length(); i++) {\n\t\tint count = 0;\n\t\tif (paren_string[i] == '(') {\n\t\t\t// If the char is left, check if the next one is right. If not, increase count by 1.\n\t\t\twhile (paren_string[i + 1] != ')') {\n\t\t\t\tcount++;\n\t\t\t\ti++;\n\t\t\t}\n\t\t\tcount++;\n\t\t\tresults.push_back(count);\n\t\t}\n\t}\n\treturn results;",
    "grade-4": {
      "execution": 0
    },
    "5": "std::vector<long> v;\n    return v;",
    "grade-5": {
      "execution": 0
    }
  },
  {
    "intent": "#include<assert.h>\n#include<bits/stdc++.h>\n// triples_sum_to_zero takes a list of integers as an input.\n// it returns True if there are three distinct elements in the list that\n// sum to zero, and False otherwise.\n// >>> triples_sum_to_zero([1, 3, 5, 0])\n// False\n// >>> triples_sum_to_zero([1, 3, -2, 1])\n// True\n// >>> triples_sum_to_zero([1, 2, 3, 7])\n// False\n// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n// True\n// >>> triples_sum_to_zero([1])\n// False\nbool triples_sum_to_zero(std::vector<long> l) {\n",
    "task_id": "40",
    "prompt": "/*\ntriples_sum_to_zero takes a vector of integers as an input.\nit returns true if there are three distinct elements in the vector that\nsum to zero, and false otherwise.\n\n>>> triples_sum_to_zero({1, 3, 5, 0})\nfalse\n>>> triples_sum_to_zero({1, 3, -2, 1})\ntrue\n>>> triples_sum_to_zero({1, 2, 3, 7})\nfalse\n>>> triples_sum_to_zero({2, 4, -5, 3, 9, 7})\ntrue\n>>> triples_sum_to_zero({1})\nfalse\n*/\n#include<stdio.h>\n#include<vector>\nusing namespace std;\nbool triples_sum_to_zero(vector<int> l){\n",
    "simplified_intent": "triples_sum_to_zero takes a list of integers as an input. it returns True if there are three distinct elements in the list that sum to zero, and False otherwise.",
    "snippet": [
      "    for (int i=0;i<l.size();i++)\n    for (int j=i+1;j<l.size();j++)\n    for (int k=j+1;k<l.size();k++)\n        if (l[i]+l[j]+l[k]==0) return true;\n    return false;\n}\n"
    ],
    "sample_from": {
      "0": "incoder",
      "1": "incoder",
      "2": "incoder",
      "3": "codex",
      "4": "codex",
      "5": "codex"
    },
    "0": "long long int sum = 0;\n    for (long long int elem : l) {\n        sum += elem;\n    }\n    return sum == 0;",
    "grade-0": {
      "execution": 0
    },
    "1": "int n = l.size();\n    long long int sum = 0;\n    long long int prev_sum = 0;\n    for (int i = 0; i < n - 1; i++) {\n        sum += l[i];\n        if (sum == prev_sum) {\n            return false;\n        }\n        prev_sum = sum;\n    }\n    return true;",
    "grade-1": {
      "execution": 0
    },
    "2": "assert(l.size() >= 3);\n    std::vector<int> sum;\n    // We keep track of how many times a number appears in the list\n    // and how many times it has been added to the sum\n    std::vector<int> count(l.size(), 0);\n    for (long i : l)\n        if (count[i - 1] > 0)\n            count[i] += count[i - 1];\n        else\n            count[i - 1]++;\n    for (int i = 0; i < 3; i++)\n        if (count[i] > 0)\n            return false;\n    return true;",
    "grade-2": {
      "execution": 0
    },
    "3": "std::sort(l.begin(), l.end());\n\tint size = l.size();\n\tfor (int i = 0; i < size; i++) {\n\t\tint j = i + 1;\n\t\tint k = size - 1;\n\t\twhile (j < k) {\n\t\t\tif (l[i] + l[j] + l[k] == 0) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\telse if (l[i] + l[j] + l[k] < 0) {\n\t\t\t\tj++;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tk--;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;",
    "grade-3": {
      "execution": 1
    },
    "4": "// TODO: Implement Me\n    std::sort(l.begin(), l.end());\n    std::set<long> st(l.begin(), l.end());\n    l.assign(st.begin(), st.end());\n    for (int i = 0; i < l.size(); i++) {\n        int left = i + 1;\n        int right = l.size() - 1;\n        while (left < right) {\n            int sum = l[i] + l[left] + l[right];\n            if (sum == 0) {\n                return true;\n            } else if (sum < 0) {\n                left++;\n            } else {\n                right--;\n            }\n        }\n    }\n    return false;",
    "grade-4": {
      "execution": 0
    },
    "5": "// TODO: Implement me!\n  return false;",
    "grade-5": {
      "execution": 0
    }
  },
  {
    "intent": "#include<assert.h>\n#include<bits/stdc++.h>\n// Given two lists operator, and operand. The first list has basic algebra operations, and \n// the second list is a list of integers. Use the two given lists to build the algebric \n// expression and return the evaluation of this expression.\n// The basic algebra operations:\n// Addition ( + ) \n// Subtraction ( - ) \n// Multiplication ( * ) \n// Floor division ( // ) \n// Exponentiation ( ** ) \n// Example:\n// operator['+', '*', '-']\n// array = [2, 3, 4, 5]\n// result = 2 + 3 * 4 - 5\n// => result = 9\n// Note:\n// The length of operator list is equal to the length of operand list minus one.\n// Operand is a list of of non-negative integers.\n// Operator list has at least one operator, and operand list has at least two operands.\nlong do_algebra(std::vector<std::string> _operator_, std::vector<long> operand) {\n",
    "task_id": "160",
    "prompt": "/*\nGiven two vectors operator, and operand. The first vector has basic algebra operations, and \nthe second vector is a vector of integers. Use the two given vectors to build the algebric \nexpression and return the evaluation of this expression.\n\nThe basic algebra operations:\nAddition ( + ) \nSubtraction ( - ) \nMultiplication ( * ) \nFloor division ( // ) \nExponentiation ( ** ) \n\nExample:\noperator{\"+\", \"*\", \"-\"}\nvector = {2, 3, 4, 5}\nresult = 2 + 3 * 4 - 5\n=> result = 9\n\nNote:\n    The length of operator vector is equal to the length of operand vector minus one.\n    Operand is a vector of of non-negative integers.\n    Operator vector has at least one operator, and operand vector has at least two operands.\n\n*/\n#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nint do_algebra(vector<string> operato, vector<int> operand){\n",
    "simplified_intent": "Given two lists operator, and operand. The first list has basic algebra operations, and the second list is a list of integers. Use the two given lists to build the algebric expression and return the evaluation of this expression. The basic algebra operations: Addition ( + ) Subtraction ( - ) Multiplication ( * ) Floor division ( // ) Exponentiation ( ** )",
    "snippet": [
      "    vector<int> num={};\n    vector<int> posto={};\n    for (int i=0;i<operand.size();i++)\n        posto.push_back(i);\n    for (int i=0;i<operato.size();i++)\n        if (operato[i]==\"**\") \n        {\n        while (posto[posto[i]]!=posto[i]) posto[i]=posto[posto[i]];\n        while (posto[posto[i+1]]!=posto[i+1]) posto[i+1]=posto[posto[i+1]];\n        operand[posto[i]]=pow(operand[posto[i]],operand[posto[i+1]]);\n        posto[i+1]=posto[i];\n        }\n    for (int i=0;i<operato.size();i++)\n        if (operato[i]==\"*\" or operato[i]==\"//\") \n        {\n        while (posto[posto[i]]!=posto[i]) posto[i]=posto[posto[i]];\n        while (posto[posto[i+1]]!=posto[i+1]) posto[i+1]=posto[posto[i+1]];\n        if (operato[i]==\"*\")\n            operand[posto[i]]=operand[posto[i]]*operand[posto[i+1]];\n        else\n            operand[posto[i]]=operand[posto[i]]/operand[posto[i+1]];\n        posto[i+1]=posto[i];\n        }\n    for (int i=0;i<operato.size();i++)\n        if (operato[i]==\"+\" or operato[i]==\"-\") \n        {\n        while (posto[posto[i]]!=posto[i]) posto[i]=posto[posto[i]];\n        while (posto[posto[i+1]]!=posto[i+1]) posto[i+1]=posto[posto[i+1]];\n        if (operato[i]==\"+\")\n            operand[posto[i]]=operand[posto[i]]+operand[posto[i+1]];\n        else\n            operand[posto[i]]=operand[posto[i]]-operand[posto[i+1]];\n        posto[i+1]=posto[i];\n        }\n    return operand[0];\n\n}\n"
    ],
    "sample_from": {
      "0": "incoder",
      "1": "incoder",
      "2": "incoder",
      "3": "codex",
      "4": "codex",
      "5": "codex"
    },
    "0": "long result = 0;\n  assert(_operator_.size() == operand.size() - 1);\n  // Operator to perform.\n  std::string operation = _operator_[0];\n  // Operand to perform the operation on.\n  long current_operand = operand[0];\n  long operand1;\n  long operand2;\n  long operation1;\n  long operation2;\n  for(size_t i = 0; i < _operator_.size(); i++) {\n    // Check the next operator. \n    if(operation == \"+\") {\n      // Add the current operand.\n      result += current_operand;\n      current_operand = operand[i + 1];\n      continue;\n    }\n    if(operation == \"-\") {\n      // Subtract the current operand.\n      result -= current_operand;\n      current_operand = operand[i + 1];\n      continue;\n    }\n    if(operation == \"*\") {\n      // Multiply the current operand.\n      result *= current_operand;\n      current_operand = operand[i + 1];\n      continue;\n    }\n    if(operation == \"/\") {\n      // Floor the current operand.\n      result /= current_operand;\n      current_operand = operand[i + 1];\n      continue;\n    }\n    if(operation == \"**\") {\n      // Exponentiate the current operand.\n      result *= current_operand * current_operand;\n      current_operand = operand[i + 1];\n      continue;\n    }\n    // Operation unknown.\n    return -1;\n  }\n  return result;",
    "grade-0": {
      "execution": 0
    },
    "1": "// TODO: Write your code here\n    // Your code here\n    // Write your code here\n    std::map<std::string, long> operator;\n    // std::unordered_map<std::string, long> operator;\n    std::map<long, int> operandMap;\n\n    // for each operator in _operator_\n    for (auto opStr : _operator_)\n        operator[opStr] = -1;\n\n    // for each element in operand\n    int i = 0, j = 0;\n    while (i < operand.size() && j < operator.size()) {\n        if (operator[j] == -1)\n            operator[j] = j + 1;\n\n        // if the operator is equal in operand and operand\n        if (operand[i] == operand[j]) {\n            // if the operator exist in the map\n            if (operator.find(operand[j]) != operator.end())\n                // if the operator exist, just increasing the number in map\n                operator[operand[j]] = operandMap[operator[operand[j]]] + 1;\n            // if the operator not exist, just initialize the number of 1 in map\n            else\n                operator[operand[j]] = 1;\n            // else, just increase the number in map\n        }\n        // else, ignore this element in the operand\n        else\n            i += 1;\n        \n        i += 1;\n        j += 1;\n    }\n\n    // if there are exist operator\n    if (operator.size() != 0) {\n        // find the max value in the map\n        long maxNum = -1;\n        for (auto it: operator)\n            maxNum = std::max(maxNum, it.second);\n        // return the maxNum\n        return maxNum;\n    }\n    // if there is no exist operator\n    else\n        return -1;",
    "grade-1": {
      "execution": 0
    },
    "2": "std::map<std::string, long> operator;\n    operator['+'] = 0L;\n    operator['-'] = 0L;\n    operator['*'] = 1L;\n    operator['/'] = 1L;\n    operator['^'] = 2L;\n    operator['%'] = 2L;\n    operator['*'] = 2L;\n\n    int numOperator = _operator_.size() - 1;\n    int numOperand = operand.size() - 1;\n    for (int i = 0; i < numOperator; i++)\n    {\n        if (_operator_[i] == \"+\") {\n            operator[_operator_[i]] += operand[i + numOperand];\n        }\n        else if (_operator_[i] == \"-\") {\n            operator[_operator_[i]] -= operand[i + numOperand];\n        }\n        else if (_operator_[i] == \"*\") {\n            operator[_operator_[i]] *= operand[i + numOperand];\n        }\n        else if (_operator_[i] == \"/\") {\n            operator[_operator_[i]] /= operand[i + numOperand];\n        }\n        else if (_operator_[i] == \"^\") {\n            operator[_operator_[i]] **= operand[i + numOperand];\n        }\n        else if (_operator_[i] == \"%\") {\n            operator[_operator_[i]] %= operand[i + numOperand];\n        }\n        else if (_operator_[i] == \"*\") {\n            operator[_operator_[i]] *= operand[i + numOperand];\n        }\n    }\n    long result = 0;\n    for (std::map<std::string, long>::iterator iter = operator.begin();\n         iter != operator.end(); ++iter) {\n        result += (iter->second);\n    }\n    return result;",
    "grade-2": {
      "execution": 0
    },
    "3": "long result = operand[0];\n    // create a stack to keep track of the operands\n    std::stack<long> operand_stack;\n    operand_stack.push(result);\n    // iterate over operator_ and operand\n    for (unsigned i = 0; i < _operator_.size(); i++) {\n        if (_operator_[i] == \"+\") {\n            operand_stack.push(operand[i+1]);\n        } else if (_operator_[i] == \"-\") {\n            operand_stack.push(-operand[i+1]);\n        } else if (_operator_[i] == \"*\") {\n            long temp = operand_stack.top();\n            operand_stack.pop();\n            operand_stack.push(temp * operand[i+1]);\n        } else if (_operator_[i] == \"//\") {\n            long temp = operand_stack.top();\n            operand_stack.pop();\n            operand_stack.push(temp / operand[i+1]);\n        } else if (_operator_[i] == \"**\") {\n            long temp = operand_stack.top();\n            operand_stack.pop();\n            operand_stack.push(std::pow(temp, operand[i+1]));\n        }\n    }\n    // sum up all the operands\n    while (!operand_stack.empty()) {\n        result += operand_stack.top();\n        operand_stack.pop();\n    }\n    return result;",
    "grade-3": {
      "execution": 0
    },
    "4": "// do algebra using the operator and operand lists \n    long result = operand[0];\n    int i = 0;\n    while(i < _operator_.size()){\n        if(_operator_[i] == \"+\")\n            result += operand[i+1];\n        else if(_operator_[i] == \"-\")\n            result -= operand[i+1];\n        else if(_operator_[i] == \"*\")\n            result *= operand[i+1];\n        else if(_operator_[i] == \"//\")\n            result /= operand[i+1];\n        else if(_operator_[i] == \"**\")\n            result = pow(result, operand[i+1]);\n        i++;\n    }\n    return result;",
    "grade-4": {
      "execution": 0
    },
    "5": "long res = operand[0];\n\tfor (int i = 0; i < _operator_.size(); i++) {\n\t\tif (_operator_[i] == \"+\") {\n\t\t\tres += operand[i + 1];\n\t\t}\n\t\telse if (_operator_[i] == \"-\") {\n\t\t\tres -= operand[i + 1];\n\t\t}\n\t\telse if (_operator_[i] == \"*\") {\n\t\t\tres *= operand[i + 1];\n\t\t}\n\t\telse if (_operator_[i] == \"//\") {\n\t\t\tres /= operand[i + 1];\n\t\t}\n\t\telse if (_operator_[i] == \"**\") {\n\t\t\tres = pow(res, operand[i + 1]);\n\t\t}\n\t}\n\treturn res;",
    "grade-5": {
      "execution": 0
    }
  },
  {
    "intent": "#include<assert.h>\n#include<bits/stdc++.h>\n// The FibFib number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:\n// fibfib(0) == 0\n// fibfib(1) == 0\n// fibfib(2) == 1\n// fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n// Please write a function to efficiently compute the n-th element of the fibfib number sequence.\n// >>> fibfib(1)\n// 0\n// >>> fibfib(5)\n// 4\n// >>> fibfib(8)\n// 24\nlong fibfib(long n) {\n",
    "task_id": "63",
    "prompt": "/*\nThe FibFib number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:\nfibfib(0) == 0\nfibfib(1) == 0\nfibfib(2) == 1\nfibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\nPlease write a function to efficiently compute the n-th element of the fibfib number sequence.\n>>> fibfib(1)\n0\n>>> fibfib(5)\n4\n>>> fibfib(8)\n24\n*/\n#include<stdio.h>\nusing namespace std;\nint fibfib(int n){\n",
    "simplified_intent": "The FibFib number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows: fibfib(0) == 0 fibfib(1) == 0 fibfib(2) == 1 fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3). Please write a function to efficiently compute the n-th element of the fibfib number sequence.",
    "snippet": [
      "    int ff[100];\n    ff[0]=0;\n    ff[1]=0;\n    ff[2]=1;\n    for (int i=3;i<=n;i++)\n        ff[i]=ff[i-1]+ff[i-2]+ff[i-3];\n    return ff[n];\n\n}\n"
    ],
    "sample_from": {
      "0": "incoder",
      "1": "incoder",
      "2": "incoder",
      "3": "codex",
      "4": "codex",
      "5": "codex"
    },
    "0": "long res = 0;\n    long k = 3;\n    while (k <= n) {\n        res += k;\n        k = k + k;\n    }\n    return res;",
    "grade-0": {
      "execution": 0
    },
    "1": "int a = 0;\n    int b = 0;\n    int c = 0;\n    long d = 0;\n    long ans = 0;\n    for (int i = 1; i <= n; i++) {\n        c = a + b;\n        a = b;\n        b = c;\n        d += c;\n        ans = d;\n    }\n    return ans;",
    "grade-1": {
      "execution": 0
    },
    "2": "if(n == 0 || n == 1) return 0;\n   if(n == 2) return 1;\n   return fibfib(n-1) + fibfib(n-2) + fibfib(n-3);",
    "grade-2": {
      "execution": 1
    },
    "3": "if (n == 0) return 0;\n   if (n == 1) return 0;\n   if (n == 2) return 1;\n   return fibfib(n-1) + fibfib(n-2) + fibfib(n-3);",
    "grade-3": {
      "execution": 1
    },
    "4": "long dp[n+1];\n   dp[0] = 0;\n   dp[1] = 0;\n   dp[2] = 1;\n   for(int i = 3; i <= n; i++) {\n       dp[i] = dp[i-1] + dp[i-2] + dp[i-3];\n   }\n   return dp[n];",
    "grade-4": {
      "execution": 1
    },
    "5": "if (n < 0) {\n    throw;\n  }\n  if (n < 2) {\n    return 0;\n  }\n  if (n == 2) {\n    return 1;\n  }\n  long nMinusOne = 1;\n  long nMinusTwo = 0;\n  long nMinusThree = 0;\n  long currentValue = 0;\n  for (int i = 3; i <= n; i++) {\n    currentValue = nMinusOne + nMinusTwo + nMinusThree;\n    nMinusThree = nMinusTwo;\n    nMinusTwo = nMinusOne;\n    nMinusOne = currentValue;\n  }\n  return currentValue;",
    "grade-5": {
      "execution": 1
    }
  },
  {
    "intent": "#include<assert.h>\n#include<bits/stdc++.h>\n// Concatenate list of strings into a single string\n// >>> concatenate([])\n// ''\n// >>> concatenate(['a', 'b', 'c'])\n// 'abc'\nstd::string concatenate(std::vector<std::string> strings) {\n",
    "task_id": "28",
    "prompt": "/*\nConcatenate vector of strings into a single string\n>>> concatenate({})\n\"\"\n>>> concatenate({\"a\", \"b\", \"c\"})\n\"abc\"\n*/\n#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\nstring concatenate(vector<string> strings){\n",
    "simplified_intent": "Concatenate list of strings into a single string",
    "snippet": [
      "    string out=\"\";\n    for (int i=0;i<strings.size();i++)\n        out=out+strings[i];\n    return out;\n}\n"
    ],
    "sample_from": {
      "0": "incoder",
      "1": "incoder",
      "2": "incoder",
      "3": "codex",
      "4": "codex",
      "5": "codex"
    },
    "0": "// Concatenate all strings into single string by joining together\n  // strings separated by a separator (a comma in this case)\n  std::string result = \"\";\n  for (size_t i = 0; i != strings.size(); ++i) {\n    result += strings[i];\n    if (i != strings.size() - 1) {\n      result += ',';\n    }\n  }\n  return result;",
    "grade-0": {
      "execution": 0
    },
    "1": "std::string s;\n    for (const auto& str : strings) {\n        s += str;\n    }\n    return s;",
    "grade-1": {
      "execution": 1
    },
    "2": "std::string ret;\n    std::copy(strings.begin(), strings.end(), std::back_inserter(ret));\n    return ret;",
    "grade-2": {
      "execution": 0
    },
    "3": "std::string result = \"\";\nfor (auto s : strings) {\nresult += s;",
    "grade-3": {
      "execution": 0
    },
    "4": "std::string concat_string = \"\";\n    for (unsigned i = 0; i < strings.size(); i++) {\n        concat_string += strings[i];\n    }\n    return concat_string;",
    "grade-4": {
      "execution": 1
    },
    "5": "// your code goes here\n    string res = \"\";\n    for(string i : strings) {\n        res += i;\n    }\n    return res;",
    "grade-5": {
      "execution": 0
    }
  },
  {
    "intent": "#include<assert.h>\n#include<bits/stdc++.h>\n// Return a greatest common divisor of two integers a and b\n// >>> greatest_common_divisor(3, 5)\n// 1\n// >>> greatest_common_divisor(25, 15)\n// 5\nlong greatest_common_divisor(long a, long b) {\n",
    "task_id": "13",
    "prompt": "/*\nReturn a greatest common divisor of two integers a and b\n>>> greatest_common_divisor(3, 5)\n1\n>>> greatest_common_divisor(25, 15)\n5\n*/\n#include<stdio.h>\nusing namespace std;\nint greatest_common_divisor(int a, int b){\n",
    "simplified_intent": "Return a greatest common divisor of two integers a and b",
    "snippet": [
      "    int out,m;\n    while (true){\n        if (a<b) \n        {\n            m=a;a=b;b=m;\n        }\n        a=a%b;\n        if (a==0) return b;\n    }\n}\n"
    ],
    "sample_from": {
      "0": "incoder",
      "1": "incoder",
      "2": "incoder",
      "3": "codex",
      "4": "codex",
      "5": "codex"
    },
    "0": "if (a == 0)\n        return b;\n    if (b == 0)\n        return a;\n    if (a > b)\n        std::swap(a, b);\n    long low = a;\n    long high = b;\n    while (true) {\n        long mid = low + (high - low) / 2;\n        if (mid * mid == a)\n            return mid;\n        if (mid * mid == b)\n            return mid;\n        if (mid * mid > a)\n            low = mid;\n        else\n            high = mid;\n    }",
    "grade-0": {
      "execution": 0
    },
    "1": "if (b == 0) {\n        return a;\n    }\n    long div = greatest_common_divisor(b, a % b);\n    if (div == 1) {\n        return a;\n    }\n    return div;",
    "grade-1": {
      "execution": 0
    },
    "2": "if (b == 0) {\n        return a;\n    }\n    if (a == 0 || b == 0) {\n        return 0;\n    }\n    long g = greatest_common_divisor(b, a % b);\n    if (b / g != a) {\n        return g;\n    }\n    return b;",
    "grade-2": {
      "execution": 1
    },
    "3": "long c;\n    while ( a != 0 ) {\n        c = a; a = b%a;  b = c;\n    }\n    return b;",
    "grade-3": {
      "execution": 1
    },
    "4": "assert(a >= 0 && b >= 0);\n    return a == 0 ? b : greatest_common_divisor(b % a, a);",
    "grade-4": {
      "execution": 1
    },
    "5": "if (a <= 0 or b <= 0) return 0;\n    if (a < b) std::swap(a, b);\n    if (a % b == 0) return b;\n    return greatest_common_divisor(b, a % b);",
    "grade-5": {
      "execution": 1
    }
  },
  {
    "intent": "#include<assert.h>\n#include<bits/stdc++.h>\n// For a given string, flip lowercase characters to uppercase and uppercase to lowercase.\n// >>> flip_case('Hello')\n// 'hELLO'\nstd::string flip_case(std::string string) {\n",
    "task_id": "27",
    "prompt": "/*\nFor a given string, flip lowercase characters to uppercase and uppercase to lowercase.\n>>> flip_case(\"Hello\")\n\"hELLO\"\n*/\n#include<stdio.h>\n#include<string>\nusing namespace std;\nstring filp_case(string str){\n",
    "simplified_intent": "For a given string, flip lowercase characters to uppercase and uppercase to lowercase.",
    "snippet": [
      "    string out=\"\";\n    for (int i=0;i<str.length();i++)\n    {\n        char w=str[i];\n        if (w>=97 and w<=122) {w-=32;}\n        else\n            if (w>=65 and w<=90){ w+=32;}\n        out=out+w;\n    }\n    return out;\n}\n"
    ],
    "sample_from": {
      "0": "incoder",
      "1": "incoder",
      "2": "incoder",
      "3": "codex",
      "4": "codex",
      "5": "codex"
    },
    "0": "string s = string;\n  for (auto i : s) {\n    if (i == tolower(i)) {\n      s[i] = toupper(i);\n    }\n  }\n  return s;",
    "grade-0": {
      "execution": 0
    },
    "1": "std::string result = \"\";\n   for (char &c : string) {\n      c = toupper(c);\n      if (islower(c))\n         c = tolower(c);\n      result += c;\n   }\n   return result;",
    "grade-1": {
      "execution": 0
    },
    "2": "for (auto& c : string)\n        c = toupper(c);\n    return string;",
    "grade-2": {
      "execution": 0
    },
    "3": "for(int i=0; i<string.length(); i++) {\n        if(string[i] >= 'a' && string[i] <= 'z') {\n            string[i] = string[i] - 32;\n        }\n        else if(string[i] >= 'A' && string[i] <= 'Z') {\n            string[i] = string[i] + 32;\n        }\n    }\n    return string;",
    "grade-3": {
      "execution": 1
    },
    "4": "for(int i=0;i<string.length();i++)\n    {\n        if(isupper(string[i]))\n        {\n            string[i]=tolower(string[i]);\n        }\n        else\n        {\n            string[i]=toupper(string[i]);\n        }\n    }\n    return string;",
    "grade-4": {
      "execution": 1
    },
    "5": "int len = string.length();\n    for(int i=0;i<len;i++){\n        if(string[i]>=65 && string[i]<=90){\n            string[i] = string[i] + 32;\n        }\n        else if(string[i]>=97 && string[i]<=122){\n            string[i] = string[i] - 32;\n        }\n    }\n    return string;",
    "grade-5": {
      "execution": 1
    }
  },
  {
    "intent": "#include<assert.h>\n#include<bits/stdc++.h>\n// Your task is to write a function that returns true if a number x is a simple\n// power of n and false in other cases.\n// x is a simple power of n if n**int=x\n// For example:\n// is_simple_power(1, 4) => true\n// is_simple_power(2, 2) => true\n// is_simple_power(8, 2) => true\n// is_simple_power(3, 2) => false\n// is_simple_power(3, 1) => false\n// is_simple_power(5, 3) => false\nbool is_simple_power(long x, long n) {\n",
    "task_id": "76",
    "prompt": "/*\nYour task is to write a function that returns true if a number x is a simple\npower of n and false in other cases.\nx is a simple power of n if n**int=x\nFor example:\nis_simple_power(1, 4) => true\nis_simple_power(2, 2) => true\nis_simple_power(8, 2) => true\nis_simple_power(3, 2) => false\nis_simple_power(3, 1) => false\nis_simple_power(5, 3) => false\n*/\n#include<stdio.h>\n#include<math.h>\nusing namespace std;\nbool is_simple_power(int x,int n){\n",
    "simplified_intent": "Your task is to write a function that returns true if a number x is a simple power of n and false in other cases. x is a simple power of n if n**int=x",
    "snippet": [
      "    int p=1,count=0;\n    while (p<=x and count<100)\n    {\n        if (p==x) return true;\n        p=p*n;count+=1;\n    }\n    return false;\n}\n"
    ],
    "sample_from": {
      "0": "incoder",
      "1": "incoder",
      "2": "incoder",
      "3": "codex",
      "4": "codex",
      "5": "codex"
    },
    "0": "if (x == 1) {\n\t\treturn true;\n\t}\n\tif (n % 2 == 0) {\n\t\treturn is_simple_power(x , n / 2);\n\t}\n\treturn is_simple_power(x * x, n / 2);",
    "grade-0": {
      "execution": 0
    },
    "1": "// base case\n  if (n == 1) return true;\n  // recursive case\n  else if (n % 2 == 0 && n < x) return is_simple_power(x, n / 2);\n  else return false;",
    "grade-1": {
      "execution": 0
    },
    "2": "long a = 1, b = 1, c = 0;\n    while (b < n) {\n        if (b & 1) c = a * x;\n        a = c; b = b >> 1;\n    }\n    return n == b;",
    "grade-2": {
      "execution": 0
    },
    "3": "long i = 1;\n    while (pow(n, i) <= x) {\n        if (pow(n, i) == x) {\n            return true;\n        }\n        i++;\n    }\n    return false;",
    "grade-3": {
      "execution": 0
    },
    "4": "float result = log(x) / log(n);\n  float rounded = roundf(result * 100) / 100;\n  return result == rounded;",
    "grade-4": {
      "execution": 0
    },
    "5": "if (x == 1) return true;\n  if (n == 1) return false;\n  if (x == n) return true;\n  for (long i = 2; i <= x; i++) {\n    long k = i;\n    for (long j = 2; j <= i; j++) {\n      if (k % n == 0) k /= n;\n      else break;\n    }\n    if (k == 1) {\n      if (i * i == x) return false;\n      if (i == x) return true;\n    }\n  }\n  return false;",
    "grade-5": {
      "execution": 0
    }
  },
  {
    "intent": "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a grid with N rows and N columns (N >= 2) and a positive integer k, \n// each cell of the grid contains a value. Every integer in the range [1, N * N]\n// inclusive appears exactly once on the cells of the grid.\n// You have to find the minimum path of length k in the grid. You can start\n// from any cell, and in each step you can move to any of the neighbor cells,\n// in other words, you can go to cells which share an edge with you current\n// cell.\n// Please note that a path of length k means visiting exactly k cells (not\n// necessarily distinct).\n// You CANNOT go off the grid.\n// A path A (of length k) is considered less than a path B (of length k) if\n// after making the ordered lists of the values on the cells that A and B go\n// through (let's call them lst_A and lst_B), lst_A is lexicographically less\n// than lst_B, in other words, there exist an integer index i (1 <= i <= k)\n// such that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n// lst_A[j] = lst_B[j].\n// It is guaranteed that the answer is unique.\n// Return an ordered list of the values on the cells that the minimum path go through.\n// Examples:\n// Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n// Output: [1, 2, 1]\n// Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n// Output: [1]\nstd::vector<long> minPath(std::vector<std::vector<long>> grid, long k) {\n",
    "task_id": "129",
    "prompt": "/*\nGiven a grid with N rows and N columns (N >= 2) and a positive integer k, \neach cell of the grid contains a value. Every integer in the range {1, N * N}\ninclusive appears exactly once on the cells of the grid.\n\nYou have to find the minimum path of length k in the grid. You can start\nfrom any cell, and in each step you can move to any of the neighbor cells,\nin other words, you can go to cells which share an edge with you current\ncell.\nPlease note that a path of length k means visiting exactly k cells (not\nnecessarily distinct).\nYou CANNOT go off the grid.\nA path A (of length k) is considered less than a path B (of length k) if\nafter making the ordered vectors of the values on the cells that A and B go\nthrough (let's call them lst_A and lst_B), lst_A is lexicographically less\nthan lst_B, in other words, there exist an integer index i (1 <= i <= k)\nsuch that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\nlst_A[j] = lst_B[j].\nIt is guaranteed that the answer is unique.\nReturn an ordered vector of the values on the cells that the minimum path go through.\n\nExamples:\n\n    Input: grid = { {1,2,3}, {4,5,6}, {7,8,9}}, k = 3\n    Output: {1, 2, 1}\n\n    Input: grid = { {5,9,3}, {4,1,6}, {7,8,2}}, k = 1\n    Output: {1}\n*/\n#include<stdio.h>\n#include<vector>\nusing namespace std;\nvector<int> minPath(vector<vector<int>> grid, int k){\n",
    "simplified_intent": "Given a grid with N rows and N columns (N >= 2) and a positive integer k, each cell of the grid contains a value. Every integer in the range [1, N * N] inclusive appears exactly once on the cells of the grid. You have to find the minimum path of length k in the grid. You can start from any cell, and in each step you can move to any of the neighbor cells, in other words, you can go to cells which share an edge with you current cell. Please note that a path of length k means visiting exactly k cells (not necessarily distinct). You CANNOT go off the grid. A path A (of length k) is considered less than a path B (of length k) if after making the ordered lists of the values on the cells that A and B go through (let's call them lst_A and lst_B), lst_A is lexicographically less than lst_B, in other words, there exist an integer index i (1 <= i <= k) such that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have lst_A[j] = lst_B[j]. It is guaranteed that the answer is unique. Return an ordered list of the values on the cells that the minimum path go through.",
    "snippet": [
      "    int i,j,x,y,min;\n    for (i=0;i<grid.size();i++)\n        for (j=0;j<grid[i].size();j++)\n            if (grid[i][j]==1) {\n                x=i;y=j;\n            }\n    min=grid.size()*grid.size();\n    if (x>0 and grid[x-1][y]<min) min=grid[x-1][y];\n    if (x<grid.size()-1 and grid[x+1][y]<min) min=grid[x+1][y];\n    if (y>0 and grid[x][y-1]<min) min=grid[x][y-1];\n    if (y<grid.size()-1 and grid[x][y+1]<min) min=grid[x][y+1];\n    vector<int> out={};\n    for (i=0;i<k;i++)\n    if (i%2==0) out.push_back(1);\n    else out.push_back(min);\n    return out;\n}\n"
    ],
    "sample_from": {
      "0": "incoder",
      "1": "incoder",
      "2": "incoder",
      "3": "codex",
      "4": "codex",
      "5": "codex"
    },
    "0": "long ans = 0;\n    // Use map to store all visited cells\n    std::map<long, long> visited;\n    // Using queue to store all cells\n    std::queue<long> queue;\n    for(long row = 0; row < grid.size(); row++) {\n        for(long col = 0; col < grid[0].size(); col++) {\n            if(visited.find(grid[row][col]) == visited.end()) {\n                // If not visited, add it to a queue\n                queue.push(grid[row][col]);\n                // Add it to map\n                visited[grid[row][col]] = grid[row][col];\n            }\n        }\n    }\n    // Use map to store all visited cells along the path\n    std::map<long, long> path;\n    visited[grid[0][0].back()] = grid[0][0].back();\n    while(!queue.empty()) {\n        long value = queue.front();\n        queue.pop();\n        // If already visited, return it\n        if(visited.find(value) != visited.end()) {\n            path[value] = visited[value];\n            ans += visited[value];\n        }\n        else {\n            // If not visited, then visit all neighbours\n            for(long row = 0; row < grid.size(); row++) {\n                for(long col = 0; col < grid[0].size(); col++) {\n                    if(visited.find(grid[row][col]) == visited.end()) {\n                        // If not visited, add it to a queue\n                        queue.push(grid[row][col]);\n                        // Add it to map\n                        visited[grid[row][col]] = grid[row][col];\n                    }\n                }\n            }\n            path[value] = visited[value];\n            ans += visited[value];\n        }\n    }\n    std::vector<long> ans_path;\n    for(long i = 0; i < path.size(); i++) {\n        if(path[i] < ans) {\n            ans_path.push_back(path[i]);\n        }\n    }\n    return ans_path.reverse();",
    "grade-0": {
      "execution": 0
    },
    "1": "// Your code here\n    long n = grid.size();\n    long m = grid[0].size();\n    std::vector<std::vector<long> > vec(n);\n    for(long i = 0; i < n; ++i){\n        vec[i] = std::vector<long>(m);\n        for(long j = 0; j < m; ++j){\n            long val = 0;\n            for(long r = i - 1; r <= i + k; ++r){\n                for(long c = j - 1; c <= j + k; ++c){\n                    if(grid[r][c] > 0){\n                        val += grid[r][c];\n                    }\n                }\n            }\n            vec[i][j] = val;\n        }\n    }\n    long ans = 0;\n    for(long i = 0; i < n; ++i){\n        long min = INT_MAX;\n        for(long j = 0; j < m; ++j){\n            if(vec[i][j] < min){\n                min = vec[i][j];\n            }\n        }\n        ans = min;\n    }\n    return std::vector<long>(ans);",
    "grade-1": {
      "execution": 0
    },
    "2": "std::vector<long> ans;\n  std::list<long> lst_A, lst_B;\n  // store all value on a grid\n  for (auto &row : grid) {\n    for (auto &val : row) {\n      lst_A.push_back(lst_A.back() + val);\n      lst_B.push_back(lst_B.back() + val);\n    }\n  }\n  // for each cell, store its value\n  for (size_t r = 0; r < grid.size(); r++) {\n    for (size_t c = 0; c < grid[0].size(); c++) {\n      ans.push_back(grid[r][c]);\n    }\n  }\n  // for each cell, add 1 to the value in lst_A or lst_B\n  for (size_t r = 0; r < grid.size(); r++) {\n    for (size_t c = 0; c < grid[0].size(); c++) {\n      if (r == 0 || grid[r][c] == grid[r - 1][c] || c == 0 || grid[r][c] == grid[r][c - 1]) {\n        continue;\n      } else {\n        ans[r][c] += grid[r][c];\n        lst_A.push_back(grid[r][c]);\n      }\n    }\n  }\n  // for each cell, add k to the value in lst_A or lst_B\n  for (size_t r = 0; r < grid.size(); r++) {\n    for (size_t c = 0; c < grid[0].size(); c++) {\n      if (r == 0 || grid[r][c] == grid[r - 1][c] || c == 0 || grid[r][c] == grid[r][c - 1]) {\n        continue;\n      } else {\n        ans[r][c] += k;\n        lst_B.push_back(k);\n      }\n    }\n  }\n  // for each cell, compare and find the smallest one\n  for (size_t r = 0; r < grid.size(); r++) {\n    for (size_t c = 0; c < grid[0].size(); c++) {\n      if (r == 0 || grid[r][c] == grid[r - 1][c] || c == 0 || grid[r][c] == grid[r][c - 1]) {\n        continue;\n      } else {\n        // compare lst_A and lst_B\n        if (lst_A[lst_A.size() - 1] < lst_B[lst_B.size() - 1]) {\n          lst_A.push_back(grid[r][c]);\n        } else {\n          lst_B.push_back(grid[r][c]);\n        }\n      }\n    }\n  }\n  // add k to the value from lst_B\n  ans.back() = lst_B.back() + k;\n  // add 1 to value from lst_A\n  ans.front() = lst_A.front() + 1;\n  // print out the answer\n  for (auto &row : ans) {\n    for (auto &val : row) {\n      printf(\"",
    "grade-2": {
      "execution": 0
    },
    "3": "// Write your code here\n\tif (k == 0)\n\t\treturn {};\n\tint n = grid.size();\n\tif (n == 0)\n\t\treturn {};\n\tif (n == 1)\n\t\treturn grid[0];\n\tint m = grid[0].size();\n\tif (m == 0)\n\t\treturn {};\n\tif (m == 1)\n\t{\n\t\tstd::vector<long> temp;\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ttemp.push_back(grid[i][0]);\n\t\treturn temp;\n\t}\n\tlong sum = 0;\n\tlong s = 0;\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tfor (int j = 0; j < m; j++)\n\t\t{\n\t\t\tsum += grid[i][j];\n\t\t\ts += grid[i][j] * (i + j);\n\t\t}\n\t}\n\tif (sum == k)\n\t{\n\t\tstd::vector<long> temp;\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < m; j++)\n\t\t\t{\n\t\t\t\ttemp.push_back(grid[i][j]);\n\t\t\t}\n\t\t}\n\t\treturn temp;\n\t}\n\tstd::vector<long> dir{ 1, -1, -m, m };\n\tstd::vector<long> ans;\n\tstd::vector<long> ans1;\n\tstd::vector<long> ans2;\n\tstd::vector<long> ans3;\n\tstd::vector<long> ans4;\n\tstd::vector<long> temp;\n\tstd::vector<long> temp1;\n\tstd::vector<long> temp2;\n\tstd::vector<long> temp3;\n\tstd::vector<long> temp4;\n\tstd::vector<long> row;\n\tstd::vector<long> col;\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tfor (int j = 0;",
    "grade-3": {
      "execution": 0
    },
    "4": "//      [5,9,3],\n    //      [4,1,6],\n    //      [7,8,2]], k = 1\n    //\n    //\n    //       5,9,3\n    //       5,9,3\n    //       5,9,3\n    //      5,9,3\n    //     5,9,3\n    //    5,9,3\n    //   5,9,3\n    //  5,9,3\n    // 5,9,3\n    //5,9,3\n    //5,9,3\n    //5,9,3\n    //5,9,3\n    //5,9,3\n    //5,9,3\n    //5,9,3\n    //5,9,3\n    //5,9,3\n    //5,9,3\n    //5,9,3\n    //5,9,3\n    //5,9,3\n    //5,9,3\n    //5,9,3\n    //5,9,3\n    //5,9,3\n    //5,9,3\n    //5,9,3\n    //5,9,3\n    //5,9,3\n    //5,9,3\n    //5,9,3\n    //5,9,3\n    //5,9,3\n    //5,9,3\n    //5,9,3\n    //5,9,3\n    //5,9,3\n    //5,9,3\n    //5,9,3\n    //5,9,3\n    //5,9,3\n    //5,9,3\n    //5,9,3\n    //5,9,3\n    //5,9,3\n    //5,9,3\n    //5,9,3\n    //5,9,3\n    //5,9,3\n    //5,9,3\n    //5,9,3\n    //5,9,3\n    //5,9,3\n    //5,9,3\n    //5,9,3\n    //5,9,3\n    //5,",
    "grade-4": {
      "execution": 0
    },
    "5": "std::vector<long> result;\n    int n = grid.size();\n    int m = grid[0].size();\n    std::vector<std::vector<int>> dp(n, std::vector<int>(m, INT_MAX));\n    std::priority_queue<std::vector<int>, std::vector<std::vector<int>>, std::greater<std::vector<int>>> pq;\n    pq.push({grid[0][0], 0, 0});\n    while(!pq.empty()) {\n        auto temp = pq.top();\n        pq.pop();\n        long value = temp[0];\n        int x = temp[1];\n        int y = temp[2];\n        if(x >= 0 && x < n && y >= 0 && y < m && dp[x][y] > k) {\n            dp[x][y] = k;\n            if(k == 1) {\n                result.push_back(value);\n            }\n            else {\n                pq.push({grid[x][y], x, y});\n                pq.push({grid[x][y], x - 1, y});\n                pq.push({grid[x][y], x + 1, y});\n                pq.push({grid[x][y], x, y - 1});\n                pq.push({grid[x][y], x, y + 1});\n            }\n        }\n    }\n    return result;",
    "grade-5": {
      "execution": 0
    }
  },
  {
    "intent": "#include<assert.h>\n#include<bits/stdc++.h>\n// From a list of integers, remove all elements that occur more than once.\n// Keep order of elements left the same as in the input.\n// >>> remove_duplicates([1, 2, 3, 2, 4])\n// [1, 3, 4]\nstd::vector<long> remove_duplicates(std::vector<long> numbers) {\n",
    "task_id": "26",
    "prompt": "/*\nFrom a vector of integers, remove all elements that occur more than once.\nKeep order of elements left the same as in the input.\n>>> remove_duplicates({1, 2, 3, 2, 4})\n{1, 3, 4}\n*/\n#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nvector<int> remove_duplicates(vector<int> numbers){\n",
    "simplified_intent": "From a list of integers, remove all elements that occur more than once. Keep order of elements left the same as in the input.",
    "snippet": [
      "    vector<int> out={};\n    vector<int> has1={};\n    vector<int> has2={};\n    for (int i=0;i<numbers.size();i++)\n    {\n        if (find(has2.begin(),has2.end(),numbers[i])!=has2.end()) continue;\n        if (find(has1.begin(),has1.end(),numbers[i])!=has1.end())\n        {\n\n            has2.push_back(numbers[i]);\n        }\n        else has1.push_back(numbers[i]);\n    }\n    for (int i=0;i<numbers.size();i++)\n    if (find(has2.begin(),has2.end(),numbers[i])==has2.end())\n        out.push_back(numbers[i]);\n    return out;\n\n\n}\n"
    ],
    "sample_from": {
      "0": "incoder",
      "1": "incoder",
      "2": "incoder",
      "3": "codex",
      "4": "codex",
      "5": "codex"
    },
    "0": "std::vector<long> uniqueNumbers;\n  long number = 0;\n  for (int i = 0; i < numbers.size(); i++) {\n    number += numbers[i];\n    while (numbers[--i] == number) {\n      uniqueNumbers.push_back(numbers[i]);\n    }\n  }\n  return uniqueNumbers;",
    "grade-0": {
      "execution": 0
    },
    "1": "long long int sum = 0;\n    for (int i = 0; i < numbers.size(); i++) {\n        if (numbers.at(i) != i) {\n            sum += numbers.at(i);\n            numbers.erase(numbers.begin() + numbers.at(i));\n        }\n    }\n    return numbers;",
    "grade-1": {
      "execution": 0
    },
    "2": "std::vector<long> result;\n    std::unordered_set<long> numberSet;\n\n    for (const auto &i : numbers)\n        numberSet.insert(i);\n\n    for (const auto &i : numberSet)\n        result.push_back(i);\n\n    return result;",
    "grade-2": {
      "execution": 0
    },
    "3": "std::vector<long> result;\n    std::unordered_set<long> set;\n    for (long n : numbers) {\n        if (set.count(n) == 0) {\n            result.push_back(n);\n            set.insert(n);\n        }\n    }\n    return result;",
    "grade-3": {
      "execution": 0
    },
    "4": "std::vector<long> new_numbers;\n\tfor (int i = 0; i < numbers.size(); i++) {\n\t\tif (find(new_numbers.begin(), new_numbers.end(), numbers[i]) == new_numbers.end()) {\n\t\t\tnew_numbers.push_back(numbers[i]);\n\t\t}\n\t}\n\treturn new_numbers;",
    "grade-4": {
      "execution": 0
    },
    "5": "// Your code goes here\n    std::vector<long> res;\n    std::set<long> s;\n    for(auto i:numbers){\n        if(s.count(i)==0){\n            s.insert(i);\n            res.push_back(i);\n        }\n    }\n    return res;",
    "grade-5": {
      "execution": 0
    }
  },
  {
    "intent": "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a list of strings, where each string consists of only digits, return a list.\n// Each element i of the output should be \"the number of odd elements in the\n// string i of the input.\" where all the i's should be replaced by the number\n// of odd digits in the i'th string of the input.\n// >>> odd_count(['1234567'])\n// [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n// >>> odd_count(['3',\"11111111\"])\n// [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n// \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\nstd::vector<std::string> odd_count(std::vector<std::string> lst) {\n",
    "task_id": "113",
    "prompt": "/*\nGiven a vector of strings, where each string consists of only digits, return a vector.\nEach element i of the output should be 'the number of odd elements in the\nstring i of the input.\" where all the i's should be replaced by the number\nof odd digits in the i'th string of the input.\n\n>>> odd_count({\"1234567\"})\n{'the number of odd elements 4n the str4ng 4 of the 4nput.\"}\n>>> odd_count({\"3\",\"11111111\"})\n{'the number of odd elements 1n the str1ng 1 of the 1nput.\",\n 'the number of odd elements 8n the str8ng 8 of the 8nput.\"}\n*/\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<map>\nusing namespace std;\nvector<string> odd_count(vector<string> lst){\n",
    "simplified_intent": "Given a list of strings, where each string consists of only digits, return a list. Each element i of the output should be \"the number of odd elements in the string i of the input.\" where all the i's should be replaced by the number of odd digits in the i'th string of the input.",
    "snippet": [
      "    vector<string> out={};\n    for (int i=0;i<lst.size();i++)\n        {\n            int sum=0;\n            for (int j=0;j<lst[i].length();j++)\n                if (lst[i][j]>=48 and lst[i][j]<=57 and lst[i][j]%2==1)\n                sum+=1;\n            string s=\"the number of odd elements in the string i of the input.\";\n            string s2=\"\";\n            for (int j=0;j<s.length();j++)\n                if (s[j]=='i') s2=s2+to_string(sum);\n                else s2=s2+s[j];\n            out.push_back(s2);\n        }\n    return out;\n}\n"
    ],
    "sample_from": {
      "0": "incoder",
      "1": "incoder",
      "2": "incoder",
      "3": "codex",
      "4": "codex",
      "5": "codex"
    },
    "0": "std::sort(lst.begin(), lst.end());\n  std::vector<std::string> res;\n  std::string s = \"\";\n  for (auto it = lst.begin(); it != lst.end(); ++it) {\n    s = *it;\n    s += '0';\n    auto it = s.begin();\n    for (; it != s.end() - 1; ++it) {\n      assert(*it != '0');\n    }\n    s += \"n\";\n    res.push_back(s);\n  }\n  return res;",
    "grade-0": {
      "execution": 0
    },
    "1": "int n = lst.size();\n  assert(n > 0);\n  \n  // Sort the elements of the list\n  std::vector<int> sorted_elements(n, 0);\n  for (int i = 0; i < n; ++i) {\n    int element = stoi(lst.at(i));\n    sorted_elements[element] += 1;\n  }\n  \n  // Initialize the output with empty strings\n  std::vector<std::string> odd_elements(n, \"\");\n  for (int i = 0; i < n; ++i) {\n    odd_elements[i] = std::to_string(sorted_elements[i]);\n  }\n  \n  // Sort the output string\n  std::sort(odd_elements.begin(), odd_elements.end());\n  \n  // Return the output list\n  return odd_elements;",
    "grade-1": {
      "execution": 0
    },
    "2": "assert(lst.size() == 1 && lst[0].size() == 10);\n  // vector<int> is faster than vector<vector<int>>\n  std::vector<int> odds_so_far(101, 0);\n  // vector<vector<int>> is faster than vector<int>\n  std::vector<std::vector<int>> odds(10, vector<int>());\n  for (int i = 0; i < 10; ++i) {\n    for (int j = 0; j < 10; ++j) {\n      if (j > i)\n        odds[i][j] += std::count_if(\n            lst.begin() + std::abs(j - i),\n            lst.begin() + std::abs(j),\n            [](const std::string &s) {\n              return s[0] == s[j];\n            });\n    }\n  }\n  for (int i = 0; i < 10; ++i) {\n    for (int j = 0; j < 10; ++j) {\n      odds_so_far[i] += odds[i][j];\n    }\n  }\n  std::vector<std::string> ans;\n  ans.push_back(to_string(i) + \" odd digits in \" + lst[0]);\n  for (int i = 1; i < 10; ++i) {\n    ans.push_back(to_string(std::abs(i - 1)) + \" odd digits in \" +\n                  to_string(odds_so_far[i]));\n  }\n  return ans;",
    "grade-2": {
      "execution": 0
    },
    "3": "// Your code here\n  std::vector<std::string> odd;\n  int i = 1;\n  for (std::string str : lst) {\n    int odd_number = 0;\n    for (char x : str) {\n      if (x%2 != 0) {\n        odd_number++;\n      }\n    }\n    std::stringstream ss;\n    ss << \"the number of odd elements \" << odd_number << \"n the str\" << i\n       << \"ng \" << i << \" of the \" << i << \"nput.\";\n    odd.push_back(ss.str());\n    i++;\n  }\n  return odd;",
    "grade-3": {
      "execution": 0
    },
    "4": "std::vector<std::string> result;\n    for (auto s : lst) {\n        int i = 0;\n        for (auto c : s) {\n            if (c - '0' % 2 == 1)\n                i++;\n        }\n        std::string temp = \"the number of odd elements \" + std::to_string(i) + \"n the str\" + std::to_string(i) + \"ng \" + std::to_string(i) + \" of the \" + std::to_string(i) + \"nput.\";\n        result.push_back(temp);\n    }\n    return result;",
    "grade-4": {
      "execution": 0
    },
    "5": "std::vector<std::string> result;\n  for (int i = 0; i < lst.size(); i++) {\n    std::string temp = lst[i];\n    int odd = 0;\n    for (int j = 0; j < temp.size(); j++) {\n      int num = temp[j] - '0';\n      if (num % 2 != 0) {\n        odd++;\n      }\n    }\n    std::string s = \"the number of odd elements \" + std::to_string(odd) +\n      \"n the str\" + std::to_string(odd) + \"ng \" + std::to_string(odd) +\n      \" of the \" + std::to_string(odd) + \"nput.\";\n    result.push_back(s);\n  }\n  return result;",
    "grade-5": {
      "execution": 1
    }
  },
  {
    "intent": "#include<assert.h>\n#include<bits/stdc++.h>\n// Add two numbers x and y\n// >>> add(2, 3)\n// 5\n// >>> add(5, 7)\n// 12\nlong add(long x, long y) {\n",
    "task_id": "53",
    "prompt": "/*\nAdd two numbers x and y\n>>> add(2, 3)\n5\n>>> add(5, 7)\n12\n*/\n#include<stdio.h>\n#include<stdlib.h>\nusing namespace std;\nint add(int x,int y){\n",
    "simplified_intent": "Add two numbers x and y",
    "snippet": [
      "    return x+y;\n}\n"
    ],
    "sample_from": {
      "0": "incoder",
      "1": "incoder",
      "2": "incoder",
      "3": "codex",
      "4": "codex",
      "5": "codex"
    },
    "0": "long sum = 0;\n    for (; x > 0 && y > 0; x--, y--)\n        sum += (x & y) == 0 ? x : y;\n    return sum;",
    "grade-0": {
      "execution": 0
    },
    "1": "return x + y;",
    "grade-1": {
      "execution": 1
    },
    "2": "assert(x > 0);\n   assert(y > 0);\n   long ans = x + y;\n   return ans;",
    "grade-2": {
      "execution": 0
    },
    "3": "long result = x + y;\n\treturn result;",
    "grade-3": {
      "execution": 1
    },
    "4": "long ans = x+y;\n    return ans;",
    "grade-4": {
      "execution": 1
    },
    "5": "// TODO\n    if(x<0 && y<0)\n    {\n        return -(add(-x,-y));\n    }\n    long result=0;\n    long carry=0;\n    long i;\n    for(i=0;i<64;i++)\n    {\n        long m=x&1;\n        long n=y&1;\n        x=x>>1;\n        y=y>>1;\n        long p=m&n;\n        long q=m^n;\n        long r=carry&q;\n        carry=p|r;\n        q=q^r;\n        result=result|(q<<i);\n    }\n    return result;",
    "grade-5": {
      "execution": 0
    }
  },
  {
    "intent": "#include<assert.h>\n#include<bits/stdc++.h>\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome('')\n// ''\n// >>> make_palindrome('cat')\n// 'catac'\n// >>> make_palindrome('cata')\n// 'catac'\nstd::string make_palindrome(std::string string) {\n",
    "task_id": "10",
    "prompt": "#include<stdio.h>\n#include<string>\nusing namespace std;\nbool is_palindrome(string str){\n    //Test if given string is a palindrome \n    string s(str.rbegin(),str.rend());\n    return s==str;\n}\nstring make_palindrome(string str){\n    /*\n    Find the shortest palindrome that begins with a supplied string. \n    Algorithm idea is simple: - Find the longest postfix of supplied string that is a palindrome. \n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome(\"\") \n    \"\" \n    >>> make_palindrome(\"cat\") \n    \"catac\" \n    >>> make_palindrome(\"cata\") \n    \"catac\" \n    */\n",
    "simplified_intent": "Test if given string is a palindrome",
    "snippet": [
      "   int i;\n   for (i=0;i<str.length();i++)\n   {\n        string rstr=str.substr(i);\n        if (is_palindrome(rstr))\n        {\n            string nstr;\n            nstr=str.substr(0,i);\n            string n2str(nstr.rbegin(),nstr.rend());\n            return str+n2str;\n        }\n   }\n   string n2str(str.rbegin(),str.rend());\n   return str+n2str;\n}\n"
    ],
    "sample_from": {
      "0": "incoder",
      "1": "incoder",
      "2": "incoder",
      "3": "codex",
      "4": "codex",
      "5": "codex"
    },
    "0": "int size = string.length();\n    std::string new_string;\n    // Find the longest postfix of supplied string that is a palindrome.\n    int start_index = 0;\n    int end_index = 0;\n    int longest = 0;\n    for (int i = 0; i < size; i++) {\n        if (string[i] == '(') {\n            if (longest == 0) {\n                start_index = i;\n            }\n        } else if (string[i] == ')') {\n            if (longest > 0) {\n                end_index = i - longest;\n            }\n        } else if (string[i] == string[size - i - 1]) {\n            longest++;\n        }\n    }\n    // Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    if (end_index == start_index) return string;\n    new_string.assign(string);\n    new_string += string.substr(start_index, end_index + 1);\n    return new_string;",
    "grade-0": {
      "execution": 0
    },
    "1": "std::string revstring;\n    size_t revstringsize = 0;\n\n    for (auto it=string.rbegin(); it!=string.rend(); ++it) {\n        string temp(string, it);\n        revstring += temp;\n        revstringsize += temp.size();\n    }\n\n    auto revit = revstring.rbegin();\n    revstring.resize(revstringsize);\n    size_t len = 0;\n    for (; revit!=revstring.rend(); ++revit, ++len) {\n        revstring.insert(revit, *revit);\n    }\n    return revstring;",
    "grade-1": {
      "execution": 0
    },
    "2": "// Find the longest postfix that is a palindrome by adding one\n    int max_length = 0;\n    for (size_t i = 0; i < string.length(); ++i) {\n        int pos = string.length() - i;\n        if (string[pos] != string[string.length() - 1 - i]) {\n            break;\n        }\n        ++max_length;\n    }\n    // Append prefix and suffix of longest postfix palindrome to original string\n    string prefix = string.substr(0, i);\n    string suffix = string.substr(string.length() - max_length);\n    return prefix + suffix;",
    "grade-2": {
      "execution": 0
    },
    "3": "int i = 0;\n    int j = string.size() - 1;\n    while (i < j) {\n        if (string[i] == string[j]) {\n            i++;\n            j--;\n        } else {\n            i = 0;\n            j--;\n        }\n    }\n    std::string prefix = string.substr(0, i);\n    std::reverse(prefix.begin(), prefix.end());\n    return string + prefix;",
    "grade-3": {
      "execution": 0
    },
    "4": "if (string.empty()) {\n    return string;\n  }\n  std::string end_string;\n  auto it = string.begin();\n  while (it != string.end()) {\n    std::string prefix_string = std::string(string.begin(), it);\n    if (prefix_string == std::string(prefix_string.rbegin(), prefix_string.rend())) {\n      end_string = std::string(prefix_string.rbegin(), prefix_string.rend());\n      break;\n    }\n    ++it;\n  }\n  return string + end_string;",
    "grade-4": {
      "execution": 0
    },
    "5": "std::string reversed = string;\n    std::reverse(reversed.begin(), reversed.end());\n    int position = string.find(reversed);\n    if (position != std::string::npos) {\n        return string + reversed.substr(position + 1);\n    }\n    return string + reversed;",
    "grade-5": {
      "execution": 0
    }
  },
  {
    "intent": "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a list of numbers, return the sum of squares of the numbers\n// in the list that are odd. Ignore numbers that are negative or not integers.\n// double_the_difference([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10\n// double_the_difference([-1, -2, 0]) == 0\n// double_the_difference([9, -2]) == 81\n// double_the_difference([0]) == 0  \n// If the input list is empty, return 0.\nlong double_the_difference(std::vector<float> lst) {\n",
    "task_id": "151",
    "prompt": "/*\nGiven a vector of numbers, return the sum of squares of the numbers\nin the vector that are odd. Ignore numbers that are negative or not integers.\n\ndouble_the_difference({1, 3, 2, 0}) == 1 + 9 + 0 + 0 = 10\ndouble_the_difference({-1, -2, 0}) == 0\ndouble_the_difference({9, -2}) == 81\ndouble_the_difference({0}) == 0  \n\nIf the input vector is empty, return 0.\n*/\n#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\nlong long double_the_difference(vector<float> lst){\n",
    "simplified_intent": "Given a list of numbers, return the sum of squares of the numbers in the list that are odd. Ignore numbers that are negative or not integers. If the input list is empty, return 0.",
    "snippet": [
      "    long long sum=0;\n    for (int i=0;i<lst.size();i++)\n    if (lst[i]-round(lst[i])<1e-4)\n    if (lst[i]>0 and (int)(round(lst[i]))%2==1) sum+=(int)(round(lst[i]))*(int)(round(lst[i]));\n    return sum;\n}\n"
    ],
    "sample_from": {
      "0": "incoder",
      "1": "incoder",
      "2": "incoder",
      "3": "codex",
      "4": "codex",
      "5": "codex"
    },
    "0": "if (lst.size() <= 0) {\n        return 0;\n    }\n    \n    // Step 1: Sort the list to reduce search space and performance\n    // of subsequent steps.\n    std::sort(lst.begin(), lst.end());\n    \n    // Step 2: Loop through the sorted list and check adjacent elements\n    // to find the odd numbers.\n    long sum = 0;\n    for (int i = 0; i < lst.size() - 1; i++) {\n        if (lst[i] % 2 != 0) {\n            sum += (lst[i] - lst[i + 1]) * (lst[i] - lst[i + 1]);\n        }\n    }\n    \n    // Step 3: Return sum if all numbers in the list are odd.\n    return sum;",
    "grade-0": {
      "execution": 0
    },
    "1": "int n = lst.size();\n\tlong sum = 0;\n\tfloat x = lst[0];\n\tfor (int i = 1; i < n; i++) {\n\t\tif (lst[i] > 0 && lst[i] % 2 != 0) {\n\t\t\tsum += x*x;\n\t\t}\n\t\tx += lst[i];\n\t}\n\treturn sum;",
    "grade-1": {
      "execution": 0
    },
    "2": "long ans = 0.0;\n    for (int i = 0; i < lst.size(); i++)\n    {\n        if (lst[i] < 0)\n        {\n            ans += lst[i] * lst[i];\n        }\n        else if (lst[i] > 0)\n        {\n            if (lst[i] & 1)\n            {\n                ans += lst[i];\n            }\n            else\n            {\n                ans += (lst[i] - 1) * (lst[i] - 1);\n            }\n        }\n    }\n    return ans;",
    "grade-2": {
      "execution": 0
    },
    "3": "int sum = 0;\n    for(int i = 0; i < lst.size(); i++) {\n        if(lst[i] < 0) continue;\n        if(lst[i] - int(lst[i]) != 0) continue;\n        if(lst[i] % 2 == 0) continue;\n        sum += lst[i] * lst[i];\n    }\n    return sum;",
    "grade-3": {
      "execution": 0
    },
    "4": "long sum = 0;\n    for(float num : lst) {\n        if(num >= 0 && (int)num == num && num%2 != 0)\n            sum += num*num;\n    }\n    return sum;",
    "grade-4": {
      "execution": 0
    },
    "5": "float sum=0;\n    for(int i=0;i<lst.size();i++)\n    {\n        if(lst[i]>0 && int(lst[i])==lst[i])\n        {\n            if(lst[i]%2!=0)\n            {\n                sum+=(lst[i]*lst[i]);\n            }\n        }\n    }\n    return sum;",
    "grade-5": {
      "execution": 0
    }
  },
  {
    "intent": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string s.\n// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains no letters, reverse the string.\n// The function should return the resulted string.\n// Examples\n// solve(\"1234\") = \"4321\"\n// solve(\"ab\") = \"AB\"\n// solve(\"#a@C\") = \"#A@c\"\nstd::string solve(std::string s) {\n",
    "task_id": "161",
    "prompt": "/*\nYou are given a string s.\nif s[i] is a letter, reverse its case from lower to upper or vise versa, \notherwise keep it as it is.\nIf the string contains no letters, reverse the string.\nThe function should return the resulted string.\nExamples\nsolve(\"1234\") = \"4321\"\nsolve(\"ab\") = \"AB\"\nsolve(\"#a@C\") = \"#A@c\"\n*/\n#include<stdio.h>\n#include<string>\nusing namespace std;\nstring solve(string s){\n",
    "simplified_intent": "You are given a string s. if s[i] is a letter, reverse its case from lower to upper or vise versa, otherwise keep it as it is. If the string contains no letters, reverse the string. The function should return the resulted string.",
    "snippet": [
      "    int nletter=0;\n    string out=\"\";\n    for (int i=0;i<s.length();i++)\n    {\n        char w=s[i];\n        if (w>=65 and w<=90) w=w+32;\n        else if (w>=97 and w<=122) w=w-32;\n        else nletter+=1;\n        out=out+w;\n    }\n    if (nletter==s.length())\n    {\n        string p(s.rbegin(),s.rend());\n        return p;\n    }\n    else return out;\n}\n"
    ],
    "sample_from": {
      "0": "incoder",
      "1": "incoder",
      "2": "incoder",
      "3": "codex",
      "4": "codex",
      "5": "codex"
    },
    "0": "char result[s.length()];\n    for(int i = 0; i < s.length(); i++){\n        char c = s[i];\n        if((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z')){\n            std::swap(s[i], s[i]);\n        }\n    }\n    for(int i = 0; i < s.length(); i++){\n        char c = s[i];\n        if((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z')){\n            int pos = (c-'a') + 2;\n            int ind = i - pos;\n            result[i] = 'a' + ind;\n        }\n        else{\n            result[i] = s[i];\n        }\n    }\n    return std::string(result);",
    "grade-0": {
      "execution": 0
    },
    "1": "std::map<char, int> m;\n    for (auto i : s) {\n        m[i] = m[std::tolower(i)];\n        if (m[std::tolower(i)] == 0) {\n            m[std::tolower(i)] = i;\n        }\n    }\n    std::string answer;\n    for (auto i : s) {\n        answer[m.at(i)] = i;\n    }\n    return answer;",
    "grade-1": {
      "execution": 0
    },
    "2": "std::string t;\n    for(int i = 0; i < s.size(); i++) {\n        if(isalpha(s[i])) {\n            // Reverse from lower to upper\n            std::swap(s[i], s[sizeof(s) - i - 1]);\n        }\n        // If the string contains no letters, reverse the string\n        else {\n            std::swap(s[i], s[s.size() - i - 1]);\n        }\n    }\n    return t;",
    "grade-2": {
      "execution": 0
    },
    "3": "std::string t;\n\tif (s.size() == 0)\n\t\treturn s;\n\tbool flag = true;\n\tfor (auto& c : s) {\n\t\tif (std::isalpha(c)) {\n\t\t\tflag = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (flag) {\n\t\tstd::reverse(s.begin(), s.end());\n\t\treturn s;\n\t}\n\telse {\n\t\tfor (auto& c : s) {\n\t\t\tif (std::isalpha(c)) {\n\t\t\t\tif (std::isupper(c))\n\t\t\t\t\tt += tolower(c);\n\t\t\t\telse\n\t\t\t\t\tt += toupper(c);\n\t\t\t}\n\t\t\telse\n\t\t\t\tt += c;\n\t\t}\n\t\treturn t;\n\t}",
    "grade-3": {
      "execution": 1
    },
    "4": "if(s.empty())\n    return \"\";\n    std::string result;\n    for(int i=0;i<s.length();i++)\n    {\n        if(s[i]>='a' && s[i]<='z')\n        {\n            s[i]='A'+s[i]-'a';\n        }\n        else if(s[i]>='A' && s[i]<='Z')\n        {\n            s[i]='a'+s[i]-'A';\n        }\n    }\n    return s;",
    "grade-4": {
      "execution": 0
    },
    "5": "if(s.length() == 0)\n        return s;\n    for(int i = 0; i < s.length(); i++) {\n        if(isalpha(s[i])) {\n            if(islower(s[i]))\n                s[i] = toupper(s[i]);\n            else\n                s[i] = tolower(s[i]);\n        }\n    }\n    return s;",
    "grade-5": {
      "execution": 0
    }
  },
  {
    "intent": "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a list of positive integers x. return a sorted list of all \n// elements that hasn't any even digit.\n// Note: Returned list should be sorted in increasing order.\n// For example:\n// >>> unique_digits([15, 33, 1422, 1])\n// [1, 15, 33]\n// >>> unique_digits([152, 323, 1422, 10])\n// []\nstd::vector<long> unique_digits(std::vector<long> x) {\n",
    "task_id": "104",
    "prompt": "/*\nGiven a vector of positive integers x. return a sorted vector of all \nelements that hasn't any even digit.\n\nNote: Returned vector should be sorted in increasing order.\n\nFor example:\n>>> unique_digits({15, 33, 1422, 1})\n{1, 15, 33}\n>>> unique_digits({152, 323, 1422, 10})\n{}\n*/\n#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nvector<int> unique_digits(vector<int> x){\n",
    "simplified_intent": "Given a list of positive integers x. return a sorted list of all elements that hasn't any even digit. Note: Returned list should be sorted in increasing order.",
    "snippet": [
      "    vector<int> out={};\n    for (int i=0;i<x.size();i++)\n        {\n            int num=x[i];\n            bool u=true;\n            if (num==0) u=false;\n            while (num>0 and u)\n            {\n                if (num%2==0) u=false;\n                num=num/10;\n            }\n            if (u) out.push_back(x[i]);\n        }\n    sort(out.begin(),out.end());\n    return out;\n}\n"
    ],
    "sample_from": {
      "0": "incoder",
      "1": "incoder",
      "2": "incoder",
      "3": "codex",
      "4": "codex",
      "5": "codex"
    },
    "0": "assert(x.size() == 10);\n  std::vector<long> ans;\n  std::set<long> seen;\n  for (int i = 0; i < 10; i++) {\n    if (!seen.insert(x[i]).second) {\n      ans.push_back(x[i]);\n    }\n  }\n  return ans;",
    "grade-0": {
      "execution": 0
    },
    "1": "std::vector<long> v;\n    for(long y : x)\n    {\n        if(y%2 != 0)\n        {\n            v.push_back(y);\n        }\n    }\n    sort(v.begin(), v.end());\n    return v;",
    "grade-1": {
      "execution": 0
    },
    "2": "// sort the list\n    std::sort(x.begin(), x.end());\n    // find out if the x has any even digit\n    std::vector<bool> isEven(x.size(), false);\n    long sum = 0;\n    for (long &i : x) {\n        isEven[i] = sum % 2 == 0;\n        sum += i;\n    }\n\n    // if no even digit, just return x\n    for (long &i : x) {\n        if (!isEven[i]) {\n            return x;\n        }\n    }\n\n    // otherwise, we can use isEven to find out all odd ones\n    // use std::set to prevent duplicate elements\n    std::set<long> odds;\n    for (long &i : x) {\n        if (!isEven[i]) {\n            odds.insert(i);\n        }\n    }\n\n    // finally return the odd ones in sorted order\n    std::vector<long> res(odds.begin(), odds.end());\n    std::sort(res.begin(), res.end());\n    return res;",
    "grade-2": {
      "execution": 0
    },
    "3": "// your code here\n    long n = x.size();\n    int count;\n    std::vector<long> res;\n    for(int i=0;i<n;i++){\n    \tcount = 0;\n    \twhile(x[i]!=0){\n    \t\tif(x[i]%2==0){\n    \t\t\tcount++;\n    \t\t}\n    \t\tx[i]/=10;\n    \t}\n    \tif(count==0){\n    \t\tres.push_back(x[i]);\n    \t}\n    }\n    sort(res.begin(),res.end());\n    return res;",
    "grade-3": {
      "execution": 0
    },
    "4": "long size=x.size();\n  std::vector<long> v;\n  long i=0;\n  while(i<size){\n    int flag=0;\n    long number=x[i];\n    while(number>0){\n      if(number%10==0 || number%10==2 || number%10==4 || number%10==6 || number%10==8){\n        flag=1;\n        break;\n      }\n      number=number/10;\n    }\n    if(flag==0){\n      v.push_back(x[i]);\n    }\n    i++;\n  }\n  sort(v.begin(),v.end());\n  return v;",
    "grade-4": {
      "execution": 1
    },
    "5": "// Your code here\n    std::vector<long>sorted;\n    for(auto x1:x){\n        int count=0;\n        long temp=x1;\n        int r;\n        do{\n             r=temp%10;\n            if(r%2==0){\n                count++;\n            }\n             temp=temp/10;\n        }while(temp!=0);\n        if(count==0){\n            sorted.push_back(x1);\n        }\n    }\n    std::sort(sorted.begin(),sorted.end());\n    return sorted;",
    "grade-5": {
      "execution": 1
    }
  },
  {
    "intent": "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string representing a space separated lowercase letters, return a dictionary\n// of the letter with the most repetition and containing the corresponding count.\n// If several letters have the same occurrence, return all of them.\n// Example:\n// histogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\n// histogram('a b b a') == {'a': 2, 'b': 2}\n// histogram('a b c a b') == {'a': 2, 'b': 2}\n// histogram('b b b b a') == {'b': 4}\n// histogram('') == {}\nstd::map<std::string, long> histogram(std::string test) {\n",
    "task_id": "111",
    "prompt": "/*\nGiven a string representing a space separated lowercase letters, return a map\nof the letter with the most repetition and containing the corresponding count.\nIf several letters have the same occurrence, return all of them.\n\nExample:\nhistogram(\"a b c\") == {{\"a\", 1}, {\"b\", 1}, {\"c\", 1}}\nhistogram(\"a b b a\") == {{\"a\", 2}, {\"b\", 2}}\nhistogram(\"a b c a b\") == {{\"a\", 2}, {\"b\", 2}}\nhistogram(\"b b b b a\") == {{\"b\", 4}}\nhistogram(\"\") == {}\n\n*/\n#include<stdio.h>\n#include<string>\n#include<map>\nusing namespace std;\nmap<char,int> histogram(string test){\n",
    "simplified_intent": "Given a string representing a space separated lowercase letters, return a dictionary of the letter with the most repetition and containing the corresponding count. If several letters have the same occurrence, return all of them.",
    "snippet": [
      "    map<char,int> count={},out={};\n    map <char,int>::iterator it;\n    int max=0;\n    for (int i=0;i<test.length();i++)\n        if (test[i]!=' ')\n        {\n            count[test[i]]+=1;\n            if (count[test[i]]>max) max=count[test[i]];\n        }\n    for (it=count.begin();it!=count.end();it++)\n    {\n        char w1=it->first;\n        int w2=it->second;\n        if (w2==max) out[w1]=w2;\n    }\n    return out;\n}\n"
    ],
    "sample_from": {
      "0": "incoder",
      "1": "incoder",
      "2": "incoder",
      "3": "codex",
      "4": "codex",
      "5": "codex"
    },
    "0": "std::map<std::string, long> res;\n  long maxCount = 0;\n  for (char &c : test) {\n    c = tolower(c);\n    if (res.count(c) > 0) {\n      res[c] += 1;\n    } else {\n      res[c] = 1;\n    }\n    if (res[c] > maxCount) {\n      maxCount = res[c];\n    }\n  }\n  return res;",
    "grade-0": {
      "execution": 0
    },
    "1": "std::map<std::string, long> m;\n  std::string str = test;\n  for (auto c : str) {\n    auto it = m.find(c);\n    if (it == m.end()) {\n      m[c] = 1;\n    } else {\n      it->second++;\n    }\n  }\n  return m;",
    "grade-1": {
      "execution": 0
    },
    "2": "long maxVal = 0;\n    long maxKey = test.size();\n    std::map<std::string, long> dict;\n    for(size_t i = 0; i < test.size(); ++i) {\n        // count all characters in test\n        long val = test.at(i) - 'a';\n        // if count is higher than maxVal, update the maxKey and maxVal\n        if(val > maxVal) {\n            maxKey = i;\n            maxVal = val;\n        }\n        // if count is the same as the maxVal, add the key to the dictionary\n        else if(val == maxVal) {\n            dict[test.at(i)] = dict[test.at(i)] + (i == 0 ? 1 : 0);\n        }\n        // if the count is lower than maxVal, set the count to 0\n        else if(val < maxVal) {\n            dict[test.at(i)] = 0;\n        }\n    }\n    return dict;",
    "grade-2": {
      "execution": 0
    },
    "3": "// Your code here\n  std::map<std::string, long>  m;\n  std::stringstream ss(test);\n  std::string temp;\n  while(ss >> temp)\n  {\n      if(m.find(temp) == m.end())\n      {\n          m[temp] = 1;\n      }\n      else\n      {\n          m[temp]++;\n      }\n  }\n  return m;",
    "grade-3": {
      "execution": 0
    },
    "4": "std::map<std::string, long> ret;\n    std::stringstream ss(test);\n    std::string word;\n    while(ss >> word) {\n        ret[word]++;\n    }\n    return ret;",
    "grade-4": {
      "execution": 0
    },
    "5": "std::map<std::string, long> results;\n    if (test.length() == 0) return results;\n    std::istringstream iss(test);\n    std::string token;\n    while (std::getline(iss, token, ' ')) {\n        if (results.find(token) == results.end()) {\n            results[token] = 1;\n        } else {\n            results[token] += 1;\n        }\n    }\n    long most_occurrences = 0;\n    std::map<std::string, long> final_results;\n    for (auto it : results) {\n        if (it.second > most_occurrences) {\n            most_occurrences = it.second;\n            final_results.clear();\n            final_results[it.first] = it.second;\n        } else if (it.second == most_occurrences) {\n            final_results[it.first] = it.second;\n        }\n    }\n    return final_results;",
    "grade-5": {
      "execution": 1
    }
  },
  {
    "intent": "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input list of strings only for ones that contain given substring\n// >>> filter_by_substring([], 'a')\n// []\n// >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n// ['abc', 'bacd', 'array']\nstd::vector<std::string> filter_by_substring(std::vector<std::string> strings, std::string substring) {\n",
    "task_id": "7",
    "prompt": "/*\nFilter an input vector of strings only for ones that contain given substring\n>>> filter_by_substring({}, \"a\")\n{}\n>>> filter_by_substring({\"abc\", \"bacd\", \"cde\", \"vector\"}, \"a\")\n{\"abc\", \"bacd\", \"vector\"}\n*/\n#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\nvector<string> filter_by_substring(vector<string> strings, string substring){\n",
    "simplified_intent": "Filter an input list of strings only for ones that contain given substring",
    "snippet": [
      "    vector<string> out;\n    for (int i=0;i<strings.size();i++)\n    {\n        if (strings[i].find(substring)!=strings[i].npos)\n        out.push_back(strings[i]);\n    }\n    return out;\n}\n"
    ],
    "sample_from": {
      "0": "incoder",
      "1": "incoder",
      "2": "incoder",
      "3": "codex",
      "4": "codex",
      "5": "codex"
    },
    "0": "for (size_t i = 0; i < strings.size(); i++) {\n    if (strings[i].find(substring) != strings[i].npos)\n      strings.erase(strings.begin() + i);\n  }\n  return strings;",
    "grade-0": {
      "execution": 0
    },
    "1": "// Create a vector of all substrings\n    std::vector<std::string> substrings;\n    // Iterate through each string and add all substrings\n    for(int i = 0; i < strings.size(); i++)\n    {\n        auto it = std::find_if(strings.begin(), strings.end(), [&](const string& str) { return str.find(substring) != std::string::npos; });\n        if(it != strings.end())\n        {\n            substrings.push_back(it->c_str());\n        }\n    }\n    // Return all strings that contain the substring\n    return substrings;",
    "grade-1": {
      "execution": 0
    },
    "2": "std::vector<std::string> result;\n    auto it = std::find_if(strings.begin(), strings.end(), [substring] (std::string s) {\n        if (s.find(substring) == std::string::npos) return true;\n        return false;\n    });\n    while (it != strings.end()) {\n        result.push_back(*it);\n        it++;\n    }\n    return result;",
    "grade-2": {
      "execution": 0
    },
    "3": "for (std::vector<std::string>::iterator it = strings.begin(); it != strings.end();) {\n        if ((*it).find(substring) == std::string::npos) {\n            it = strings.erase(it);\n        } else {\n            ++it;\n        }\n    }\n    return strings;",
    "grade-3": {
      "execution": 1
    },
    "4": "std::vector<std::string> filtered;\n\tstd::copy_if(strings.begin(), strings.end(), std::back_inserter(filtered),\n\t\t[&substring](std::string s) {\n\t\t\treturn s.find(substring) != std::string::npos;\n\t\t});\n\treturn filtered;",
    "grade-4": {
      "execution": 1
    },
    "5": "std::vector<std::string> res;\n\tfor (std::string s : strings) {\n\t\tif (s.find(substring) != std::string::npos) {\n\t\t\tres.push_back(s);\n\t\t}\n\t}\n\treturn res;",
    "grade-5": {
      "execution": 1
    }
  }
]